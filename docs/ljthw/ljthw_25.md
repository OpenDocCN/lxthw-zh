## 练习 24：随机选择数字

我们将在一些练习中花一些时间来学习编程书中并不总是看到的东西：如何让计算机在某个范围内选择一个“随机”数。这是因为你可以写*很多*的软件而不需要计算机随机选择一个数字。然而，有随机数将让我们制作一些简单的互动游戏，这很容易就能弥补这个略微奇怪的概念的痛苦。

```java

 1 public class RandomNumbers
 2 {
 3     public static void main( String[] args )
 4     {
 5         int a, b, c;
 6         double x, y, z;
 7 
 8         x = Math.random();
 9         y = Math.random();
10         z = Math.random();
11 
12         System.out.println( "x is " + x );
13         System.out.println( "y is " + y );
14         System.out.println( "z is " + z );
15 
16         x = Math.random() * 100;
17         y = Math.random() * 100;
18         z = Math.random() * 100;
19 
20         System.out.println( "\nx is " + x );
21         System.out.println( "y is " + y );
22         System.out.println( "z is " + z );
23 
24         a = (int)x;
25         b = (int)y;
26         c = (int)z;
27 
28         System.out.println( "\na is " + a );
29         System.out.println( "b is " + b );
30         System.out.println( "c is " + c );
31 
32         x = 0.9999999999999999;
33         a = (int)(x * 100);
34 
35         System.out.println( "\nx is " + x );
36         System.out.println( "a is " + a );
37 
38         x = Math.random();
39         a = 0 + (int)(x*10);
40         b = 1 + (int)(x*10);
41         c = 5 + (int)(x*10);
42 
43         System.out.println( "\na is " + a );
44         System.out.println( "b is " + b );
45         System.out.println( "c is " + c );
46     }
47 }
```



### 你应该看到什么

```java

x is 0.5371428668784091
y is 0.4716636154720313
z is 0.9791002546275134
x is 57.33269918363617
y is 44.731436970719386
z is 75.79286027183542
a is 57
b is 44
c is 75
x is 0.9999999999999999
a is 99
a is 6
b is 7
c is 11

```


注意：你的输出不会和我的一样。记住，这些数字是随机的。

Java 有一个内置的函数叫做`Math.random()`。每次调用这个函数，它都会产生一个新的随机`double`，范围在[0,1)之间（也就是说，它可能正好是`0`，但永远不会正好是`1`，而且很可能是介于两者之间的某个值）。所以如果我写：

```java

double x = Math.random();
```

...然后 x 可能有一个值为`0`，或`0.123544`，或`0.3`，或`0.999999999`，但永远不会是`1.0`，也永远不会大于 1。所以在第 8 到 10 行，函数`Math.random()`被调用了三次，并且结果被存储到三个不同的变量中。这三个值被打印出来，这样你就可以看到它们是什么。

不幸的是，我经常不想要一个来自[0,1)的 double。想象一下一个猜数字的游戏，你说“我在想一个小数在零和一之间的数字：试着猜猜看！”这不好玩。而且我们无法控制`Math.random()`给我们的值的范围，所以我们必须自己将其压缩到一个范围内。

在第 16 到 18 行，我们选择一个新的随机数，但在存储到变量中之前将其乘以 100。（这会使小数点向右移动两位。）因此，我们可以知道在第 20 行打印出的原始随机数是`0.5733269918363617`，因为乘以 100 后变成了`57.33269918363617`。

请注意，乘以 100 仍然有可能得到恰好为`0`的情况。如果原始随机数是 0，那么乘以它不会改变。我们存储到变量中的数字可能是`12.3544`，或`30.0`，或`99.9999999`，但永远不会是`100.0`，也永远不会大于 100。

在第 24 到 26 行，我们执行了所谓的“类型转换”或者“转换”。变量 x 是一个双精度浮点数：它可以保存带有小数的数字。变量 a 是一个整数：它只能保存整数。通常情况下，你不允许将`double`的值存储到`int`中。转换告诉编译器“我知道 x 是一个 double，我试图将它的值存储到一个不能保存小数的`int`中。但我不在乎。你为什么不假装 x 的值是一个整数呢？如果你不得不舍弃小数点后的所有内容，也没关系。”

因此，在第 24 行，计算机复制了*x*的值，但小数点后的所有内容被截断并丢弃（“截断”），新的整数值存储到变量*a*中。（*x*的值不变。）这个值*不*是四舍五入的；它是被截断的。

理论上，这给了我们什么？如果 x 最初是`0`或`12.3544`或`30.0`，或`99.9999999`，那么 a 将是`0`或`12`或`30`或`99`，但永远不会是`100`或任何大于 100 的数字。因此，a、b 和 c 的值始终为 0 到 99 的整数值。

在第 32 和 33 行，我尝试表明从双精度浮点数到整数的转换*不*四舍五入；小数点后的数字被截断。

最后，在第 38 到 41 行，选择一个随机数。在所有三种情况下，它都被乘以 10，然后转换为整数。这意味着转换后我们总是得到一个从 0 到 9 的数字。

但是在第 39 行，从 0 到 9 的随机数加上`0`后存储到 a 中。（加`0`不改变数字。）

不改变数字。）因此*a*将始终是 0 到 9 的值。

在第 40 行，从 0 到 9 的随机数加上`1`后存储到 b 中。这使得它比原来大 1。如果原来是`0`，现在是`1`。如果原来是`6`，现在是`7`。如果原来是`9`（最大值），现在是`10`。因此，b 的值始终为 1 到 10。

在第 41 行，从 0 到 9 的随机数加上`5`后存储到 c 中。因此，c 将始终具有 5 到 14 的值。（这仍然是十个值。）

好了，今天就到这里吧。

### 学习演练

1.  移除第 24 行的转换。尝试编译程序。你得到什么错误消息？（然后把它放回去。）

1.  运行程序多次，并确认在第 28 到 30 行打印出的*a*、*b*和*c*始终具有 0 到 99 的值。

1.  用手指数一数，确认如果我有一个从 0 到 9 的数字，那么我可能有十个可能的数字。将随机数乘以十并截断会得到十种可能的结果（0­9）。将随机数乘以五并截断会得到五种可能的结果（0­4）。

1.  运行程序多次，并确认在第 43 行打印出的*a*始终具有 0 到 9 的值，*b*始终具有 1 到 10 的值，*c*始终具有 5 到 14 的值。

