# 学习 Java

# 艰难的方式

Graham Mitchell

版本 20130720.004

版权所有 2013 年 Graham Mitchell。保留所有权利。版本 20130720.004

10 09 08 07 06 05 XYZABC 04 03 02 01

## 前言

我已经教了超过 15 年的初学者如何编码。超过 2000 名学生参加了我的课程，离开时知道如何编写简单的程序。有些人只学会了一点，而其他人在短短几年内获得了令人难以置信的技能。

我相信几乎任何人都可以教一个天才孩子如何编码。“我教了我 9 岁的女儿编码，她 6 周后就做出了她的第一个安卓应用！”如果你是天才孩子，这本书不是为你写的。

我也相信没有什么能替代编写小程序。这就是你在这本书中要做的。你将输入小程序并运行它们。

#### “学习的最佳方式是实践。”

- P.R. Halmos

## 目录

+   前言：通过实践学习

+   介绍：Java 作为第一语言的挑战

+   练习 0：设置

+   练习 1：重要信息

+   练习 2：更多打印

+   练习 3：打印选择

+   练习 4：转义序列和注释

+   练习 5：在变量中保存信息

+   练习 6：数学运算

+   练习 7：从人类获取输入

+   练习 8：存储人类的回答

+   练习 9：使用用户输入进行计算

+   练习 10：变量只能保存值

+   练习 11：变量修改快捷方式

+   练习 12：布尔表达式（真或假）

+   练习 13：比较字符串

+   练习 14：复合布尔表达式（与、或、非）

+   练习 15：使用 if 语句做决定

+   练习 16：更多的 if 语句

+   练习 17：否则（带有 else 的 if 语句）

+   练习 18：带有字符串的 if 语句

+   练习 19：使用 if 和 else 进行互斥

+   练习 20：更多的 if 和 else 链

+   练习 21：嵌套的 if 语句

+   练习 22：使用大开关做决定

+   练习 23：更多字符串比较

+   练习 24：随机选择数字

+   练习 25：更复杂的随机数

+   练习 26：使用 while 循环重复自己

+   练习 27：猜数字游戏

+   练习 28：无限循环

+   练习 29：使用循环进行错误检查

+   练习 30：do-while 循环

+   练习 31：逐个添加值

+   练习 32：为骰子游戏添加值

+   练习 33：名为“猪”的骰子游戏

+   练习 34：调用函数

+   练习 35：调用函数绘制旗帜

+   练习 36：使用函数显示骰子

+   练习 37：从函数返回值

+   练习 38：形状的面积

+   练习 39：使用 Javadoc 重新访问 30 天

+   练习 40：导入标准库

+   练习 41：写入文件的程序

+   练习 42：从文件中获取数据

+   练习 43：保存高分

+   练习 44：使用 for 循环计数

+   练习 45：凯撒密码（循环遍历字符串）

+   练习 46：嵌套的 for 循环

+   练习 47：生成和过滤值

+   练习 48：数组-单个变量中的多个值

+   练习 49：在数组中查找东西

+   练习 50：说某物不在数组中

+   练习 51：没有 foreach 循环的数组

+   练习 52：最低温度

+   练习 53：邮寄地址（记录）

+   练习 54：来自文件的记录

+   练习 55：记录数组

+   练习 56：来自文件的记录数组（温度再访）

+   练习 57：一副扑克牌

+   练习 58：最终项目-文字冒险游戏

    ## 介绍：Java

    Java 不是初学者的语言。我相信大多数“初学者”Java 书籍只适用于已经懂得如何编码或者是天才的人。

    我可以教你 Java，即使你以前从未编程过，甚至不是天才。但我可能会有点作弊。

    我将教给您的是 Java。但它并不是*所有*的 Java。我必须略去一些部分，因为您还没有准备好。如果您认为自己*已经*准备好学习 Java 的更复杂部分，那么 1）您是错误的，2）请购买另一本书。市面上有很多书籍会比您应付得了的复杂性更快地向您展示 Java 所能提供的一切。

    特别是，我有一个*巨大*的遗漏：我将避免讨论面向对象编程（OOP）的话题。我相当肯定，不适应的初学者无法同时学会如何编写良好的代码和学习面向对象编程。我几乎从未见过这种方法奏效。

    我计划写一本后续书籍，*将*涵盖面向对象编程和 Java 的更复杂部分。但您应该先完成这本书。我教学生编程已经很多年了，我从来没有一位学生从大学来拜访我，说“我希望您在基础知识上花的时间少一些”。

    ### 您将学到什么

    +   如何安装 Java 编译器和文本编辑器来编写程序。

    +   如何创建、编译和运行您的第一个 Java 程序。

    +   变量和从用户和文件中获取输入。

    +   使用 if 语句做出决策

    +   循环

    +   数组

    +   记录

        在最后一章中，您将编写一个不那么简单的基于文本的冒险游戏，其中的关卡是从文本文件中加载的。您还应该能够编写一个基于文本的纸牌游戏，如红心或黑桃。

        ### 您将不会学到什么

    +   图形

    +   面向对象编程

    +   如何制作 Android 应用程序

我喜欢图形，在 Java 中与 C++相比并不难，但我无法涵盖所有内容并很好地教授基础知识，所以必须有所取舍。

在我看来，面向对象编程在入门书籍中没有立足之地。

Android 应用程序非常复杂，如果您是初学者，应用程序远远超出了您的能力。然而，本书中的内容不会*伤害*您制作应用程序的机会，而且更温和的学习节奏可能会让您坚持下去，而其他书籍可能会让您沮丧而放弃。

此外，我希望在这本书之后再写两本书。我的第二本书将涵盖 Java 中的图形和面向对象编程。我的第三本书将涵盖制作一个简单的 Android 应用程序，假设您已经完成了前两本书的学习。

### 如何阅读本书

尽管我提供了一个包含本书中所有练习源代码的压缩文件，但您应该自己输入代码。

对于每个练习，都要自己手动输入代码。否则你怎么学呢？我的以前的学生从来没有通过仅仅阅读他人的代码就成为了优秀的程序员。

完成学习练习，如果有的话。完成挑战任务，如果有的话。到最后，您将能够编写一些代码。

### 许可证

本书的一些章节可以免费在线阅读，但您不得为他人制作副本。除非另有说明，所有内容均受版权法保护，版权归 Graham Mitchell 所有。

## 练习 0：设置

这个练习没有代码，但**不要跳过它**。这将帮助您安装一个体面的文本编辑器并安装 Java 开发工具包（JDK）。如果您不做这两件事，您将无法完成本书中的任何其他练习。您应该尽可能准确地遵循这些说明。

#### 警告！

这个练习需要您在终端窗口（也称为“shell”，“控制台”或“命令提示符”）中执行操作。如果您没有终端窗口的经验，那么您可能需要先学习一下。

[Zed Shaw 的出色的命令行快速入门课程在](http://cli.learncodethehardway.org/book/) http://cli.learncodethehardway.org/book/，将教您如何在 Windows 上使用 PowerShell 或在 OS X 上使用终端或在 Linux 上使用“bash”。

### Mac OS X

要完成这个练习，完成以下任务：

1.  [转到](http://www.barebones.com/products/textwrangler/) http://www.barebones.com/products/textwrangler/，使用您的网络浏览器。下载 TextWrangler 文本编辑器并安装它。

1.  将 TextWrangler 放在您的 Dock 中，以便您可以轻松访问它。

1.  找到一个名为“终端”的程序。（如果需要，进行搜索。）

1.  也将终端放在您的 Dock 中。

1.  启动终端。

1.  在终端程序中，键入`javac ­version`并按`RETURN`。您应该会看到一个类似`javac 1.7.0_04`的响应。如果`javac`后面的数字不完全相同，只要是 1.6 或更高都可以。但如果出现错误消息，您可能需要安装 JDK。

1.  完成后，您应该回到提示符。

1.  学习如何从终端创建一个文件夹（创建一个目录）。创建一个目录，以便您可以将本书中的所有代码放入其中。

1.  学习如何从终端切换到这个新目录。切换到它。

1.  使用文本编辑器（TextWrangler）创建一个名为`test.txt`的文件，并将其保存到您刚刚创建的目录中。

1.  只使用键盘切换窗口返回到终端。

1.  回到终端，查看是否可以列出目录的内容以查看您新创建的文件。

### OS X：您应该看到的内容

我目前无法访问 Mac，所以这是 Zed 在他的计算机终端上按照上述步骤操作的情况。您的计算机可能会有所不同，因此看看您能否找出他所做的事情和您应该做的事情之间的所有差异。

```java

Last login: Fri Jul 19 00:56:54 on ttys001
```

+   ```java
    $ javac ­version javac 1.6.22
    ```

+   ```java
    $ mkdir javacode
    ```

+   ```java
    $ cd javacode javacode $ ls
    ```

```java
# ... Use TextWrangler here to edit test.txt....
javacode $ ls test.txt javacode $
```

### Windows

1.  [转到](http://notepad/) http://notepad­plus­plus.org/，使用您的网络浏览器，获取 Notepad++文本编辑器，并安装它。您不需要是管理员才能这样做。

1.  确保您可以轻松访问 Notepad++，将其放在桌面和/或快速启动栏上。这两个选项都可以在安装过程中选择。

1.  从开始菜单运行 PowerShell。搜索它，然后按 Enter 运行。

1.  在桌面和/或快速启动栏上创建 PowerShell 的快捷方式，以方便使用。

1.  [转到](http://www.oracle.com/technetwork/java/javase/downloads/) http://www.oracle.com/technetwork/java/javase/downloads/，使用您的网络浏览器。

    1.  点击左上角的“Java”按钮，下载 Java 平台（JDK）7u25\. 点击后会跳转到另一个页面。

    1.  在此页面上，您需要接受许可协议，然后选择列表底部的“Windows x86”版本。下载文件。

    1.  下载完成后，运行`jdk­7u25­windows­i586.exe`进行安装。点击“下一步>”后，您将首次看到一个屏幕，上面写着`安装到：C:\Program` `Files (x86)\Java\jdk1.7.0_25\`或类似的内容。记下这个位置，您很快就会需要它。

1.  安装 JDK 后，您需要找出安装位置的确切名称。在`C:`驱动器内查看`Program Files`文件夹或`C:\Program` `Files (x86)`文件夹（如果有的话）。您要找的是一个名为`Java`的文件夹。里面有一个名为`jdk1.7.0_25`的文件夹，里面有一个名为`bin`的文件夹。文件夹名称必须包含`jdk1.7`；`jre7`不一样。确保有一个`bin`文件夹。

1.  进入此文件夹后，您可以在文件夹位置左键单击，它将变成类似`C:\Program Files (x86)\Java\jdk1.7.0_25\bin`的内容。您可以记下这个内容，或者将其高亮显示并右键单击复制到剪贴板。

1.  安装 JDK 并知道其位置后，打开您的终端窗口（PowerShell）。在 PowerShell 中，键入以下内容：

[Environment]::SetEnvironmentVariable("Path",

"$env:Path;C:\Program Files (x86)\Java\jdk1.7.0_25\bin", "User")

将所有内容放在一行上。

如果您将文件夹位置复制到剪贴板，那么您可以键入`$env:Path;`之前的所有内容，然后在 PowerShell 窗口中右键单击，它应该会为您粘贴文件夹名称。然后您只需完成这一行，输入`", "User")`并按`ENTER`。如果出现错误，您输入了错误的内容。您可以按上箭头将其取回，使用左右箭头找到并纠正错误，然后再次按`ENTER`。

1.  一旦`setEnvironmentVariable`命令完成而没有给出错误，通过在提示符处键入`exit`关闭 PowerShell 窗口。如果你不关闭它，你刚刚做的更改就不会生效。

1.  再次启动 PowerShell。

1.  在提示符处键入`javac ­version`。你应该会看到一个类似`javac 1.7.0_25`的响应。恭喜！如果你成功了，这本书的其余部分应该相对容易。

1.  之后，你应该回到一个闪烁的 PowerShell 提示符。

1.  学习如何从终端窗口（PowerShell）创建一个文件夹（创建一个目录）。创建一个目录，这样你就可以把这本书中的所有代码放进去。

1.  学习如何从提示符中切换到这个新目录。切换到它。

1.  使用你的文本编辑器（Notepad++）创建一个名为`test.txt`的文件，并将其保存到目录中

    你刚刚创建的。

1.  只使用键盘切换窗口回到终端。

1.  回到终端，看看你是否可以列出目录的内容，以查看你新创建的文件。

```java

Windows PowerShell
Copyright (C) 2009 Microsoft Corporation. All rights reserved.

PS C:\Users\Graham_Mitchell> javac ­version javac 1.7.0_25
PS C:\Users\Graham_Mitchell> mkdir javacode
```

```java
Directory: C:\Users\Graham_Mitchell\javacode
```

```java
PS C:\Users\Graham_Mitchell> cd javacode PS C:\Users\Graham_Mitchell\javacode> ls PS C:\Users\Graham_Mitchell\javacode>
... Here you would use Notepad++ to make test.txt in javacode ... PS C:\Users\Graham_Mitchell\javacode> ls
```

```java
Directory: C:\Users\Graham_Mitchell\javacode
```

### Windows：你应该看到的内容

```java

Mode
LastWriteTime
Length Name
­­­­
­­­­­­­­­­­­­
­­­­­­ ­­­­
d­­­­
7/19/2013 7:39 PM
javacode

Mode
LastWriteTime
Length Name
­­­­
­­­­­­­­­­­­­
­­­­­­ ­­­­
­a­­­
7/19/2013
7:45 PM
4 test.txt

PS C:\Users\Graham_Mitchell\javacode>
```

你可能会看到不同的提示和其他细微的差异，但你不应该会得到任何错误，这是一般的想法。

### Linux

Linux 有很多不同的版本，所以我将为最新版本的 Ubuntu 提供说明。如果你使用其他系统，你可能知道如何修改这些说明以适应你的设置。

1.  使用你的 Linux 软件包管理器安装`gedit`文本编辑器（可能只是称为“文本编辑器”）。

1.  确保你可以通过将其放在启动器中轻松地找到 gedit。

1.  运行 gedit，这样我们就可以更改一些默认设置，使其更适合程序员：

    1.  打开*首选项*并选择*编辑器*选项卡。

    1.  将选项卡宽度更改为 4。

    1.  在“自动缩进”旁边打上勾

    1.  打开*查看*选项卡，打开“显示行号”。

1.  找到你的终端程序。它可能被称为 GNOME 终端、Konsole 或 xterm。

1.  也把你的终端放到启动器中。

1.  使用你的 Linux 软件包管理器安装 Java JDK。我使用`openjdk­7­jdk`，但如果你更喜欢 Oracle 的，也可以。

1.  如果你还没有启动终端，启动你的终端。

1.  在提示符处键入`javac ­version`。你应该会看到一个类似`javac 1.7.0_25`的响应。如果没有，确保 JDK 已安装，并且包含可执行文件`javac`的`bin`目录在你的 PATH 中。

1.  学习如何从终端创建一个文件夹（创建一个目录）。创建一个目录，这样你就可以把这本书中的所有代码放进去。

1.  学习如何从提示符中切换到这个新目录。切换到它。

1.  使用你的文本编辑器（gedit）创建一个名为`test.txt`的文件，并将其保存到你刚刚创建的目录中。

1.  只使用键盘切换窗口回到终端。如果你不知道如何做，查一下。

1.  回到终端，看看你是否可以列出目录的内容，以查看你新创建的文件。

### Linux：你应该看到的内容

```java

mitchell@graham­desktop:~$ javac ­version javac 1.7.0_25
mitchell@graham­desktop:~$ mkdir javacode mitchell@graham­desktop:~$ cd javacode/ mitchell@graham­desktop:~/javacode$ ls mitchell@graham­desktop:~/javacode$
... Here you would use Notepad++ to make test.txt in javacode ... mitchell@graham­desktop:~/javacode$ ls
test.txt mitchell@graham­desktop:~/javacode$
```

你可能会看到不同的提示和其他细微的差异，但你不应该会得到任何错误，这是一般的想法。

### 初学者警告

你已经完成了第一个练习。这个练习可能对你来说很难，这取决于你对计算机的熟悉程度。如果很困难，你没有完成，回去花时间阅读和学习，然后再试一次。编程需要仔细阅读和注意细节。

如果一个程序员告诉你使用 vim 或 emacs 或 Eclipse，只需说“不”。这些编辑器是给你成为更好的程序员时使用的。你现在所需要的只是一个能让你把文本放入文件中的编辑器。我们将使用 gedit、TextWrangler 或 Notepad++（从现在开始称为“文本编辑器”或“一个文本编辑器”），因为它简单，并且在所有计算机上都是一样的。专业程序员使用这些文本编辑器，所以对于你来说已经足够了。

程序员最终会告诉你使用 Mac OS X 或 Linux。如果程序员喜欢字体和排版，他会告诉你买一个 Mac OS X 电脑。如果他喜欢控制并且留着大胡子，他们会告诉你安装 Linux。再次强调，使用你现在拥有的能工作的计算机。你只需要一个编辑器、一个终端和 Java。

最后，这个设置的目的是让你在做练习时可以非常可靠地做三件事：

+   使用你的文本编辑器（Linux 上的 gedit，OSX 上的 TextWrangler，或 Windows 上的 Notepad++）编写练习。

+   运行你写的练习。

+   当它们坏了就修好它们。

+   重复。

其他任何事情都只会让你困惑，所以坚持计划。

### 常见问题

#### 我必须使用这个糟糕的文本编辑器吗？我想用 Eclipse！

不要使用 Eclipse。虽然它是一个不错的程序，但不适合初学者。它对初学者有两个坏处：

1.  它让你做一些你现在不需要担心的事情。

1.  它为你做了一些你需要先学会如何做的事情。

所以按照我的指示使用一个体面的文本编辑器和一个终端窗口。一旦你学会了编码，你可以使用其他工具，但现在不行。

#### 我可以在我的平板电脑上完成这本书吗？还是我的 Chromebook？

很不幸。你不能在这两台机器上安装 Java 开发工具包（JDK）。你必须有某种传统的计算机。

## 练习 1：一个重要的消息

在这个练习中，你将编写一个在屏幕上显示重要消息的 Java 工作程序。

如果你不习惯为计算机输入详细的指令，那么这可能是本书中最难的练习之一。计算机非常愚蠢，如果你没有把每一个细节都搞对，计算机就不会理解你的指令。但是如果你能完成并使这个练习工作，那么你很有可能能够处理本书中的每一个练习，只要你每天都继续努力，并且不放弃。

打开你在练习 0 中安装的文本编辑器，并将以下文本输入到一个名为`FirstProg.java`的单个文件中。确保与我写的完全匹配，包括间距、标点和大写。

```java

1 public class FirstProg 2 {
3  public static void main( String[] args ) 4 {
```

1.  ```java
    System.out.println( "I am determined to learn how to code." );
    ```

1.  ```java
    System.out.println( "Today's date is" ); 7 }
    ```

```java
8 }
```

我在每一行前面都加了行号，但不要输入行号。它们只是为了我能谈论这些行。另外，取决于你是否已经保存了文件，不同的单词可能根本没有颜色。或者如果它们有颜色，它们可能与我的颜色不同。这些差异都没关系。

我将逐行走过这个程序，只是为了确保你输入的每一个东西都是正确的。

第一行以单词`public`开头，后面跟着一个空格，然后是单词`class`，再后面是一个空格，然后是单词`FirstProg`。 “First”中的‘F’是大写的，“Prog”中的‘P’是大写的。第一行只有两个大写字母。只有两个空格。

第二行只是一个单字符：“大括号”。你可以通过按住`SHIFT`键然后按下通常在字母‘P’右边的‘[’键来显示它。

在我继续程序的第三行之前，我应该告诉你程序员通常称呼这个程序中出现的每个有趣的符号。

`（`和`）`被称为“括号”（复数）。其中一个被称为“括号”，但有些人只是称它们为 parens（“puh­RENZ”）。这个（“`（`”）有时被称为“左括号”，另一个（“`）`”）被称为“右括号”，因为括号通常成对出现，一个通常在另一个的左边。左括号（“`（`”）也经常被称为“开括号”，右括号被称为“闭括号”，原因类似。

第 3 行有一个开括号和一个闭括号，整个文件中没有其他括号。

【】和【】被称为“括号”，但许多程序员称它们为“方括号”，以确保不会引起混淆。在 Java 中，括号和方括号不能互换使用。括号成对出现，它们被称为“左括号”或“开括号”和“右括号”或“闭括号”。

第 3 行有一个紧挨着的开括号和闭括号。

`{`和`}`被称为“大括号”，有些程序员称它们为“花括号”。这

也总是成对出现的左大括号和右大括号/开大括号和闭大括号。

`"`被称为“引号”，通常简称为“引号”。在 Java 中，它们总是成对出现。一对中的第一个通常被称为“开引号”，第二个是“闭引号”，尽管在两个位置上它是完全相同的字符。但第一个引号用于开始某事，第二个引号结束了那件事。

`'`在技术上是“撇号”，但几乎所有程序员都称它们为“单引号”。因此，引号通常被称为“双引号”。在一些编程语言中，单引号和双引号是可以互换的，但在 Java 中不行。Java 有时会使用单引号，但在这本书中它们会相当少见。

`.`在技术上是“句号”，但几乎所有程序员都说“点”。它们在编程语言中经常被使用，并且通常被用作分隔符而不是“结束符”，所以我们不称它们为句号。

这个程序中有四个句点和一个句号。

`;`被称为“分号”。它位于键盘上字母'L'和引号之间。Java 中使用了很多分号，尽管在这个程序中只有两个：一个在第 5 行的末尾，另一个在第 6 行的末尾。

`:`被称为“冒号”。通过按住 SHIFT 键并输入分号来获得它。Java 确实使用冒号，但它们非常少见。

最后，`<`是“小于号”，`>`是“大于号”，但有时它们被用作大括号或方括号。当它们以这种方式使用时，它们通常被称为“尖括号”。Java 使用尖括号，但你在这本书中看不到它们被使用。

好的，回到逐行。你已经正确地输入了前两行。

你应该按一次`TAB`键开始第三行。你的光标会移动几个空格（可能是 4 或 8）。然后再次输入单词`public`，一个空格，单词`static`，一个空格，单词`void`，一个空格，单词`main`后面跟一个开括号（`main`和括号之间没有空格）。括号后有一个空格，单词`String`（大写'S'），一个紧挨着的开括号和闭括号，一个空格，单词`args`，一个空格，最后是一个闭括号。

因此，第三行以一个制表符开始，总共有六个空格，只有“String”中的‘S’是大写的。哇。

在第四行，你的文本编辑器可能已经将光标直接放在“public”中的‘p’下面。如果没有这样做，那么你将不得不自己按 TAB 键开始第 4 行。然后只需输入另一个开大括号，就这样。

第五行应该以两个制表符开始。然后输入单词`System`（大写'S'），然后是一个句点（句号），然后是单词`out`，另一个句点，单词`println`（发音为“PrintLine”，尽管末尾没有‘i’或‘e’），一个开括号，一个空格，一个引号（开引号），句子`I` `am determined to learn how to code.`（句子以句号结束），然后是一个闭引号，一个空格，一个闭括号和一个分号。

因此，第 5 行有两个制表符，九个空格，两个句点（和一个句号），一个开引号和闭引号，一个开括号和闭括号，只有两个大写字母。

第 6 行几乎与第 5 行相同，只是句子说“今天的日期是”，而不是决定性的句子。

第 7 行只以一个制表符开始。如果你的文本编辑器为你放了两个制表符，你应该能够通过按一次 BACKSPACE 键来去掉多余的制表符。然后在制表符之后有一个右花括号。

最后，第 8 行没有制表符，还有一个右花括号。你可以在第 8 行按 ENTER 键，也可以不按：Java 不在乎。

注意，文件中有两个左花括号和两个右花括号。三个左括号和三个右括号。两个“开引号”和两个“闭引号”。一个左方括号和一个右方括号。这总是正确的。

还要注意，每次我们输入一个左花括号时，下面的行会有更多的制表符，而在右花括号下面的行则会有更少的制表符。

好了，现在保存这个（如果你还没有）为`FirstProg.java`，并将其保存在你在练习 0 中创建的“code”文件夹中。

确保文件名与我的完全匹配： “First”中的‘F’是大写的，“Prog”中的‘P’是大写的，其他所有字母都是小写的。文件名中不应该有空格。Java 将拒绝运行任何文件名中带有空格的程序。还要确保文件名以`.java`结尾，而不是`.txt`。

### 编译你的第一个程序

现在程序已经编写好了，希望没有错误（我们很快就会看到），启动你的终端（或 PowerShell）并切换到保存代码的目录。

进行目录列表以确保 Java 文件在那里。在我的电脑上，它看起来像这样：

```java

mitchell@graham­desktop:~$ cd javacode/ mitchell@graham­desktop:~/javacode$ ls FirstProg.java test.txt mitchell@graham­desktop:~/javacode$
```

将来，因为你的终端可能看起来不像我的，我会这样缩写提示：

```java

$ ls
FirstProg.java test.txt
$
```

这样会更少混乱，因为要忽略的“错误”会更少，你只需要看看你应该输入什么和你应该看到什么。

现在，我们已经在一个叫做 Java 的编程语言中输入了一系列命令。但是计算机不能直接执行我们的命令。我们必须把这个文件交给一个“编译器”，这是一个将我们的指令翻译成更接近计算机可以执行的一些东西的程序。在 Java 中，这些东西被称为“字节码”。所以我们要运行 Java 编译器程序来“编译”我们的 Java 源代码成一个字节码文件，这样我们就能够执行它了。

Java 编译器的名字是`javac`（‘c’代表“编译器”），我们这样运行它：

```java

$ javac FirstProg.java
$
```

如果你对细节非常关注，并且做了我告诉你的一切，这个命令将花费一秒钟的时间运行，然后提示符将会弹出，没有消息。如果你犯了某种错误，你会看到这样的错误：

```java

$ javac FirstProg.java
FirstProg.java:8: error: reached end of file while parsing
}
^
1 error
$
```

不要太担心特定的错误消息。当它感到困惑时，编译器会试图猜测你可能犯了什么错误。不幸的是，这些猜测是为专业程序员设计的，所以它通常对初学者类型的错误猜测不准确。

这是你可能会得到的另一种错误消息的例子：

```java

$ javac FirstProg.java FirstProg.java:5: error: ';' expected
System.out.println( "I am determined to learn how to code." ):
^
1 error
$
```

在这种情况下，编译器实际上是正确的：错误出现在第 5 行，具体错误是期望有一个分号（`';' expected`）。（该行以冒号（`:`）结尾，但应该是分号（`;`）。

这里还有一个：

```java

$ javac FirstProg.java
FirstProg.java:1: error: class Firstprog is public, should be declared in a file named Firstprog.java
public class Firstprog
^
1 error
$
```

这次是一个大小写错误。 代码中写着`public class Firstprog`（注意小写的‘p’），但文件名是`FirstProg.java`。因为它们不完全匹配，包括大小写，编译器会感到困惑并退出。

所以如果你有任何错误消息，修复它们，然后*保存*你的代码，回到终端再次编译。

#### 警告！

如果你在文本编辑器中对代码进行了更改，你必须在尝试重新编译之前保存文件。如果你不保存更改，你仍然会编译之前保存的旧版本的代码，即使你的文本编辑器中的代码是正确的。

最终，您应该做对了，它将编译而不会出现任何错误或任何消息。进行目录列表，您应该看到字节码文件出现在文件夹中：

```java

$ javac FirstProg.java
$ ls
FirstProg.class FirstProg.java test.txt
$
```

现在我们有了一个有效的字节码文件，我们可以通过 Java 虚拟机（JVM）程序`java`来运行它（或“执行”它）：

### 您应该看到的内容

```java

$ java FirstProg
I am determined to learn how to code. Today's date is
$
```

请注意，您输入的命令是`java FirstProg`，而不是`java FirstProg.java`，甚至不是`java` `FirstProg.class`。

您激动吗？您刚刚编写了您的第一个 Java 程序并运行它！如果您走到了这一步，那么只要您每天都在上面努力工作并且不放弃，您几乎肯定有能力完成这本书。

### 学习任务

在大多数练习之后，我会列出一些额外的任务，您应该在键入代码并使其编译和运行后尝试。一些学习任务将非常简单，有些将更具挑战性，但您应该始终尝试。

1.  更改第 6 行引号内的内容以包括今天的日期。在进行更改后保存文件，编译文件并再次运行它。

1.  更改第 5 行引号内的内容，使计算机显示您的姓名。

### 完成学习任务后您应该看到的内容

```java

$ java FirstProg
I, Graham Mitchell, am determined to learn how to code. Today's date is Friday, July 19, 2013.
$
```

## 练习 2：更多打印

好了，现在我们已经完成了第一个艰难的任务，我们将做另一个。好处是，在这个任务中，我们仍然有很多设置代码（几乎每次都是相同的），但是设置与“有用”代码的比例要好得多。

将以下文本键入单个文件中，文件名为`LetterToYourself.java`。确保与我写的内容完全匹配，包括间距、标点和大写。

请注意，第一行与上一个任务相同，只是类的名称现在是`LetterToYourself`而不是`FirstProg`。还要注意，您要放置内容的文件名是`LetterToYourself.java`而不是`FirstProg.java`。这不是巧合。

在 Java 中，每个文件只能包含一个 public 类，而公共类的名称必须与文件名（包括大小写）匹配，除了文件名以`.java`结尾，而公共类名不是。

那么，在 Java 中，“public class” *意味着*什么？等您长大了我会告诉您。说真的，试图一开始就详细介绍这种类型的原因是大多数“初学者”编程书籍对于真正的初学者来说都很糟糕。所以不要担心。现在只需键入它。（不幸的是，这种情况会发生很多。）

您可能会注意到此程序的第二行、第三行和第四行与上一个任务*完全*相同。它们没有任何区别。

然后，在第二个左大括号之后，有十一个打印语句。它们都是完全相同的，除了引号之间的内容。小竖线（“`|`”）称为“管道”字符，您可以使用 Shift +反斜杠（“`\`”）键入它。假设您使用的是普通的美国键盘，反斜杠键位于退格键和回车键之间。

一切都键入并保存为`LetterToYourself.java`后，您可以像之前的任务一样编译和运行它。切换到终端窗口，将目录更改为保存代码的目录，并键入以下内容进行编译：

```java

$ javac LetterToYourself.java
```

如果你非常擅长烦人的细节并且幸运的话，你将不会有错误，`javac`命令将在不说任何话的情况下完成。可能你会有错误。如果是这样，回去仔细比较你输入的内容和我写的内容。最终你会发现你的错误。修复它们，再次保存文件，然后尝试重新编译。

一旦它编译没有错误，你可以像以前一样运行它：

```java

$ javac LetterToYourself.java
$ java LetterToYourself
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
|

#### |
|

#### |
|

#### |
|

|
|

|
|
Bill Gates
|
|
1 Microsoft Way
|
|
Redmond, WA 98104
|
|                          |
+­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­­+
```

两个程序完成了。不错！到目前为止你所取得的成就*并不*容易，任何认为它容易的人都有*很多*经验，并且已经忘记了第一次尝试这些东西是什么感觉。不要放弃！

每天多做一点，这样*会*变得更容易。

### 学习演习

1. 这个文件叫`LetterToYourself.java`而不是`LetterToBillGates.java`！回到你的文本编辑器，把名字和地址从比尔盖茨在微软的地址改成你自己的名字和地址。然后保存，编译，再次运行。

### 常见的学生问题

#### 我必须使用我的真实地址吗？

当然不是。但是确保你的虚假地址占据三行。

#### 为什么当我运行程序时我的信不对齐？！在代码中一切看起来都很完美！

你可能在你的 println()语句中使用了制表符和空格的混合。许多文本编辑器在你按下 TAB 键时只会将光标移动 4 个空格。但当你的程序运行时，引号内嵌的任何制表符将占用 8 个空格，而不是 4 个。如果你删除引号之间的所有制表符并用空格替换它们，你的代码和运行程序时的效果应该是一样的。

## 练习 3：打印选择

Java 有两个常用的命令用于在屏幕上显示东西。到目前为止，我们只看过

`println()`，但`print()`有时也会用到。这个练习将展示它们之间的区别。

```java

1 public class PrintingChoices 2 {
```

```java
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24 }
```

```java
public static void main( String[] args )
{
System.out.println( "Alpha" ); System.out.println( "Bravo" );
```

```java
System.out.println( "Charlie" ); System.out.println( "Delta" ); System.out.println();

System.out.print( "Echo" ); System.out.print( "Foxtrot" );

System.out.println( "Golf" ); System.out.print( "Hotel" ); System.out.println(); System.out.println( "India" );

System.out.println();
System.out.println( "This" + " " + "is" + " " + "a" + " test." );
```

```java
}
```

将以下代码输入到一个文件中。通过阅读代码，你能猜到文件必须叫`PrintingChoices.java`吗？在未来的作业中，我可能不会告诉你如何命名 Java 文件。

当你运行它时，你应该看到这个。

```java

Alpha Bravo Charlie Delta

EchoFoxtrotGolf Hotel
India

This is a test.
```

你能找出区别吗？

`print()`和`println()`都会在屏幕上显示引号之间的任何东西。但`println()`在完成打印后会移到新的一行，而`print()`不会：它会显示然后将光标留在行的末尾，以便下一个打印语句从同一位置开始。

你还会注意到（第 10 行）我们可以有一个`println()`语句，括号里什么都不写。没有引号或其他任何东西。这个语句指示计算机什么都不打印，然后将光标移动到下一行的开头。

你可能还会注意到这个程序有一些空行（第 7、11、14、19 和 22 行）。在第一个练习中，当我写道你必须“完全匹配我写的内容，包括间距、标点和大写”，我并没有*完全*诚实。你的代码中多余的空行

被 Java 编译器忽略。你可以把它们放进去或移除它们，程序将完全一样。

我的学生经常指责我“充满谎言”。这是真的。我已经通过艰苦的方式学到，当学生只是在学习编程这样困难的东西时，告诉他们真相会让他们太困惑。所以我经常过分简化我说的话，即使这使得它在技术上不准确。

如果你已经知道如何编程，而我的“谎言”冒犯了你，那么这本书将很难阅读。但对于那些刚开始学习的人，我向你保证，你希望我一开始简化事情。我保证最终会揭示真相。

无论如何，在第 21 行，我做了一件新的事情。到目前为止，你只在引号内打印了一个东西。但是完全可以打印多个东西，只要在打印之前将这些东西组合起来。

因此，在第 21 行，我有六个字符串用引号括起来：单词“this”，一个空格，单词“is”，一个空格，单词“a”，最后是一个空格，后面跟着“test”和一个句号。在这六个字符串之间有一个加号（“`+`”），因此在第 21 行总共有五个加号。当您在字符串之间放置加号时，Java 会将它们 2 加在一起，以形成一个长字符串，然后一次性显示所有内容。

如果您的代码出现错误，那么它可能在第 21 行。记住正确启动和停止所有引号并正确获取所有这些细节是棘手的。

今天的课程希望*相对*容易。别担心，我会在下一个课程中弥补的。

![image](img/Image_005.png)

1.  “String”是什么？一对引号之间的一堆字符（字母，数字，符号）。我稍后会解释更多。

1.  从技术上讲，将较小的单词组合成较大的单词称为“连接”，而不是“添加”。 Java 将字符串连接在一起。

    ## 练习 4：转义序列和注释

    您是否考虑过如果我们想在屏幕上显示引号会发生什么？由于我们想要显示的所有内容都包含在`println()`语句的引号之间，因此在引号内放置引号将是一个问题。

    大多数编程语言都允许“转义序列”，其中您使用某种转义字符来表示下一个字符不应以正常方式处理。

    以下（邪恶）代码演示了 Java 的许多转义序列。称之为

    `EscapeSequences.java`。

    1

    public class EscapeSequences

    2

    {

    3

    public static void main(String[] args)

    4

    {

    5

    //使用 FIGlet 创建的初始版本，字体为“Big Money”，向西南方向

    6

    7

    System.out.print("\t  \n\t / |\n\t JJJJJ |");

    8

    System.out.println("       ");

    9

    System.out.println("\t JJ | / \\ / \\ / |/ \\");

    10

    System.out.println("\t   JJ | aaaaaa |\"\" \\ /\"\"/ aaaaaa |");

    11

    System.out.println("\t/ | JJ | / aa | \"\" /\"\"/ / aa |");

    12

    System.out.println("\tJJ \\  JJ |/aaaaaaa | \"\" \"\"/ /aaaaaaa |");

    13

    System.out.println("\tJJ JJ/ aa aa | \"\"\"/ aa aa |");

    14

    System.out.println("\t JJJJJJ/ aaaaaaa/ \"/ aaaaaaa/");

    15

    }

    16

    }

    ```java

    /
    ```

    ```java
    |
    ```

    JJJJJ |

    ```java
    JJ | /   \ / \  / |/   \
    ```

    JJ | aaaaaa |"" \ /""/ aaaaaa |

    ```java
    / | JJ | /  aa | "" /""/ /  aa | JJ \  JJ |/aaaaaaa | "" ""/ /aaaaaaa | JJ  JJ/ aa  aa | """/ aa  aa | JJJJJJ/  aaaaaaa/   "/   aaaaaaa/
    ```

    当您运行它时，您应该看到的是这样的。

    Java 的转义字符是反斜杠（`\`），这与您按下以使管道（`|`）显示出来的相同键，但不需要按住 Shift。 Java 中的所有转义序列都必须在一组引号内。

    `\"`代表引号。

    `\t`是一个制表符；这就像您在键入代码时按 Tab 键一样。现在它可能看起来更复杂，因为您以前从未见过它，但是当您阅读别人的代码时

    引号内的`\t`不如一堆可能是空格或制表符的空格不明确。

    `\n`是一个换行符。在打印时，它将导致输出移到下一行的开头，然后继续打印。

    `\\`是显示反斜杠的方法。

    在第 5 行，您会注意到该行以两个斜杠（或“正斜杠”，如果您坚持的话）开头。这标记了该行为“注释”，这是程序员的人为利益。计算机完全忽略注释。

    实际上，用两个斜杠标记注释的行不一定要在行的开头；我们可以写这样的东西：

    ```java

    System.out.println( "A" ); // prints an 'A' on the screen
    ```

    ...它完全有效。从两个斜杠到该行末尾的所有内容都将被编译器忽略。

    （尽管这不是一个很好的评论；但是，任何了解 Java 的程序员都已经知道该行代码的作用。通常，您应该放置解释代码存在的原因的注释，而不是代码的作用。随着您在编码方面的技能提高，您将更擅长编写良好的注释。）

    无论如何，这个练习很难，所以这次没有学习任务。下一个练习将介绍一些新内容，并恢复正常难度。

    ## 练习 5：在变量中保存信息

    如果程序只能在屏幕上打印东西，那就太无聊了。我们希望我们的程序是互动的。

    不幸的是，互动需要几个不同的概念共同工作，一次解释所有这些可能会令人困惑。所以我会一个一个地介绍它们。

    首先是：变量！如果你上过代数课，你就会熟悉数学中的变量概念。编程语言也有变量，基本概念是一样的：

    “变量是指向保存值的位置的名称。” Java 中的变量与数学变量有四个主要区别：

    1.  变量名可以超过一个字母长。

    1.  变量不仅可以保存数字，还可以保存单词。

    1.  当变量首次创建时，你必须选择变量将保存的值的类型。

    1.  变量的值（但不是它的类型）可以在程序中改变。变量`score`可能一开始的值是`0`，但到程序结束时，`score`可能保存的值是`413500`。

        好了，讨论够了。让我们开始写代码吧！我不会告诉你文件的名字应该是什么。你得自己弄清楚。

        1

        public class CreatingVariables

        2

        {

        3

        public static void main( String[] args )

        4

        {

        5

        int x, y, age;

        6

        double seconds, e, checking;

        7

        String firstName, last_name, title;

        8

        9

        x = 10;

        10

        y = 400;

        11

        age = 39;

        12

        13

        seconds = 4.71;

        14

        e = 2.71828182845904523536;

        15

        checking = 1.89;

        16

        17

        firstName = "Graham";

        18

        last_name = "Mitchell";

        19

        title = "Mr.";

        20

        21

        System.out.println( "变量 x 包含" + x );

        22

        System.out.println( "变量 y 中存储的值为" + y );

        23

        System.out.println( "实验在" + seconds + "秒内完成。" );

        24

        System.out.println( "我最喜欢的无理数是欧拉常数：" + e );

        25

        System.out.println( "希望你的余额超过$" + checking + "！" );

        26

        System.out.println( "我的全名是" + title + " " + firstName + last_name );

        27

        }

        28

        }

        ### 你应该看到的内容

        ```java

        The variable x contains 10
        The value 400 is stored in the variable y. The experiment completed in 4.71 seconds.
        My favorite irrational number is Euler's constant: 2.718281828459045 Hopefully your balance is more than $1.89!
        My full name is Mr. GrahamMitchell
        ```

        在第 5 到 7 行，我们声明了九个变量。前三个分别命名为*x*，*y*和*age*。这三个变量都是“整数”，这是一种可以保存±两十亿之间的值的变量类型。

        一个整数变量可以保存值`10`。它可以保存值`­8192`。一个整数变量可以保存`123456789`。它不能保存值`3.14`，因为这有小数部分。一个整数变量也不能保存值`10000000000`，因为一百亿太大了。

        在第 6 行，我们声明了变量*seconds*，*e*和*checking*。这三个变量都是“double”，这是一种可以保存可能有小数部分的数字的变量类型。

        一个双精度变量可以保存值`4.71`。它可以保存值`­8192`。（它可能有小数部分，但不一定有。）它几乎可以保存± 1.79769 × 10308 和 4.94065 × 10­324 之间的任何值。

        然而，双精度有限的精度。请注意，在第 14 行，我将值`2.71828182845904523536`存储到名为 e 的变量中，但当我在第 24 行打印出该值时，只有`2.718281828459045`出现。双精度没有足够的有效数字来精确保存值`2.71828182845904523536`。整数具有完美的精度，但只能保存整数，不能保存巨大的值。

        我们在这个练习中要看的最后一种变量类型是`String`。在第 7 行，我们声明了三个 String 变量：firstName，last_name 和 title。String 变量可以保存单词和短语；名称缩写为“字符串”。

        在第 9 到 11 行，我们初始化 4 三个整数值。值`10`被存储到 x 中。在此之前，变量 x 存在，但其值未定义。`400`被存储到 y 中，`39`被存储到变量 age 中。

        第 13 到 15 行给三个双精度变量赋初始值，第 17 到 19 行初始化了三个字符串变量。然后第 21 到 26 行在屏幕上显示了这些变量的值。请注意，变量名没有用引号括起来。

        我知道对于这样的程序使用变量是没有意义的，但很快一切都会变得清晰起来。

        ![image](img/Image_008.png)

1.  声明-告诉程序变量的名称（或“标识符”）和类型。‌

1.  初始化-给变量赋予其第一个（或“初始”）值。

    ## 练习 6：数学运算

    ```java

    1
    public class MathOperations
    2
    {
    3
    public static void main( String[]
    args )
    4
    {

    5
    int a, b, c, d, e, f, g;

    6
    double x, y, z;

    7
    String one, two, both;

    8

    ```

    现在我们知道如何在 Java 中声明和初始化变量，我们可以用这些变量进行一些数学运算。

    ```java

    11
    System.out.println(
    "a is " + a + ", b
    is
    "
    +
    b
    );
    12

    13
    c = a + b;

    14
    System.out.println(
    "a+b is " + c );
    15
    d = a ­ b;

    16
    System.out.println(
    "a­b is " + d );
    17
    e = a+b*3;

    18
    System.out.println(
    "a+b*3 is " + e );
    19
    f = b / 2;

    20
    System.out.println(
    "b/2 is " + f );
    21
    g = b % 10;

    22
    System.out.println(
    "b%10 is " + g );
    23

    24
    x = 1.1;

    25
    System.out.println(
    "\nx
    is
    "
    +
    x
    );
    26
    y = x*x;

    27
    System.out.println(
    "x*x
    is
    "
    +
    y
    );
    28
    z = b / 2;

    29
    System.out.println(
    "b/2
    is
    "
    +
    z
    );
    30

    System.out.println();

    31

    32

    one = "dog";

    33

    two = "house";

    34

    both = one + two;

    35

    System.out.println( both
    );
    36

    }

    37
    }

    ```

    ### 你应该看到的

    ```java

    a is 10, b is 27
    a+b is 37
    a­b is ­17
    a+b*3 is 91
    b/2 is 13
    b%10 is 7

    x is 1.1
    x*x is 1.2100000000000002
    b/2 is 13.0

    doghouse
    ```

    加号（`+`）将两个整数或两个双精度数相加，或一个整数和一个双精度数（顺序不限）。对于两个字符串（就像在第 34 行），它将把这两个字符串连接在一起。

    ![image

1.  “连接”-将字符字符串端对端连接。

    减号（`-`）将一个数字减去另一个数字。就像加法一样，它适用于两个整数、两个双精度数，或一个整数和一个双精度数（顺序不限）。

    星号（`*`）用于表示乘法。您还可以在第 17 行看到 Java 知道正确的运算顺序。b 乘以 3 得到`81`，然后加上 a。

    斜杠（`/`）用于除法。请注意，当一个整数被另一个整数除（就像在第 19 行），结果也是一个整数而不是一个双精度数。

    百分号（`%`）用于表示“模数”，本质上是除法后剩下的余数。在第 21 行，b 被`10`除，余数（`7`）被存储到变量 g 中。

    ### 常见学生问题

    +   为什么`1.1`乘以`1.1`等于`1.2100000000000002`而不是`1.21`？为什么 0.333333 + 0.666666 等于 0.999999 而不是 1.0？有时候在数学中我们会得到重复的小数，大多数计算机在处理它们之前会将数字转换为二进制。结果是`1.1`在二进制中是一个重复的小数。

    记住我在上一个练习中说的：双精度的问题在于有限的精度。在本书中，你大多数时候可以忽略这个事实，但我希望你能记住双精度变量有时会给出*略微*不同于你期望的值。

    ## 练习 7：从人类那里获取输入

    现在我们已经练习了一段时间创建变量，我们将看看交互式程序的另一部分：让运行我们程序的人有机会输入一些内容。

    继续输入这个，但请注意程序中的第一行不是`public class`行。这次我们从一个“导入”语句开始。

    并非每个程序都需要从键盘获取人类的交互输入，因此这不是 Java 语言核心的一部分。就像一辆 F1 赛车不包括空调一样，编程语言通常有一个小的核心，然后有很多可选的库 6，如果需要可以包含进来。

    1 import java.util.Scanner; 2

    3 public class ForgetfulMachine

    4 {

    5

    public static void main( String[] args )

    6

    {

    7

    Scanner keyboard = new Scanner(System.in);

    8

    9

    System.out.println( "法国的首都是哪个城市？" );

    10

    keyboard.next();

    11

    12

    System.out.println( "6 乘以 7 等于多少？" );

    13

    keyboard.nextInt();

    14

    15

    System.out.println( "你最喜欢的数字是多少？在 0.0 和 1.0 之间" );

    16

    keyboard.nextDouble();

    17

    18

    System.out.println( "还有什么你想告诉我的吗？" );

    19

    keyboard.next();

    20

    }

    21

    }

    当你第一次运行这个程序时，它只会打印第一行：

    ```java

    What city is the capital of France?
    ```

    然后它会在屏幕上闪烁光标，等待你输入一个单词。当我运行程序时，我输入了单词“巴黎”，但即使你输入一个不同的单词，程序也会正常工作。

    然后在你输入一个单词并按回车后，程序将继续打印：

    ```java

    What is 6 multiplied by 7?
    ```

    ……等等。假设你对每个问题都输入了合理的答案，最终看起来会像这样：

    ### 你应该看到的

    ```java

    What city is the capital of France? Paris
    What is 6 multiplied by 7?
    42
    What is your favorite number between 0.0 and 1.0? 2.3
    Is there anything else you would like to tell me? No, there is not.
    ```

    ![image]（Learn%20Java%20the%20Hard%20Way_files/Image_011.png）

1.  库或“模块”——添加额外功能到程序中的一段代码，可能包含或不包含。

    让我们来谈谈代码。在第 1 行，我们有一个`import`语句。我们导入的库是 scanner 库`java.util.Scanner`（“java 点 util 点 Scanner”）。这个库包含的功能允许我们从键盘或其他地方（如文件或互联网）读取信息。

    第 2 行到第 7 行希望是无聊的。在第 8 行，我们看到了另一件新事物：我们创建了一个名为“keyboard”的“Scanner 对象”。（它不一定要被命名为“keyboard”；你可以在这里使用一个不同的词，只要你在你的代码中到处使用它。）这个名为 keyboard 的 Scanner 对象包含我们将称之为函数或“方法”的能力。在你使用之前，你必须创建并命名一个 Scanner 对象。

    在第 10 行，我们要求名为 keyboard 的 Scanner 对象为我们做一些事情。我们说“键盘，运行你的`next（）`函数。”Scanner 对象将暂停程序，等待人类输入。一旦人类输入内容并按回车，Scanner 对象将把它打包成一个字符串，并允许你的代码继续。

    在第 13 行，我们要求 Scanner 对象执行其`nextInt（）`函数。这会暂停程序，等待人类输入并按回车，然后将其打包成整数值（如果可能的话）并继续。

    如果人类在这里没有输入整数会怎么样？再次运行程序，然后在第二个问题的答案中输入`41.9`。

    该程序会因为`41.9`无法被打包成整数值而爆炸：`41.9`是一个`double`。最终，我们将研究如何处理类似问题的错误检查，但与此同时，如果人类输入了错误的内容导致程序崩溃，我们会责怪人类没有遵循指示，而不会担心这个问题。

    第 16 行让人类输入一个 Scanner 对象将尝试转换为 double 值的内容，第 19 行让人类输入一个字符串。（任何东西都可以被打包为字符串，包括数字，所以这不太可能失败。）

    尝试多次运行程序，注意何时会崩溃，何时不会。

    ## 练习 8：存储人类的回答

    1 import java.util.Scanner; 2

    3 public class RudeQuestions 4 {

    5

    6

    7

    8

    9

    10

    11

    12

    13

    14

    15

    16

    17

    18

    19

    20

    21

    22

    23

    public static void main（String[] args）

    {

    String name; int age;

    double weight, income;

    Scanner keyboard = new Scanner（System.in）;

    System.out.print（“你好。你叫什么名字？“）；name = keyboard.next（）；

    System.out.print（“你好，”+姓名+“！你多大了？”）；年龄=keyboard.nextInt（）；

    System.out.println（“所以你”+年龄+“岁了？一点都不老。”）；System.out.print（“你的体重是多少，”+姓名+“？”）；

    体重=keyboard.nextDouble（）；

    System.out.print（体重+“！最好保持安静。最后，你的收入是多少，”+

    name +“？”）；

    24

    25

    26

    27

    28

    29 }

    收入=keyboard.nextDouble（）；

    System.out.println（“希望这是每小时的收入，而不是每年的收入！”）；System.out.println（“好吧，谢谢你回答我的粗鲁问题，”+姓名+“。”）；

    }

    在上一个练习中，你学会了如何暂停程序并允许人类输入一些东西。但是输入的内容发生了什么？当你为第一个问题输入“巴黎”时，答案去哪了？嗯，它在输入后立即被丢弃了，因为我们没有放置任何指令告诉 Scanner 对象在哪里存储它。所以这就是今天课程的主题。

    （抱歉，第 23 行像那样换行了。我不想因为那一行而使字体变得微小。就像平常一样，把它都写在一行上。）

    就像上一个练习一样，当你第一次运行这个程序时，它只会显示第一个问题，然后暂停，等待回答。

    ```java

    Hello. What is your name?
    ```

    请注意，因为第 13 行的第一个打印语句是`print()`而不是`println()`，光标会留在问题所在行的末尾闪烁。如果你使用了`println()`，光标会在下一行的开头闪烁。

    ### 你应该看到什么

    ```java

    Hello. What is your name? Brick Hi, Brick! How old are you? 25
    So you're 25, eh? That's not old at all. How much do you weigh, Brick? 192
    192.0! Better keep that quiet. Finally, what's your income, Brick? 8.75 Hopefully that is 8.75 per hour and not per year!
    Well, thanks for answering my rude questions, Brick.
    ```

    在程序的顶部，我们声明了四个变量：一个名为*name*的字符串变量，一个名为*age*的整数变量，以及两个名为*weight*和*income*的双精度变量。

    在第 14 行，我们看到了`keyboard.next()`，我们知道它来自上一个练习，它会暂停程序并让人类输入一些东西，然后将其打包成一个字符串。那么他们输入的字符串去哪了呢？在这种情况下，我们将该值存储到名为“name”的字符串变量中。字符串值被存储到了一个字符串变量中。不错。

    所以，假设你在第 14 行为你的名字输入了`Brick`，字符串值`"Brick"`就会被存储到第 14 行的变量名中。这意味着在第 16 行，我们可以在屏幕上显示该值！如果你问我，这相当酷。

    在第 17 行，我们要求 Scanner 对象让人类输入一些东西，它将尝试将其格式化为整数，然后该值将被存储到名为*age*的整数变量中。我们在第 19 行将该值显示在屏幕上。

    第 21 行读取一个双精度值并将其存储到*weight*中，第 24 行读取另一个双精度值并将其存储到*income*中。

    这是一件非常强大的事情。有了一些变量和 Scanner 对象的帮助，我们现在可以让人类输入信息，并且可以在程序中稍后使用变量来记住它！

    在我结束之前，注意例如变量*income*在第 9 行上被声明（我们选择了它的名称和类型），但直到第 24 行之前它都是未定义的（它没有值）。在第 24 行*income*最终被初始化（给出了程序的第一个值）。如果你在第 24 行之前尝试打印*income*的值，程序将无法编译。

    无论如何，尝试输入不同的答案来回答问题，并看看你是否能在每个问题后让程序崩溃。

    ## 练习 9：使用用户输入进行计算

    既然我们知道如何从用户那里获取输入并将其存储到变量中，而且我们也知道如何进行一些基本的数学运算，我们现在可以编写我们的第一个*有用*的程序了！

    ```java

    1 import java.util.Scanner; 2
    3 public class BMICalculator
    4 {
    5

    public static void main( String[] args )
    6

    {
    7

    Scanner keyboard = new Scanner(System.in);
    8

    double m, kg, bmi;
    9

    10

    System.out.print( "Your height in m: " );
    11

    m = keyboard.nextDouble();
    12

    13

    System.out.print( "Your weight in kg: " );
    14

    kg = keyboard.nextDouble();
    15

    16

    bmi = kg / (m*m);
    17

    18

    System.out.println( "Your BMI is " + bmi );
    19

    }
    20
    }

    ```

    ### 你应该看到什么

    ```java

    Your height in m: 1.75 Your weight in kg: 73
    Your BMI is 23.836734693877553
    ```

    这个练习（希望）相当简单。我们有三个变量（都是双精度）：*m*（米）、*kg*（千克）和*bmi*（身体质量指数）。我们读取*m*和*kg*的值，但*bmi*的值不是来自人类，而是计算的结果。在第 16 行，我们计算质量除以身高的平方，并将结果存储到*bmi*中。然后我们将其打印出来。

    身体质量指数（BMI）通常被健康和营养专业人员用来估计人群的体脂肪。因此，这个结果对健康专业人员来说是有信息价值的。目前我们只能做到这些。

    最终，我们将学会如何根据 BMI 的值在屏幕上显示不同的消息，但目前这就够了。

    今天是一个相当简单的任务，但我在学习挑战中为你准备了一些挑战，应该会让事情变得更加困难。

    ### 学习挑战

    1.  添加一些变量并更改程序，以便人类可以使用磅和英寸输入他们的体重和身高，然后将这些值转换为千克和米，以计算 BMI。

        ```java
        Your height in inches: 69 Your weight in pounds: 160 Your BMI is 23.625289
        ```

    1.  使人类可以分别输入他们的身高，一个是英尺，一个是英寸。

        ```java

        Your height (feet only): 5 Your height (inches): 9 Your weight in pounds: 160 Your BMI is 23.625289
        ```

        ## 练习 10：变量只能保存值

        好的，现在我们可以从人类那里获取输入并进行计算，我想要引起一些我的学生经常感到困惑的事情的注意。以下代码应该可以编译，但它可能不会按照你的期望工作。

        我故意在代码中制造了一个*逻辑*错误。这不是语法问题（编译器关心的代码部分），也不是运行时错误，比如当人类在期望整数时，Scanner 对象接收到了一个双精度数。这个逻辑错误是我设计指令流程的缺陷，导致输出不是我想要实现的。

        ```java

        1 import java.util.Scanner; 2
        3 public class Sequencing
        4 {
        5

        public static void main( String[] args )
        6

        {
        7

        // BROKEN
        8

        9

        Scanner keyboard = new Scanner(System.in);
        10

        double price = 0, salesTax, total;
        11

        12

        salesTax = price * 0.0825;
        13

        total = price + salesTax;
        14

        15

        System.out.print( "How much is the purchase price? " );
        16

        price = keyboard.nextDouble();
        17

        18

        System.out.println( "Item price:\t" + price );
        19

        System.out.println( "Sales tax:\t" + salesTax );
        20

        System.out.println( "Total cost:\t" + total );
        21

        }
        22
        }

        How much is the purchase price? 7.99 Item price:  7.99
        Sales tax:  0.0
        Total cost:  0.0
        ```

        ### 你应该看到的是

        你对输出感到惊讶吗？你是否期望$7.99 的销售税显示为$0.66 而不是一个大大的零？总成本应该是$8.65，对吧？发生了什么？

        发生的是，在 Java（以及大多数编程语言中），*变量不能保存公式*。变量只能保存值。

        看看第 12 行。我的学生有时会认为该行将公式`price * 0.0825`存储到变量 salesTax 中，然后稍后人类将值`7.99`存储到变量 price 中。他们认为在第 19 行打印 salesTax 时，计算机会以某种方式“运行”该公式。

        实际上并不是这样的。事实上，这个程序甚至不应该编译。变量*price*在第 12 行甚至没有一个合适的值。它之所以有一个值，只是因为我在第 10 行做了一些狡猾的事情。

        通常我们一直在程序的顶部声明变量，然后稍后初始化它们。但是在第 10 行，我声明了 price 并将其初始化为`0`。当你同时声明和初始化一个变量时，这被称为“定义”变量。salesTax 和 total 在这里没有定义

        第 10 行，只是声明。

        所以在第 16 行，人类输入的值并没有初始化 price；price 已经有了一个初始值（`0`）。但是人类输入的值（`7.99`或其他值）确实被存储到变量 price 中。

        `0`被替换为`7.99`。

        从第 10 行到第 15 行，变量 price 包含值`0`。当第 16 行开始执行并且我们在等待人类输入时，price 仍然包含`0`。但是当第 16 行完成时，无论人类输入了什么，都已经存储到 price 中，替换了零。然后从第 17 行到程序结束，变量 price 包含值`7.99`（或其他值）。

        因此，考虑到这一点，我们可以弄清楚第 12 行实际发生了什么。第 12 行并没有将一个公式存储到 salesTax 中，但它确实存储了一个值。是什么值？它获取代码中此时变量 price 的值（即`0`），将其乘以`0.0825`（仍然是零），然后将这个零存储到 salesTax 中。

        当第 12 行开始时，salesTax 的值是未定义的（salesTax 被声明但未定义）。到第 12 行结束时，salesTax 的值为`0`。没有一行代码改变了 salesTax（没有一行代码以`salesTax =`开头），因此该值永远不会改变，当它在第 19 行显示时，salesTax 仍然是零。

        第 13 行也是类似的。它获取*price*的值**此时**（零），并将其加到*salesTax*的值**此时**（也是零）中，并将总和（零）存储到变量*total*中。*total*的值没有改变，*total*也不会以某种方式“记住”它的值来自涉及一些变量的公式。

        这就是全部内容。变量保存值，而不是公式。计算机程序不是一组规则，它们是计算机按顺序执行的一系列指令，你代码中的后续操作取决于之前发生的事情。

        ### 学习练习

        1.  删除第 10 行的“= 0”，这样*price*就不再在第 10 行定义，只是声明。当你尝试编译代码时会发生什么？错误消息是否合理？（现在将“= 0”放回，以便程序再次编译。）

        1.  将给*salesTax*和*total*赋值的两行代码移到*price*获得适当值之后。确认程序现在按预期工作。

        1.  现在这些行发生在*price*变量被正确赋予真实值之后，再次尝试删除第 10 行的“= 0”。程序是否仍然报错？你感到惊讶吗？

        ## 练习 11：变量修改快捷方式

        变量的值可以随着程序运行的时间而改变。（除非你编写代码来改变它，但我是说它*可以*改变。）

        事实上，这是相当常见的。我们经常做的事情是取一个变量并对其进行加法。例如，假设变量 x 包含值`10`。我们想要加上`2`，这样 x 现在包含`12`。

        我们可以这样做：

        ```java

        int x = 10, temp_x; temp_x = x + 2;
        x = temp_x;
        ```

        这样做是可以的，但很烦人。如果我们愿意，我们可以利用一个变量可以在代码行的开头有一个值，并在结束时存储另一个值的事实。因此，我们可以写出这样的东西：

        ```java

        int x = 10; x = 2 + x;
        ```

        这也可以。第二行表示“取 x 的当前值（`10`），加上`2`，并存储总和

        1.  到变量 x。因此，当第二行代码开始执行时，x 为`10`，执行完毕后，x 为 12。加法的顺序无关紧要，所以我们甚至可以这样做：

            ```java

            int x = 10; x = x + 2;
            ```

            ```java

            1
            public class VariableChangeShortcuts
            2
            {
            3
            public static void main( String[]
            args )
            4
            {

            5
            int i, j, k;

            6

            ```

            …这与前一个例子相同。好的，现在来看代码！

            ```java

            11
            System.out.println(
            "i: "
            +
            i
            +
            "\tj: "
            +
            j
            +
            "\tk: "
            +
            k
            );
            12
            i = i + 3;

            13
            j = j ­ 3;

            14
            k = k * 3;

            15
            System.out.println(
            "i: "
            +
            i
            +
            "\tj: "
            +
            j
            +
            "\tk: "
            +
            k
            );
            16

            17
            i = 5;

            18
            j = 5;

            19
            k = 5;

            20

            21
            System.out.println(
            "\ni:
            "
            +
            i
            + "\tj:
            "
            +
            j
            + "\tk:
            "
            +
            k );
            22
            i += 3;

            23
            j ­= 3;

            24
            k *= 3;

            25
            System.out.println(
            "i: "
            +
            i
            +
            "\tj: "
            +
            j
            +
            "\tk: "
            +
            k
            );
            26

            27
            i = j = k = 5;

            28

            29
            System.out.println(
            "\ni:
            "
            +
            i
            + "\tj:
            "
            +
            j
            + "\tk:
            "
            +
            k );
            30
            i += 1;

            31
            j ­= 2;

            32
            k *= 3;

            33
            System.out.println(
            "i: "
            +
            i
            +
            "\tj: "
            +
            j
            +
            "\tk: "
            +
            k
            );

            34
            35
            36
            37
            38
            39
            40
            41
            42
            43
            44
            45
            46
            47
            48
            49
            50 }
            ```

            ```java
            i = j = k = 5;

            System.out.println( "\ni: " + i + "\tj: " + j + "\tk: " + k ); i =+ 1;
            j =­ 2;
            System.out.println( "i: " + i + "\tj: " + j + "\tk: " + k ); i = j = k = 5;
            System.out.println( "\ni: " + i + "\tj: " + j + "\tk: " + k ); i++;
            j­­;
            System.out.println( "i: " + i + "\tj: " + j + "\tk: " + k );
            ```

            ```java
            }
            ```

            ### 你应该看到的

            ```java

            i:
            5
            j:
            5
            k:
            5
            i:
            8
            j:
            2
            k:
            15
            i:
            5
            j:
            5
            k:
            5
            i:
            8
            j:
            2
            k:
            15
            i:
            5
            j:
            5
            k:
            5
            i:
            6
            j:
            3
            k:
            15
            i:
            5
            j:
            5
            k:
            5
            i:
            1
            j:
            ­2
            k:
            5
            i:
            5
            j:
            5
            k:
            5
            i:
            6
            j:
            4
            k:
            5
            ```

            希望第 1-21 行很好很无聊。我们创建三个变量，给它们赋值，显示它们，改变它们的值，然后再次打印它们。然后从第 17 行开始，我们给变量相同的值，并打印它们。

            在第 22 行，我们看到了一些新东西：一种称为“复合赋值运算符”的快捷方式。`i += 3`的意思与`i = i + 3`相同：“取 i 的当前值，加上`3`，并将结果存储为 i 的新值。当我们大声说出来时，我们会说“i 加 3”。

            在第 23 行，我们看到`­=`（“减等于”），从 k 中减去 3，第 24 行演示了`*=`，表示乘法。还有`/=`，它将左边的变量除以右边的值。还有“模等于”（`%=`），它将左边的变量设置为其先前值除以右边的值时余数。呼。

            然后在第 27 行，我做了一些奇怪的事情。我不是用三行代码来将 i、j 和 k 都设置为`5`，而是用一行代码。有些人不赞成这种技巧，但我认为在这种情况下是可以的。第 27 行的意思是“将值`5`放入变量 k。然后取当前 k 中的值（`5`）的副本，并将其存储到 j 中。然后取当前 j 中的值的副本，并将其存储到 i 中。”因此，当这行代码执行完毕时，所有三个变量都已更改为等于`5`。

            第 30 至 32 行基本上与第 22 至 24 行相同，只是我们不再使用`3`

            作为要添加、减去或相乘的数字。

            第 38 行可能看起来像是一个打字错误，如果你在自己的代码中写了这个，它可能会是一个打字错误。请注意，我写的不是`+=`，而是`=+`。这将编译，但它的解释方式与你期望的不同。编译器

            看到`i = +1;`，也就是“将 i 设置为正 1。”第 39 行类似“将 j 设置为负 2。”所以要注意这一点。

            在第 45 行，我们看到了另一个快捷方式：“后增量运算符”。`i++`就意味着“在 i 中加 1”。这与写`i = i + 1`或`i += 1`是一样的。将`1`加到变量中是非常常见的。（你会看到的。）这就是为什么有一个特殊的快捷方式。

            在第 46 行，我们看到“后减量运算符”：`j--`。它从 j 的值中减去 1。

            今天的课程很特别，因为这些快捷方式是可选的。你可以一辈子编写代码而不使用它们。但大多数程序员都很懒，不想多打字，所以如果你阅读别人的代码，你会经常看到这些。

            ## 练习 12：布尔表达式

            到目前为止，我们只看到了三种类型的变量：

            #### 整数

            整数，不带小数部分的数字（正数或负数）

            #### 双精度

            “双精度浮点”数字（正数或负数），可能有小数部分

            #### 字符串

            一个字符串是字符，保存单词、短语、符号、句子，无论什么

            但用 Yoda 的话来说：“还有另一个。”“布尔”变量（以数学家乔治·布尔命名）不能保存数字或单词。它只能存储两个值中的一个：`true`或`false`。就是这样。我们可以用它们来执行逻辑。来看代码吧！

            ```java

            1 import java.util.Scanner; 2
            3 public class BooleanExpressions
            4 {
            5

            public static void main( String[] args )
            6

            {
            7

            Scanner keyboard = new Scanner(System.in);
            8

            9

            boolean a, b, c, d, e, f;
            10

            double x, y;
            11

            12

            System.out.print( "Give me two numbers. First: " );
            13

            x = keyboard.nextDouble();
            14

            System.out.print( "Second: " );
            15

            y = keyboard.nextDouble();
            16

            17

            a = (x < y);
            18

            b = (x <= y);
            19

            c = (x == y);
            20

            d = (x != y);
            21

            e = (x > y);
            22

            f = (x >= y);
            23

            24

            System.out.println( x + " is LESS THAN " + y + ": " + a );
            25

            System.out.println( x + " is LESS THAN or EQUAL TO " + y + ": " + b );
            26

            System.out.println( x + " is EQUAL TO " + y + ": " + c );
            27

            System.out.println( x + " is NOT EQUAL TO " + y + ": " + d );
            28

            System.out.println( x + " is GREATER THAN " + y + ": " + e );
            29

            System.out.println( x + " is GREATER THAN or EQUAL TO " + y + ": " + f
            );

            30

            System.out.println();
            31

            32

            System.out.println( !(x < y) + " " + (x >= y) );
            33

            System.out.println( !(x <= y) + " " + (x > y) );
            34

            System.out.println( !(x == y) + " " + (x != y) );
            35

            System.out.println( !(x != y) + " " + (x == y) );
            36

            System.out.println( !(x > y) + " " + (x <= y) );
            37

            System.out.println( !(x >= y) + " " + (x < y) );
            38

            39

            }
            40
            }

            ```

            ### 你应该看到的内容

            ```java

            Give me two numbers. First: 3 Second: 4
            3.0 is LESS THAN 4.0: true
            3.0 is LESS THAN or EQUAL TO 4.0: true
            3.0 is EQUAL TO 4.0: false
            3.0 is NOT EQUAL TO 4.0: true
            3.0 is GREATER THAN 4.0: false
            3.0 is GREATER THAN or EQUAL TO 4.0: false

            false false false false true true false false true true true true
            ```

            在第 17 行，布尔变量 a 被设置为一些奇怪的东西：比较的结果。变量 x 中的当前值与变量 y 的值进行比较。如果 x 小于 y，则比较为真，并且布尔值`true`存储在 a 中。如果 x 不小于 y，则比较为假，并且布尔值`false`存储在 a 中。（我认为这比写起来更容易理解。）

            第 18 行类似，只是比较是“小于或等于”，布尔结果存储在*b*中。

            第 19 行是“等于”：如果 x 持有与 y 相同的值，c 将被设置为值`true`。第 20 行的比较是“不等于”。第 21 行和第 22 行分别是“大于”和“大于或等于”。

            在第 24 行到第 29 行，我们在屏幕上显示了所有这些布尔变量的值。

            第 32 行到第 37 行介绍了“非”运算符，即感叹号（`!`）。它取逻辑相反。因此，在第 32 行，我们显示“x 是否小于 y”的逻辑否定，并打印出“x 是否大于或等于 y”的真值，它们是等价的。（“小于”的相反是“大于或等于”。）第 33 行到第 37 行显示了其余关系运算符的相反情况。

            ## 练习 13：比较字符串

            在这个练习中，我们将看到一些让初学者学习 Java 时困扰的东西：常规的关系运算符不适用于字符串，只适用于数字。

            ```java

            boolean a, b;
            a = ("cat" < "dog");
            b = ("horse" == "horse" );
            ```

            第二行甚至无法编译！你不能在 Java 中使用`<`来查看一个单词是否在另一个单词之前。在第三行中，b 确实在这里设置为值`true`，但如果你将值读入变量，就不会这样：

            ```java

            String animal;
            animal = keyboard.next(); // the user types in "horse" b = ( animal == "horse" );
            ```

            无论人类是否输入`"horse"`，b 都将始终被设置为值`false`！

            我不想试图解释为什么会这样。Java 的创建者对此显然有充分的理由，但对初学者来说并不友好，解释可能只会让你更加困惑。

            你还记得我警告过你 Java 不是初学者的语言吗？所以*有*一种比较字符串是否相等的方法，让我们来看看。

            ```java
            1 import java.util.Scanner; 2
            3 public class WeaselOrNot
            4 {
            5

            public static void main( String[] args )
            6

            {
            7

            Scanner keyboard = new Scanner(System.in);
            8

            9

            String word;
            10

            boolean yep, nope;
            11

            12

            System.out.println( "Type the word \"weasel\", please." );
            13

            word = keyboard.next();
            14

            15

            yep = word.equals("weasel");
            16

            nope = ! word.equals("weasel");
            17

            18

            System.out.println( "You typed what was requested: " + yep );
            19

            System.out.println( "You ignored polite instructions: " + nope );
            20

            }
            21
            }

            ```

            ### 你应该看到的内容

            ```java

            Type the word "weasel", please. no
            You typed what was requested: false You ignored polite instructions: true
            ```

            因此，字符串有一个名为`.equals()`的内置方法（“点等于”），它将自己与另一个字符串进行比较，如果它们相等，则简化为值`true`，如果它们不相等，则简化为值`false`。你必须使用非运算符（`!`）与`.equals()`方法一起来判断两个字符串是否不同。

            ### 学习技巧

            1.  尝试在第 15 行改变比较，使得`"weasel"`在点的前面，变量 word 在括号内。确保`"weasel"`仍然被引号括起来，而 word 则没有。它有效吗？

        ## 练习 14：复合布尔表达式

        1 导入 java.util.Scanner; 2

        3 public class ShallowGrandmother 4 {

        5

        6

        7

        8

        9

        10

        11

        12

        13

        14

        15

        16

        17

        18

        19

        20

        21

        22

        23

        24

        25

        26 }

        public static void main( String[] args )

        {

        键盘扫描器=新的扫描器（系统。在）;

        年龄；

        双收入，吸引力；布尔允许；

        System.out.print( "输入你的年龄：" ); age = keyboard.nextInt();

        System.out.print( "输入你的年收入：" );收入=键盘。nextDouble();

        System.out.print( "你有多吸引人，从 0.0 到 10.0 的范围？" );吸引力=键盘。nextDouble();

        允许=（年龄>25 && 年龄<40 &&（收入>50000 || 吸引力>=8.5））; System.out.println( "你被允许约会我的孙子：" + 允许);

        }

        有时我们想使用比“小于”或“等于”更复杂的逻辑。想象一下，只有在 25 岁以上*并且*40 岁以下*并且*要么富有要么长得很好看时，祖母才会同意你约会她的孙子。如果那位祖母是一名程序员，并且能说服申请者诚实回答，她的程序可能会像这样：

        ### 你应该看到什么

        ```java

        Enter your age: 39
        Enter your yearly income: 49000
        How attractive are you, on a scale from 0.0 to 10.0? 7.5 You are allowed to date my grandchild: false
        ```

        所以我们可以看到，对于复杂的布尔表达式，您可以使用括号来分组，使用符号`&&`表示“AND”，使用符号`||`表示“OR”。

        我知道你在想什么：使用`&`（“和符号”）表示“AND”有点说得通，但为什么要两个？谁想到使用`||`（“管道管道”）表示“OR”？！？

        嗯，肯·汤普森的想法，可能是。Java 语法是模仿 C++的语法，而 C++的语法基本上是从 C 的语法复制过来的，而 C 的语法是从 B 的语法修改而来的，而 B 的语法是由丹尼斯·里奇和肯·汤普森发明的。

        编程语言 B 使用`&`表示“AND”，`|`表示“OR”，但它们是“按位的”：它们只对两个整数起作用，并且它们会逐位地遍历整数，对每一对比特进行按位 AND 或 OR 运算，在每次比较中放置`1`或`0`在输出中。（`|`可能被使用是因为它看起来像数学符号，并且是 PDP-7 计算机键盘上的一个关键，B 最初是为其开发的。）

        当肯恩和丹尼斯开始开发编程语言*C*来取代*B*时，他们决定需要一个*逻辑*的“AND”和“OR”，而单个符号已经被使用了，所以他们使用两个和符号来表示逻辑“AND”，两个竖线或“管道”来表示逻辑“OR”。哇。

        幸运的是，你不需要知道任何这些。你只需要记住要输入什么并且输入正确。

        接下来的一点有点奇怪，因为我将向您展示 AND 和 OR 的“真值表”，您将不得不将“AND”视为对两个值执行的*操作*，而不是一个连接词。

        以下是 AND 的真值表：

        输入

        输出

        A

        B

        A && B

        正确

        正确

        正确

        正确

        错误

        错误

        错误

        正确

        错误

        错误

        错误

        错误

        您可以这样读表：假设我们的肤浅的祖母已经决定，只有在巡航便宜并且酒精包含在价格中时，她才会去乘船。所以我们假设陈述 A 是“巡航很便宜”，陈述 B 是“酒精包括在内”。表中的每一行都是一个可能的巡航航线。

        第 1 行是两个语句都为真的情况。祖母会对第 1 条巡航感到兴奋吗？是的！“巡航很便宜”是真的，“酒精包括在内”也是真的，所以“祖母会去”（A && B）也是真的。

        巡航#2 很便宜，但酒精*不*包括在内（陈述 B 是假的）。所以祖母不感兴趣：（A && B）是假的，当 A 为真时，B 为假。

        清楚吗？现在这是 OR 的真值表：

        输入

        输出

        A

        B

        A || B

        正确

        正确

        正确

        正确

        错误

        正确

        错误

        正确

        真

        假

        假

        假

        假设祖母会购买某辆二手车，如果它看起来真的很酷，或者它的油耗很好。陈述 A 是“车看起来很酷”，B 是“每加仑好里程”，结果 A 或 B 决定了祖母是否想要这辆车。

        汽车＃1 看起来很棒，而且一箱油可以走很远。祖母感兴趣吗？当然！我们可以说值`true`与值`true`进行 OR 运算的结果是`true`。

        事实上，祖母不喜欢的唯一一辆车是两者都是假的时候。涉及 OR 的表达式只有在其两个组成部分都为假时才为假。

        ### 学习演习

        1.  你知道 Java 也有位运算符吗？调查一下数字是如何用二进制表示的，看看你能否弄清楚为什么以下代码将 x 设置为值`7`，将 y 设置为值`1`。

            ```java
            int x = 3 | 5;
            int y = 3 & 5;
            ```

            ## 练习 15：使用 if 语句做决定

            嘿！我真的很喜欢这个练习。你在那里经历了一些相当无聊的练习，所以现在是时候学习一些有用而不是超级困难的东西了。

            ```java

            1 import java.util.Scanner; 2
            3 public class AgeMessages 4 {
            ```

            ```java
            5
            6
            7
            8
            9
            10
            11
            12
            13
            14
            15
            ```

            ```java
            public static void main( String[] args )
            {
            Scanner keyboard = new Scanner(System.in);
            ```

            ```java
            int age;

            System.out.print( "How old are you? " ); age = keyboard.nextInt();

            if ( age < 13 )
            {
            ```

            ```java
            16   System.out.println( "You are too young to create a Facebook account." );
            ```

            ```java
            17
            18
            19
            20
            ); 21
            22
            23
            24
            25
            26
            27
            28
            29
            30
            31
            ```

            ```java
            }
            if ( age < 16 )
            {
            System.out.println( "You are too young to get a driver's license."
            ```

            ```java
            }
            if ( age < 18 )
            {
            System.out.println( "You are too young to get a tattoo." );
            }
            if ( age < 21 )
            {
            System.out.println( "You are too young to drink alcohol." );
            }
            if ( age < 35 )
            {
            ```

            ```java
            32    System.out.println( "You are too young to run for President of the United States." );
            ```

            ```java
            33
            34
            35
            36 }
            ```

            ```java
            System.out.println( "How sad!" );
            ```

            ```java
            }
            ```

            ```java
            }
            ```

            我们将学习如何编写具有决策的代码，以便输出不总是相同的。执行的代码会根据人输入的内容而改变。

            ### 你应该看到什么

            ```java

            How old are you? 17
            You are too young to get a tattoo. You are too young to drink alcohol.
            You are too young to run for President of the United States. How sad!
            ```

            好的，这就是所谓的“if 语句”。if 语句以关键字`if`开头，后面跟着括号中的“条件”。条件必须是一个布尔表达式，其值为`true`或`false`。在下面开始了由大括号包围的一块代码，大括号里面的东西缩进了一层。这段代码被称为 if 语句的“主体”。

            当 if 语句的条件为真时，if 语句的主体中的所有代码都会被执行。

            当 if 语句的条件为假时，主体中的所有代码都会被跳过。你可以在 if 语句的主体中有任意多行代码；它们将作为一组被执行或跳过。

            注意，当我运行代码时，我输入了`17`作为我的年龄。因为 17 不小于 13，所以第 14 行的条件是假的，所以第一个 if 语句的主体中的代码（第 15 到 17 行）被跳过了。

            第二个 if 语句也是假的，因为 17 不小于 16，所以它的主体中的代码（第 19 到 21 行）也被跳过了。

            第三个 if 语句的条件是真的：17 确实小于 18，所以第三个 if 语句的主体不会被跳过；它被执行了，屏幕上打印出了“你太年轻了，不能纹身”的短语。练习中剩下的 if 语句都是真的。

            最后的 if 语句包含两行代码在它的主体中，只是为了向你展示它会是什么样子。

            ### 学习演习

            1.  如果你输入一个大于 35 的年龄，会打印出什么？为什么？

            1.  再添加一个 if 语句，将他们的年龄与 65 进行比较。如果他们的年龄大于或等于 65 岁，就说“你已经足够老了，可以退休了！”。

            1.  对于每个 if 语句，添加另一个说相反的 if 语句。例如，如果他们的年龄大于或等于 13 岁，就说“你已经足够大了，可以创建一个 Facebook 账户。”完成后，无论输入什么年龄，你的程序每次都应该显示六条消息。

        ## 练习 16：更多的 if 语句

        ```java

        1 import java.util.Scanner; 2
        3 public class ComparingNumbers
        4 {
        5
        public static void main( String[] args )

        6
        {

        7
        Scanner keyboard = new Scanner(System.in);

        8
        double first, second;

        9

        10
        System.out.print( "Give me two numbers. First:
        " );
        11
        first = keyboard.nextDouble();

        12
        System.out.print( "Second: " );

        13
        second = keyboard.nextDouble();

        14

        ```

        这个练习几乎没有什么新东西。这只是对 if 语句的更多练习，因为它们非常重要。这也会帮助你记住关系运算符。

        ```java

        17

        System.out.println(
        first
        +
        "
        is
        LESS THAN " + second );
        18

        }

        19

        if
        ( first <= second )

        20

        {

        21

        System.out.println(
        first
        +
        "
        is
        LESS THAN or EQUAL TO " + second );
        22

        }

        23

        if
        ( first == second )

        24

        {

        25

        System.out.println(
        first
        +
        "
        is
        EQUAL TO " + second );
        26

        }

        27

        if
        ( first >= second )

        28

        {

        29

        System.out.println(
        first
        +
        "
        is
        GREATER THAN or EQUAL TO "+second);
        30

        }

        31

        if
        ( first > second )

        32

        {

        33

        System.out.println(
        first
        +
        "
        is
        GREATER THAN " + second );
        34

        }

        35

        36

        if
        ( first != second )

        37

        System.out.println(
        first
        +
        "
        is
        NOT EQUAL TO " + second );
        38

        39

        }

        40
        }

        ```

        ### 你应该看到什么

        ```java

        Give me two numbers. First: 3 Second: 4
        3.0 is LESS THAN 4.0
        3.0 is LESS THAN or EQUAL TO 4.0
        3.0 is NOT EQUAL TO 4.0
        ```

        在第 37 行，你会看到我做了一些有问题的事情：最后一个 if 语句的主体没有任何大括号围绕它。这样可以吗？

        实际上是。当 `if` 语句的主体没有花括号时，那么在条件之后的代码的第一行将被包括在主体中。因此，由于这整个练习中的所有 `if` 语句的主体只有一行代码，所以这个练习中的所有 `if` 语句的花括号都是可选的。你可以删除并且程序会正常工作。不过，包括它们永远不会错，有些程序员总是无论如何都会加上花括号。

        ### 学习技巧

        1\. 在第 37 行之后添加另一行代码，写上 `System.out.println( "Hey." );`。缩进它，使其与上面的 `println()` 语句对齐，就像这样：

        ```java
        if ( first != second )
        System.out.println( first + " is NOT EQUAL TO " + second ); System.out.println( "Hey." );
        ```

        运行程序，看看会发生什么。 “嘿” 部分是否属于 if 语句主体？也就是说，当 if 语句被跳过时，“嘿”也被跳过了，还是无论如何都会运行？你觉得呢？

        1\. 在最后一个 if 语句的主体周围添加花括号，以便“嘿”行是主体的一部分。然后删除所有*其他* if 语句主体的花括号，以便程序中只有最后一个 if 语句有它们。确认一切都按预期工作。

        ## 练习 17：否则（带 else 的 if 语句）

        所以，`if` 语句非常棒。几乎每种编程语言都有它们，你一直都在使用它们。事实上，`if` 语句本身就足够功能强大，你可以只使用 `if` 语句做很多事情。

        但有时，有其他东西可能会使事情变得更加方便。比如这个例子：快！以下表达式的逻辑相反是什么？

        ```java

        if ( onGuestList || age >= 21 || ( gender.equals("F") && attractiveness >= 8 ) )
        ```

        嗯？懂了吗？如果是的话

        if ( ! ( onGuestList || age >= 21 || ( gender.equals("F") && attractiveness >= 8 ) ) )

        …然后你是对的，你是我的菜。聪明并且知道什么时候让机器为你工作。如果你说

        if ( ! onGuestList && age < 21 && ( ! gender.equals("F") || attractiveness < 8 ) )

        …然后你是对的，干得好。这实际上是相当难以正确做到的。但是这个的逻辑相反又是什么呢：

        ```java

        if ( expensiveDatabaseThatTakes45SecondsToLookup( userName, password ) == true )
        ```

        我们真的想要写

        ```java

        if ( expensiveDatabaseThatTakes45SecondsToLookup( userName, password ) == false )
        ```

        ```java

        1 import java.util.Scanner; 2
        3 public class ClubBouncer 4 {
        ```

        ```java
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        ```

        ```java
        public static void main( String[] args )
        {
        Scanner keyboard = new Scanner(System.in);
        ```

        ```java
        int age = 22;
        boolean onGuestList = false; double attractiveness = 7.5; String gender = "F";

        if ( onGuestList || age >= 21 || ( gender.equals("F") && attractiveness >= 8 ) )
        ```

        ```java
        15
        16
        17
        18
        19
        20
        21
        22
        23 }
        ```

        ```java
        {
        ```

        ```java
        System.out.println("You are allowed to enter the club.");
        ```

        ```java
        }
        else
        {
        ```

        ```java
        System.out.println("You are not allowed to enter the club.");
        ```

        ```java
        }
        ```

        ```java
        }
        ```

        …因为现在我们不得不等待 90 秒来执行两个 `if` 语句，而不是 45 秒。所以幸运的是，编程语言给了我们一些 `else`。（是的，抱歉。忍不住。）

        ### 你应该看到的

        ```java

        You are allowed to enter the club.
        ```

        所以 `else` 关键字的意思是：看看前面的 `if` 语句。那个条件是

        `if` 语句为真吗？如果是，跳过。如果之前的 `if` 语句没有运行，那么

        否则语句将被执行。“如果 blah blah blah 为真，则运行这个代码块。否则（else），运行这个不同的代码块。”

        否则非常方便，因为我们不必去计算一些复杂布尔表达式的逻辑相反。我们只需要说 `else`，让计算机处理它。

        `else` 只有在 `if` 语句结束后立即合法。（严格来说，它只允许在 `if` 语句的主体代码块结束后。）

        ### 学习技巧

        1\. 在第 17 行和第 18 行之间，添加一个 `println()` 语句来在屏幕上打印一些东西（不重要，但我放了 `"C­C­C­COMBO BREAKER"` 因为我很奇怪）。尝试编译程序。为什么不能编译？

        ## 练习 18：带字符串的 if 语句

        ```java

        1 import java.util.Scanner; 2
        3 public class SecretWord 4 {
        ```

        ```java
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        ```

        ```java
        public static void main( String[] args )
        {
        Scanner keyboard = new Scanner(System.in);
        ```

        ```java
        String secret = "please", guess;

        System.out.print( "What's the secret word? " ); guess = keyboard.next();

        if ( guess == secret )
        {
        System.out.println( "Impossible. (This will never be printed.)" );
        }

        if ( guess.equals(secret) )
        {
        System.out.println( "That's correct!" );
        }
        else
        {
        System.out.println( "Nope, the secret word is not \"" + guess +
        ```

        ```java
        "\"." );
        26    }
        27
        28 }
        29 }
        ```

        几个练习之前，你学会了比较字符串不像比较数字那么容易。所以让我们用一个你可以实际测试的例子来复习一下。

        ### 你应该看到的

        ```java

        What's the secret word? abracadabra
        Nope, the secret word is not "abracadabra".
        ```

        注意，和往常一样，我在偷偷加入一些东西。在第 9 行，我不仅仅是声明 *secret*，我还给它赋了一个值。也就是说，我“定义”了它（一次性声明和初始化）。

        无论如何，第 14 行的 `if` 语句永远不会为真。无论你输入什么，猜测 `==` 秘密永远不会成立。

        （我无法解释为什么，因为那样会涉及太多细节，但这与`==`只比较变量的浅层值有关，两个字符串的浅层值只有在它们引用相同的内存位置时才相等。）

        有效的方法是使用`.equals()`方法（它比较变量的深层值而不是它们的浅层值）。如果他们输入了正确的秘密词，这将为真。

        ## 练习 19：使用 if 和 else 链进行互斥

        在上一个练习中，我们看到使用`else`可以更容易地包含一块备用代码，当`if`语句没有发生时，你想要运行的。

        ```java

        1 import java.util.Scanner; 2
        3 public class BMICategories 4 {
        ```

        ```java
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32
        33
        34
        35
        36
        37
        38
        39
        40
        41
        42
        43
        44
        45
        46
        47
        48 }
        ```

        ```java
        public static void main( String[] args )
        {
        Scanner keyboard = new Scanner(System.in);
        ```

        ```java
        double bmi;

        System.out.print( "Enter your BMI: " ); bmi = keyboard.nextDouble();

        System.out.print( "BMI category: " ); if ( bmi < 15.0 )
        {
        System.out.println( "very severely underweight" );
        }
        else if ( bmi <= 16.0 )
        {
        System.out.println( "severely underweight" );
        }
        else if ( bmi < 18.5 )
        {
        System.out.println( "underweight" );
        }
        else if ( bmi < 25.0 )
        {
        System.out.println( "normal weight" );
        }
        else if ( bmi < 30.0 )
        {
        System.out.println( "overweight" );
        }
        else if ( bmi < 35.0 )
        {
        System.out.println( "moderately obese" );
        }
        else if ( bmi < 40.0 )
        {
        System.out.println( "severely obese" );
        }
        else
        {
        System.out.println( "very severely/\"morbidly\" obese" );
        }
        ```

        ```java
        }
        ```

        但是，如果替代代码是……另一个`if`语句呢？

        ### 你应该看到什么

        ```java

        Enter your BMI: 22.5
        BMI category: normal weight
        ```

        （*注意*：尽管 BMI 是人体脂肪的一个很好的估计值，但这个公式对于肌肉量很大的运动员，或者身材极矮或极高的人来说效果不佳。如果你担心

        你的 BMI，请咨询医生。）

        请注意，即使几个`if`语句可能都为真，只有第一个为真的`if`语句才会在屏幕上打印它的消息。没有其他消息被打印：只有一个。这就是使用`else`与`if`的威力。

        在第 15 行有一个`if`语句，检查你的 BMI 是否小于`15.0`，如果是，则显示该体重指数的适当类别。

        第 19 行以`else`开头。这个 else 关注前面的`if`语句——第 15 行的那个——以确定它是否应该运行它的代码块或自动跳过它。假设你输入了 BMI 为`22.5`，那么前面的`if`语句不成立，也没有运行。因为那个`if`语句失败了，else 将自动执行它的代码块。

        然而，这段代码块紧跟在`else`后面，后面是一个新的`if`语句！这意味着当前面的`if`语句为假时，语句`if ( bmi <= 16.0 )`才会被考虑。

        每当我的学生对此感到困惑时，我都会给他们一个类比。（有点粗糙，但似乎有所帮助。）

        想象一下你是单身（浪漫方面的意思），你和一些朋友在酒吧或商场或其他地方。在对面，你看到一个真的很有吸引力的单身，你悄声告诉其他人：“好的，我先来。”

        你的团队走向这个人，但除非他们看到你的表现如何，否则没有人会开始调情。如果你似乎正在取得进展，你的朋友们会退后，让你畅所欲言。然而，如果你被拒绝，那么你的其他伙伴之一就会感到有机会尝试并发起进攻。

        这基本上就是`else if`的作用。一个`else if`语句（一个在`if`语句前面有`else`的`if`语句）包含一个可能为真或可能为假的条件。但是`else`意味着`if`语句只会检查它是否为真或假，假设前面的`if`语句（只有紧接着的那个）为假。

        第 23 行的`else`使得第 19 行开始的`if`语句推迟到第 19 行的`if`语句：如果为真，第 23 行的`if`语句将跳过，即使它本来是真的。第 27 行的`else`使得它的`if`语句推迟到前面的`if`语句，依此类推。最后一行 43 的`else`就像一群中最小的狗：只有在链中所有前面的`if`语句都为假时才会执行。

        我们将在下一个练习中再多谈一些这个问题，现在就到此为止。

        ### 学习演习

        1.  从第 27 行`if`语句前面删除`else`。运行程序，然后输入

            `15.5`作为 BMI。你看到了吗，这使得第 27 行的`if`语句“打破了规矩”，不再关心它之前的`if`语句？

        1.  不要让人直接输入他们的 BMI，让他们输入身高和体重，然后为他们计算 BMI。

        ## 练习 20：更多的`else`和`if`链。

        好的，让我们更仔细地看一下使用`else`和`if`构建条件链。

        1.  ```java
            import java.util.Scanner;
            ```

        1.  ```java
            import static java.lang.System.*; 3
            ```

        ```java
        4 public class CollegeAdmission 5 {
        6  public static void main( String[] args ) 7 {
        ```

        1.  ```java
            Scanner keyboard = new Scanner(System.in);
            ```

        1.  ```java
            int math; 10
            ```

        ```java
        11  out.println( "Welcome to the UT Austin College Admissions Interface!" );
        ```

        ```java
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32 }
        ```

        ```java
        out.print( "Please enter your SAT math score (200­800): " ); math = keyboard.nextInt();
        ```

        ```java
        out.print( "Admittance status: " );

        if ( math >= 790 ) out.print( "CERTAIN " );
        else if ( math >= 710 ) out.print( "SAFE " );
        else if ( math >= 580 ) out.print( "PROBABLE " );
        else if ( math >= 500 ) out.print( "UNCERTAIN " );
        else if ( math >= 390 ) out.print( "UNLIKELY " );
        else // below 390 out.print( "DENIED " );

        out.println();
        ```

        ```java
        }
        ```

        坦白说：尽管我确实参加了德克萨斯大学奥斯汀分校，但我认为这不是他们真正的录取标准。在决定是否申请备用学校时，不要依赖这个程序的输出。

        ### 你应该看到的

        ```java

        Welcome to the UT Austin College Admissions Interface! Please enter your SAT math score (200­800): 730 Admittance status: SAFE
        ```

        现在，在我进入这个练习的新内容之前，我应该解释一下我在这个程序中采取的一个快捷方式。你有没有注意到顶部有第二个`import`语句？如果没有，那么你的代码没有编译，或者你认为我在所有地方都写错了，应该是`out.println`而不是`System.out.println`。

        好吧，我不想在这本书中过多地谈论面向对象的代码，因为那对初学者来说太复杂了，但是可以这样想。在 Java 中有一个内置对象叫做`System`。在该对象内部还有另一个名为`out`的对象。名为`out`的对象包含一个名为`print()`和一个名为`println()`的方法。

        所以当你写`System.out.println`时，你是在要求计算机运行名为`out`的对象内部的名为`println`的方法（它本身是内置导入库`java.lang.System`的一部分）。

        因此，我可以创建一个名为`out`的变量，这不会有问题：

        ```java

        String out;
        ```

        尽管有一个名为`out`的对象存在，但它在`System`对象内部，所以名称不会冲突。

        如果我懒惰并且没有任何愿望拥有自己命名为`out`的变量，那么我可以要求计算机“将类`java.lang.System`中的所有静态项目导入当前命名空间”：

        ```java

        import static java.lang.System.*;
        ```

        所以现在我可以只输入`out.println`而不是`System.out.println`。哇！

        在这个练习中，我还省略了界定每个`if`语句主体中代码块的所有花括号。因为我只想在每个`if`语句的主体中有一个语句，所以这是可以的。如果我想要有多于一行的代码，那么我就必须把花括号放回去。

        无论如何，在之前的练习中，我写了如何将`else`放在`if`语句前面使其延迟到前一个`if`语句。当前一个为真并执行其主体中的代码时，当前一个会自动跳过（链中的所有其他`else if`语句也会跳过）。这会使得只有第一个为真的值会触发`if`语句，其他所有的都不会运行。我们有时会说`if`语句是“互斥的”：只有一个会执行。不会少于一个，也不会多于一个。

        今天的练习是另一个例子。但是这次我想指出，互斥只能正常工作是因为我按正确的顺序放置了`if`语句。

        因为第一个为真的将会执行，而其他的不会，所以你需要确保链中的第一个`if`语句是最难实现的。然后是下一个最难的，以此类推，最容易的放在最后。在学习演习中，我会让你改变`if`语句的顺序，你会看到这样会搞乱事情。

        此外，从技术上讲，`else`语句应该有花括号，就像`if`语句一样，通过将`else if`之间什么都不放置来利用花括号是可选的事实。这使得代码更加紧凑。如果按计算机解释的方式排列，先前的代码将是这样的。也许这会帮助你理解`else`在`if`前面的“延迟”行为；也许这只会让你困惑。希望它会有所帮助。

        1.  ```java
            import java.util.Scanner;
            ```

        1.  ```java
            import static java.lang.System.*; 3
            ```

        ```java
        4 public class CollegeAdmissionExpanded 5 {
        6   public static void main( String[] args ) 7   {
        ```

        1.  ```java
            Scanner keyboard = new Scanner(System.in);
            ```

        1.  ```java
            int math; 10
            ```

        1.  ```java
            out.println( "Welcome to the UT Austin College Admissions Interface!" );
            ```

        1.  ```java
            out.print( "Please enter your SAT math score (200­800): " );
            ```

        1.  ```java
            math = keyboard.nextInt(); 14
            ```

        ```java
        15    out.print( "Admittance status: " ); 16
        17    if ( math >= 790 )
        18    {
        19      out.print( "CERTAIN " ); 20    }
        21    else
        22    {
        23      if ( math >= 710 )
        24      {
        25        out.print( "SAFE " ); 26      }
        27      else
        28      {
        29        if ( math >= 580 )
        30        {
        31          out.print( "PROBABLE " ); 32        }
        33        else
        34        {
        35          if ( math >= 500 )
        36         {
        37            out.print( "UNCERTAIN " ); 38          }
        39         else
        40         {
        41           if ( math >= 390 )
        42           {
        43             out.print( "UNLIKELY " );
        44           }
        45           else // below 390
        46           {
        47             out.print( "DENIED " );
        48           }
        49         }
        50        }
        51      }
        52    }
        53 out.println(); 54   }
        55 }
        ```

        是的。所以你可以看到为什么我们通常只是使用`else if`。

        ### 学习演习

        1.  在原始的代码文件（`CollegeAdmission.java`）中，除了最后一个之外，删除所有的`else`。

            最后一个。运行它并注意它如何打印所有的消息。然后把`else`放回去。

        1.  将第 25 行和第 26 行移动到第 18 行和第 19 行之间。编译并运行它，注意程序几乎总是只说`"UNLIKELY"`，因为大多数 SAT 分数都超过 390，而且`if`语句在列表中的位置很高，大部分时间都会占据主导地位。

        1.  如果愿意，可以输入`CollegeAdmissionExpanded.java`的代码，并确认它与非扩展版本的功能相同。

        ## 练习 21：嵌套 if 语句

        你在上一个练习中已经看到了这一点，但你可以在`if`语句的主体中放入任何你喜欢的东西，包括其他`if`语句。这被称为“嵌套”，在另一个`if`语句内部的`if`语句称为“嵌套 if”。

        ```java

        1 import java.util.Scanner; 2
        3 public class GenderTitles 4 {
        ```

        ```java
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32
        33
        34
        35
        36
        37
        38
        39
        40
        41
        42
        43
        44
        45
        46
        47
        48 }
        ```

        ```java
        public static void main( String[] args )
        {
        Scanner keyboard = new Scanner(System.in);
        ```

        ```java
        String title;

        System.out.print( "First name: " ); String first = keyboard.next(); System.out.print( "Last name: " ); String last = keyboard.next(); System.out.print( "Gender (M/F): " ); String gender = keyboard.next(); System.out.print( "Age: " );
        int age = keyboard.nextInt();

        if ( age < 20 )
        {
        title = first;
        }
        else
        {
        if ( gender.equals("F") )
        {
        System.out.print( "Are you married, "+first+"? (Y/N): " ); String married = keyboard.next();
        if ( married.equals("Y") )
        {
        title = "Mrs.";
        }
        else
        {
        title = "Ms.";
        }
        }
        else
        {
        title = "Mr.";
        }
        }

        System.out.println( "\n" + title + " " + last );
        ```

        ```java
        }
        ```

        这是使用它做一些有用的事情的一个例子。

        ### 你应该看到的

        ```java

        First name: Graham
        ```

        ```java
        Last name: Mitchell Gender (M/F): M Age: 39

        Mr. Mitchell
        ```

        你可能已经发现我喜欢稍微混合一下，让你保持警惕。你注意到我这次做了什么不同吗？

        通常我会在程序的顶部声明所有变量，并在稍后给它们赋值（或“初始化”）。但实际上，你不必在准备使用变量之前声明它。所以这一次，我声明了所有变量（除了*title*）在我第一次为它们赋值的同一行。

        那么为什么我不在第 22 行声明*title*呢？因为那样它以后就不在“范围”内了。*范围*指的是程序中变量可见的位置。一般规则是，一旦声明变量，从那时起在代码中的后续部分直到声明的块结束，变量就在范围内。然后变量就超出范围，不能再使用了。

        让我们看一个例子：在第 29 行，我定义（声明和初始化）了一个名为 married 的字符串变量。它是在女性性别`if`语句的主体内声明的。这个变量存在于第 29 行到第 38 行，在该`if`语句的主体块的右花括号处。married 变量在程序的其他任何地方都不在范围内；在第 1 到第 28 行或第 39 到第 48 行引用它会导致编译错误。

        这就是为什么我必须在程序的开始处声明*title*。如果我在第 22 行声明它，那么当年龄小于 20 的代码块的右花括号出现时，变量将会超出范围。因为我需要*title*一直可见，直到第 45 行，所以我需要确保我在代码块内声明它，该代码块在第 47 行结束。

        不过，我本来可以等到第 19 行再声明它。

        无论如何，关于这个练习没有太多有趣的事情要说，除了它演示了嵌套。

        `if`语句和其他`else`语句。不过，我在学习演习中有一个小惊喜。

        ### 学习演习

        1. 将第 39 行的`else`更改为合适的`if`语句，例如：

        ```java
        if ( gender.equals("M") )
        ```

        注意，程序不再编译。你能想出原因吗？

        这是因为变量*title*在第 9 行声明，但没有立即赋值。然后在第 45 行，*title*的值被打印在屏幕上。此时变量*必须*有一个值，否则我们将尝试显示一个未定义的变量的值：它*没有*值。编译器希望防止这种情况发生。

        当第 39 行是`else`时，编译器可以保证无论通过嵌套的`if`语句的哪条路径，*title*总是会得到一个值。一旦我们将其更改为常规的`if`语句，现在有一种方法，人类可以输入一些内容，使其通过所有嵌套的`if`语句，而不给*title*一个值。你能想到一个吗？

        （当提示输入性别时，他们可以输入年龄 20 或更大，以及不同于`"M"`或`"F"`的字母。

        然后，没有一个性别的`if`语句会为真。）

        我们可以通过将第 39 行的`else`语句更改为合适的`if`语句来解决这个问题（可能是个好主意），或者通过初始化

        在我们声明*title*的时候（可能是个好主意）：

        ```java

        String title = "error";
        ```

        ……或者类似的东西。现在*title*有一个值，无论如何，编译器都很高兴。

        ## 练习 22：使用大开关做决定

        `if`语句并不是在 Java 中比较变量值的唯一方法。还有一种叫做`switch`的东西。我并不经常使用它们，但无论如何你都应该熟悉它们，以防你读到别人使用它的代码。

        ```java

        1 import java.util.Scanner; 2
        3 public class ThirtyDays 4 {
        5   public static void main( String[] args ) 6   {
        7    Scanner keyboard = new Scanner(System.in); 8
        ```

        1.  ```java
            int month, days;
            ```

        1.  ```java
            String monthName; 11
            ```

        1.  ```java
            System.out.print( "Which month? (1­12) " );
            ```

        1.  ```java
            month = keyboard.nextInt(); 14
            ```

        ```java
        15    switch(month)
        16    {
        17
        case
        1:
        monthName
        =
        "January";
        18

        break;

        19
        case
        2:
        monthName
        =
        "February";
        20

        break;

        21
        case
        3:
        monthName
        =
        "March";
        22

        break;

        23
        case
        4:
        monthName
        =
        "April";
        24

        break;

        25
        case
        5:
        monthName
        =
        "May";
        26

        break;

        27
        case
        6:
        monthName
        =
        "June";
        28

        break;

        29
        case
        7:
        monthName
        =
        "July";
        30

        break;

        31
        case
        8:
        monthName
        =
        "August";
        32

        break;

        33
        case
        9:
        monthName
        =
        "September";
        34

        break;

        35
        case
        10:
        monthName
        =
        "October";
        36

        break;

        37
        case
        11:
        monthName
        =
        "November";
        38

        break;

        39
        case
        12:
        monthName
        =
        "December";
        40

        break;

        41
        default: monthName = "error";
        42
        }
        43

        44
        /* Thirty days hath September
        45
        April, June and November
        46
        All the rest have thirty­one
        47
        Except the second month alone....
        48
        */
        49

        50
        switch(month)
        51
        {
        52
        case 9:
        53
        case 4:
        54
        case 6:
        55
        case 11: days = 30;
        56
        break;
        57
        case 2: days = 28;
        58
        break;

        59
        60
        61
        62
        63
        64
        65 }
        ```

        ```java
        default: days = 31;
        ```

        ```java
        }
        ```

        ```java
        System.out.println( days + " days hath " + monthName );
        ```

        ```java
        }
        ```

        ### 你应该看到什么

        ```java

        Which month? (1­12) 4
        30 days hath April
        ```

        `switch`语句以关键字`switch`开始，然后是一些括号。括号内是一个单一的变量（或者简化为单一值的表达式）。然后是一个开放的大括号。

        在`switch`语句的主体内部有几个以关键字`case`开头的`case`语句，然后是括号中的变量可能相等的值。然后是一个冒号（`:`）。在 Java 中很少看到冒号。

        在`case`之后，是值和冒号，然后是一些代码。它可以是任意行的代码，除了你不允许在`switch`语句内部声明任何变量。然后在所有代码之后是关键字`break`。`break`标志着`case`的结束。

        当`switch`语句运行时，计算机会找出括号内变量的当前值。然后它逐个查看`case`列表，寻找匹配项。当它找到匹配项时，它会从`case`所在的左侧移动到右侧，并开始运行代码，直到被`break`停止。

        如果没有`case`匹配，且有一个`default`情况（可选），那么`default`中的代码将被运行。

        情况将被运行。

        第二个例子从第 50 行开始，演示了一旦`switch`语句找到与之匹配的情况，它确实会运行右侧的代码，直到遇到`break`语句。它甚至会从一个`case`穿过到另一个。

        我们可以利用这种穿透行为，有时做一些聪明的事情，比如计算一个月中的天数的代码。由于 9 月、4 月、6 月和 11 月都有 30 天，我们可以将它们的所有情况放在一起，让它们穿过任何一个运行相同的事情。

        无论如何，我不会在这本书中再使用`switch`语句，因为我几乎从来没有找到过它的好用处，但它确实存在，至少我可以说你看到了它。

        ### 学习训练

        1.  在第一个`switch`中删除一些`break`语句，并添加一些`println()`语句来确认它会将 monthName 设置为一个值，然后又一个值，直到最后被`break`停止。

        ## 练习 23：更多字符串比较

        嗯，你已经学会了不能用`==`比较字符串；你必须使用`.equals()`

        方法。但我认为你终于准备好看看我们如何比较字符串的字母顺序了。

        ```java
        1 import java.util.Scanner; 2
        3 public class DictionaryOrder 4 {
        5   public static void main( String[] args ) 6   {
        7    Scanner keyboard = new Scanner(System.in); 8
        9    String name; 10
        ```

        1.  ```java
            System.out.print( "Give me the name of a made­up programming language: " );
            ```

        1.  ```java
            name = keyboard.nextLine(); 13
            ```

        1.  ```java
            if ( name.compareTo("c++") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE c++" );
            ```

        1.  ```java
            if ( name.compareTo("c++") == 0 )
            ```

        1.  ```java
            System.out.println( "c++ isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("c++") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER c++" ); 20
            ```

        1.  ```java
            if ( name.compareTo("go") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE go" );
            ```

        1.  ```java
            if ( name.compareTo("go") == 0 )
            ```

        1.  ```java
            System.out.println( "go isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("go") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER go" ); 27
            ```

        1.  ```java
            if ( name.compareTo("java") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE java" );
            ```

        1.  ```java
            if ( name.compareTo("java") == 0 )
            ```

        1.  ```java
            System.out.println( "java isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("java") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER java" ); 34
            ```

        1.  ```java
            if ( name.compareTo("lisp") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE lisp" );
            ```

        1.  ```java
            if ( name.compareTo("lisp") == 0 )
            ```

        1.  ```java
            System.out.println( "lisp isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("lisp") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER lisp" ); 41
            ```

        1.  ```java
            if ( name.compareTo("python") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE python" );
            ```

        1.  ```java
            if ( name.compareTo("python") == 0 )
            ```

        1.  ```java
            System.out.println( "python isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("python") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER python" ); 48
            ```

        1.  ```java
            if ( name.compareTo("ruby") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE ruby" );
            ```

        1.  ```java
            if ( name.compareTo("ruby") == 0 )
            ```

        1.  ```java
            System.out.println( "ruby isn't a made­up language!" );
            ```

        1.  ```java
            if ( name.compareTo("ruby") > 0 )
            ```

        1.  ```java
            System.out.println( name + " comes AFTER ruby" ); 55
            ```

        1.  ```java
            if ( name.compareTo("visualbasic") < 0 )
            ```

        1.  ```java
            System.out.println( name + " comes BEFORE visualbasic" );
            ```

        1.  ```java
            if ( name.compareTo("visualbasic") == 0 )
            ```

        ```java

        59
        60
        61
        62
        63 }
        ```

        ```java
        System.out.println( "visualbasic isn't a made­up language!" ); if ( name.compareTo("visualbasic") > 0 )
        System.out.println( name + " comes AFTER visualbasic" );
        ```

        ```java
        }
        ```

        ### 你应该看到什么

        ```java

        Give me the name of a made­up programming language: juniper juniper comes AFTER c++
        juniper comes AFTER go juniper comes AFTER java juniper comes BEFORE lisp juniper comes BEFORE python juniper comes BEFORE ruby
        juniper comes BEFORE visualbasic
        ```

        （当然，我忍不住在第 12 行插入了一些东西。而不是使用 Scanner 对象的

        `.next()`方法读取一个字符串，我使用 Scanner 对象的`.nextLine()`方法读取一个字符串。不同之处在于`.next()`会在你输入空格时停止读取，所以如果你输入`"visual` `basic"`，它只会读取`"visual"`，并留下其余的部分。当你使用`.nextLine()`时，它会读取你输入的所有内容，包括空格和制表符，直到你按下回车键，然后将所有内容放入一个长字符串中并将其存储到变量中。

        你可以使用 String 对象的`.compareTo()`方法将字符串相互比较。这个

        `.compareTo()`方法的工作方式并不是你可能期望的，但它的工作方式是有巧妙之处的。

        比较涉及两个字符串。第一个字符串是`.compareTo()`左侧的字符串。第二个字符串是括号内的字符串。比较简化为一个整数！如果我们称第一个为 self，第二个为 other，它会是这样的：

        ```java

        int n = self.compareTo(other);
        ```

        所以 self 将自己与 other 进行比较。如果 self 与 other 相同（长度相同，每个字符都相同），那么 n 将被设置为`0`。如果 self 在字母表中出现在 other 之前，那么 n 将被设置为负数（小于 0 的数）。如果 self 在字母表中出现在 other 之后，那么 n 将被设置为正数（大于 0 的数）。

        天才的部分在于：因为`.compareTo()`给我们的是一个整数，而不仅仅是一个布尔值 true 或 false，我们只需要这一个方法来进行所有的比较：小于、大于、小于或等于，等等。

        因为如果*self*等于*other*，我们会得到零，如果*self*小于*other*，我们会得到一个小于零的数字，所以我们可以写：

        ```java

        if ( self.compareTo(other) <= 0 )
        ```

        如果结果小于零，`if`语句将为真，如果结果等于零，`if`语句将为真。

        语句将为真。这有点像写

        ```java

        if ( self <= other )
        ```

        ...除了我刚刚写的那个实际上不会编译，而`.compareTo()`的技巧会。如果你问我，这很酷。

        ```java

        if ( self.compareTo(other) < 0 ) // true when self < other if ( self.compareTo(other) <= 0 ) // true when self <= other if ( self.compareTo(other) > 0 ) // true when self > other if ( self.compareTo(other) >= 0 ) // true when self >= other if ( self.compareTo(other) == 0 ) // true when self == other
        ```

        ```java
        if ( self.compareTo(other) != 0 ) // true when self != other
        ```

        这就是这个想法。对于初学者来说可能会有些困惑，使用起来稍微有些困难，但一旦你习惯了，就一点也不坏。

        这里的另一个困难（这不仅仅是一个`.compareTo()`的问题，在代码的任何地方都会发生，除非你写代码来解决它）是大小写的问题。`"Bob"`和`"bob"`不是相同的值。更糟糕的是，由于字母的 Unicode 值，`"Bob"`在字母表中出现在`"bob"`之前。如果你想避免这个问题，有很多方法，但我喜欢这两种方法中的一种：

        ```java

        if ( self.toLowerCase().compareTo( other.toLowerCase() ) < 0 ) // or if ( self.compareToIgnoreCase(other) < 0 )
        ```

        或者你可以让人类输入任何他们想要的东西，并立即将其转换为小写，然后只与你代码中的小写进行比较。

        ### 学习训练

        1. 使用你选择的方法，使这个程序即使在人类输入了“错误”的大写字母的单词时也能正确工作。

        ![image](img/Image_029.png)

1.  计算机只能在内部处理数字。字母不是数字，但有一个巨大的表，将每种语言中的每个字符映射到 1,112,063 个数字中的一个，唯一标识该字符。字母“B”的 UTF-8 Unicode 值是 66；字母“b”的值是 98。

    ## 练习 24：随机选择数字

    ```java

    1 public class RandomNumbers 2 {
    ```

    ```java
    3
    4
    5
    6
    7
    8
    9
    10
    11
    12
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24
    25
    26
    27
    28
    29
    30
    31
    32
    33
    34
    35
    36
    37
    38
    39
    40
    41
    42
    43
    44
    45
    46
    47 }
    ```

    ```java
    public static void main( String[] args )
    {
    int a, b, c; double x, y, z;
    ```

    ```java
    x = Math.random(); y = Math.random(); z = Math.random();

    System.out.println( "x is " + x ); System.out.println( "y is " + y ); System.out.println( "z is " + z );

    x = Math.random() * 100; y = Math.random() * 100; z = Math.random() * 100;

    System.out.println( "\nx is " + x ); System.out.println( "y is " + y ); System.out.println( "z is " + z );

    a = (int)x;
    b = (int)y;
    c = (int)z;

    System.out.println( "\na is " + a ); System.out.println( "b is " + b ); System.out.println( "c is " + c );

    x = 0.9999999999999999;
    a = (int)(x * 100);

    System.out.println( "\nx is " + x ); System.out.println( "a is " + a );

    x = Math.random();
    a = 0 + (int)(x*10);
    b = 1 + (int)(x*10);
    c = 5 + (int)(x*10);

    System.out.println( "\na is " + a ); System.out.println( "b is " + b ); System.out.println( "c is " + c );
    ```

    ```java
    }
    ```

    我们将在一些练习中花一些时间来学习编程书中并不总是看到的东西：如何让计算机在某个范围内选择一个“随机”数。这是因为你可以写*很多*的软件而不需要计算机随机选择一个数字。然而，有随机数将让我们制作一些简单的互动游戏，这很容易就能弥补这个略微奇怪的概念的痛苦。

    ### 你应该看到的是什么

    ```java

    x is 0.5371428668784091
    y is 0.4716636154720313
    z is 0.9791002546275134
    ```

    ```java
    x
    is
    57.33269918363617
    y
    is
    44.731436970719386
    z
    is
    75.79286027183542
    a
    is
    57
    b
    is
    44
    c
    is
    75
    x
    is
    0.9999999999999999
    a
    is
    99
    a
    is
    6
    b
    is
    7
    c
    is
    11
    ```

    注意：你的输出不会和我的一样。记住，这些数字是随机的。

    Java 有一个内置的函数叫做`Math.random()`。每次调用这个函数，它都会产生一个新的随机`double`，范围在[0,1)之间（也就是说，它可能正好是`0`，但永远不会正好是`1`，而且很可能是介于两者之间的某个值）。所以如果我写：

    ```java

    double x = Math.random();
    ```

    ...然后 x 可能有一个值为`0`，或`0.123544`，或`0.3`，或`0.999999999`，但永远不会是`1.0`，也永远不会大于 1。所以在第 8 到 10 行，函数`Math.random()`被调用了三次，并且结果被存储到三个不同的变量中。这三个值被打印出来，这样你就可以看到它们是什么。

    不幸的是，我经常不想要一个来自[0,1)的 double。想象一下一个猜数字的游戏，你说“我在想一个小数在零和一之间的数字：试着猜猜看！”这不好玩。而且我们无法控制`Math.random()`给我们的值的范围，所以我们必须自己将其压缩到一个范围内。

    在第 16 到 18 行，我们选择一个新的随机数，但在存储到变量中之前将其乘以 100。（这会使小数点向右移动两位。）因此，我们可以知道在第 20 行打印出的原始随机数是`0.5733269918363617`，因为乘以 100 后变成了`57.33269918363617`。

    请注意，乘以 100 仍然有可能得到恰好为`0`的情况。如果原始随机数是 0，那么乘以它不会改变。我们存储到变量中的数字可能是`12.3544`，或`30.0`，或`99.9999999`，但永远不会是`100.0`，也永远不会大于 100。

    在第 24 到 26 行，我们执行了所谓的“类型转换”或者“转换”。变量 x 是一个双精度浮点数：它可以保存带有小数的数字。变量 a 是一个整数：它只能保存整数。通常情况下，你不允许将`double`的值存储到`int`中。转换告诉编译器“我知道 x 是一个 double，我试图将它的值存储到一个不能保存小数的`int`中。但我不在乎。你为什么不假装 x 的值是一个整数呢？如果你不得不舍弃小数点后的所有内容，也没关系。”

    因此，在第 24 行，计算机复制了*x*的值，但小数点后的所有内容被截断并丢弃（“截断”），新的整数值存储到变量*a*中。（*x*的值不变。）这个值*不*是四舍五入的；它是被截断的。

    理论上，这给了我们什么？如果 x 最初是`0`或`12.3544`或`30.0`，或`99.9999999`，那么 a 将是`0`或`12`或`30`或`99`，但永远不会是`100`或任何大于 100 的数字。因此，a、b 和 c 的值始终为 0 到 99 的整数值。

    在第 32 和 33 行，我尝试表明从双精度浮点数到整数的转换*不*四舍五入；小数点后的数字被截断。

    最后，在第 38 到 41 行，选择一个随机数。在所有三种情况下，它都被乘以 10，然后转换为整数。这意味着转换后我们总是得到一个从 0 到 9 的数字。

    但是在第 39 行，从 0 到 9 的随机数加上`0`后存储到 a 中。（加`0`不改变数字。）

    不改变数字。）因此*a*将始终是 0 到 9 的值。

    在第 40 行，从 0 到 9 的随机数加上`1`后存储到 b 中。这使得它比原来大 1。如果原来是`0`，现在是`1`。如果原来是`6`，现在是`7`。如果原来是`9`（最大值），现在是`10`。因此，b 的值始终为 1 到 10。

    在第 41 行，从 0 到 9 的随机数加上`5`后存储到 c 中。因此，c 将始终具有 5 到 14 的值。（这仍然是十个值。）

    好了，今天就到这里吧。

    ### 学习练习

    1.  移除第 24 行的转换。尝试编译程序。你得到什么错误消息？（然后把它放回去。）

    1.  运行程序多次，并确认在第 28 到 30 行打印出的*a*、*b*和*c*始终具有 0 到 99 的值。

        1.  用手指数一数，确认如果我有一个从 0 到 9 的数字，那么我可能有十个可能的数字。将随机数乘以十并截断会得到十种可能的结果（0­9）。将随机数乘以五并截断会得到五种可能的结果（0­4）。

        1.  运行程序多次，并确认在第 43 行打印出的*a*始终具有 0 到 9 的值，*b*始终具有 1 到 10 的值，*c*始终具有 5 到 14 的值。

            ## 练习 25：更复杂的随机数

            ```java

            1 public class RandomNumbers2 2 {
            ```

            ```java
            3
            4
            5
            6
            7
            8
            9
            10
            11
            12
            13
            14
            15
            16
            17
            18
            19
            20
            21
            22
            23
            24
            25
            26
            27
            28
            29
            30
            31
            32
            33
            34
            35
            36
            37
            38
            39
            40
            41
            42 }
            ```

            ```java
            public static void main( String[] args )
            {
            int a, b, c, d, e, low, high;
            ```

            ```java
            a = 1 + (int)(Math.random()*10); b = 1 + (int)(Math.random()*10); c = 1 + (int)(Math.random()*10); d = 1 + (int)(Math.random()*10); e = 1 + (int)(Math.random()*10);
            System.out.println( a + "\t" + b + "\t" + c + "\t" + d + "\t" + e ); a = 1 + (int)(Math.random()*100);
            b = 1 + (int)(Math.random()*100);
            c = 1 + (int)(Math.random()*100); d = 1 + (int)(Math.random()*100); e = 1 + (int)(Math.random()*100);
            System.out.println( a + "\t" + b + "\t" + c + "\t" + d + "\t" + e ); a = 70 + (int)(Math.random()*31); // 31 is 100­70+1
            b = 70 + (int)(Math.random()*31); c = 70 + (int)(Math.random()*31); d = 70 + (int)(Math.random()*31); e = 70 + (int)(Math.random()*31);
            System.out.println( a + "\t" + b + "\t" + c + "\t" + d + "\t" + e ); low = 70;
            high = 100;

            a = low + (int)(Math.random()*(high­low+1)); b = low + (int)(Math.random()*(high­low+1)); c = low + (int)(Math.random()*(high­low+1)); d = low + (int)(Math.random()*(high­low+1)); e = low + (int)(Math.random()*(high­low+1));

            System.out.println( a + "\t" + b + "\t" + c + "\t" + d + "\t" + e );
            ```

            ```java
            }
            ```

            上一个练习中有一些复杂的思考，所以这个练习不会教授新的东西，而是会花更多时间来学习相同的概念。

            ### 你应该看到的

            ```java

            7
            9
            3
            3
            3
            10
            53
            78
            17
            75
            76
            96
            99
            85
            86
            99
            91
            96
            99
            83
            ```

            （再次强调，你看不到这一点。这些数字将是随机的。）

            在第 7 到 11 行，我们选择了五个随机数。每个数字都乘以 10 并转换为整数以截断它（因此每个随机数是 10 个数字之一：0 到 9）。然后对每个数字加 1，所以变量 a 到 e 每个都得到 1 到 10 的随机数。

            在第 15 到 19 行，我们再次选择了五个随机数。每个数字都乘以一

            百分之一并转换为整数以截断它（因此每个随机数是 100 个数字之一：0 到 99）。然后对每个数字加 1，所以变量 a 到 e 每个都得到 1 到 100 的随机数。

            在第 23 到 27 行，我们选择了另外五个随机数。每个数字都乘以 31 并转换为整数以截断它（因此每个随机数是 31 个数字之一：0 到 30）。然后每个数字都加上 70。`0`加上`70`得到 70。`1`加上`70`得到 71。`23`加上`70`得到 93。`30`（最大值）加上`70`得到 100。因此，变量 a 到 e 每个都得到 70 到 100 的随机数。

            因此，一般公式是这样的：

            ```java

            int a = low + (int)(Math.random() * range);
            ```

            *low*是我们想要的最小可能数字。*range*是**范围内**应该有多少个随机数。如果你知道你的最小可能数字和最大可能数字，但不知道有多少数字，那么公式是：

            ```java

            int range = high ­ low + 1;
            ```

            如果我想要的最小随机数是`1`，最大随机数是`5`，那么范围是五。5 减 1 是 4，然后加 1 来解决减法给出的两个数字之间的距离，而不是沿途停止点的计数。 8

            你甚至可以这样写公式：

            ```java

            int a = low + (int)(Math.random()*(high­low+1));
            ```

            这将使计算机从*low*到*high*中选择一个随机数。这正是我们在第 34 到 38 行所做的。

            ### 学习演习

            1.  更改第 31 行和第 32 行的*low*和*high*的值为其他值。编译并运行程序多次，以确认您总是在该范围内获得随机数。

                ![image](img/Image_032.png)

1.  编程中常见的逻辑错误是，如果您意外地计算距离而不是停止，就会发生“栅栏问题”。这个名字来自以下脑筋急转弯：如果我需要用一堆略长于一米的木板建造五米长的栅栏，我需要多少栅栏柱？你需要五块木板，但需要六根栅栏*柱*。

## 练习 26：使用 while 循环重复自己

这是我最喜欢的练习之一，因为你将学会如何使代码块*重复*。如果你能做到这一点，你就能写出各种有趣的东西。

```java

1 import java.util.Scanner; 2
3 public class EnterPIN
4 {
5
public static void main( String[] args )

6
{

7
Scanner keyboard = new Scanner(System.in);

8
int pin, entry;

9

10
pin = 12345;

11

12
System.out.println("WELCOME TO THE BANK OF JAVA.");

13
System.out.print("ENTER YOUR PIN: ");

14
entry = keyboard.nextInt();

15

16
while ( entry != pin )

17
{

18
System.out.println("\nINCORRECT PIN. TRY AGAIN.");

19
System.out.print("ENTER YOUR PIN: ");

20
entry = keyboard.nextInt();

21
}

22

23
System.out.println("\nPIN ACCEPTED. YOU NOW HAVE ACCESS
TO YOUR
ACCOUNT."); 24  }
25 }

```

### 你应该看到的是

```java

WELCOME TO THE BANK OF JAVA. ENTER YOUR PIN: 123

INCORRECT PIN. TRY AGAIN. ENTER YOUR PIN: 1234

INCORRECT PIN. TRY AGAIN. ENTER YOUR PIN: 12345

PIN ACCEPTED. YOU NOW HAVE ACCESS TO YOUR ACCOUNT.
```

在第 16 行，您首次看到`while`循环。`while`循环类似于`if`语句。它们都有括号中的条件，用于检查其真假。如果条件为假，则`while`循环和`if`语句都将跳过主体中的所有代码。当条件为真时，`while`循环和`if`语句都将执行其主体中的所有代码一次。

唯一的区别是，`if`语句为真时将执行大括号中的所有代码一次。`while`循环为真时将执行大括号中的所有代码一次，然后返回并再次检查条件。如果条件仍然为真，则再次执行主体中的所有代码。然后再次检查条件，如果条件仍然为真，则再次运行主体。

实际上，你可以说`while`循环会执行其主体中的所有代码，只要在检查时条件为真。

最终，当检查条件时，条件将为假。然后`while`循环将跳过其主体中的所有代码，程序的其余部分将继续。一旦`while`循环的条件为假，它就不会再次被检查。

循环是如此伟大，因为我们终于可以做一些事情不止一次，而不必多次输入代码！事实上，程序员有时会说“保持你的代码 DRY：不要重复自己。”一旦你学会了编程并完成了本书中的所有练习，如果你发现自己在程序中多次输入（或复制粘贴）完全相同的代码，你会开始怀疑。

## 练习 27：一个猜数字游戏

现在你知道如何使用`while`循环重复某些内容，我们将编写一个实际上另一个人可能会喜欢运行的程序？你对此和我一样兴奋吗？

```java

1 import java.util.Scanner; 2
3 public class HighLow 4 {
5   public static void main( String[] args ) 6   {
```

1.  ```java
    Scanner keyboard = new Scanner(System.in);
    ```

1.  ```java
    int secret, guess; 9
    10    secret = 1 + (int)(Math.random()*100); 11
    ```

    1.  ```java
        System.out.println( "I'm thinking of a number between 1­100\. Try to guess it." );
        ```

    1.  ```java
        System.out.print( "> " );
        ```

    1.  ```java
        guess = keyboard.nextInt(); 15
        ```

    ```java
    16    while ( secret != guess )
    17    {
    18      if ( guess < secret )
    19      {
    20        System.out.println( "Sorry, your guess is too low. Try again."
    );
    21      }
    22      if ( guess > secret )
    23      {
    24        System.out.println( "Sorry, your guess is too high. Try again." );
    25      }
    ```

    1.  ```java
        System.out.print( "> " );
        ```

    1.  ```java
        guess = keyboard.nextInt(); 28    }
        ```

    ```java
    29
    30    System.out.println( "You guessed it! What are the odds?!?" ); 31   }
    32 }

    ```

    ### 你应该看到的是

    ```java

    I'm thinking of a number between 1­100\. Try to guess it.
    > 50
    Sorry, your guess is too high. Try again.
    > 25
    Sorry, your guess is too high. Try again.
    > 13
    Sorry, your guess is too low. Try again.
    > 20
    Sorry, your guess is too high. Try again.
    > 16
    Sorry, your guess is too high. Try again.
    > 18
    Sorry, your guess is too high. Try again.
    > 14
    Sorry, your guess is too low. Try again.
    > 15
    You guessed it! What are the odds?!?
    ```

    所以在第 10 行，计算机从 1 到 100 中选择一个随机数，并将其存储到变量*secret*中。我们让人类猜测。

    第 16 行有一个`while`循环。它说“只要变量 secret 的值与变量 guess 的值不同...运行以下代码块。”第 17 行到第 28 行是循环的主体。每当条件为真时，这十二行代码都会被执行。

    在循环体内，我们有几个`if`语句。我们已经知道人类的猜测与秘密数字不同，否则我们就不会一开始就进入`while`循环！但我们不知道猜测是错误是因为它太低还是因为它太高，所以这些`if`语句找出来并显示适当的错误消息。

    然后在显示错误消息后，第 27 行我们允许他们再次猜测。人类（希望）输入一个数字，然后存储到变量*guess*中，覆盖该变量中的先前猜测。

    然后程序循环回到第 16 行并再次检查条件。如果条件仍然为真（他们的猜测仍然不等于秘密数字），则整个循环体将再次执行。如果条件现在为假（他们猜中了），则整个循环体将被跳过，程序将跳到第 29 行。

    如果循环结束，我们知道条件为假。所以我们不需要在这里加一个新的`if`语句；安全地打印“你猜对了”。

    ## 练习 28：无限循环

    ```java

    1 import java.util.Scanner; 2
    3 public class KeepGuessing 4 {
    ```

    ```java
    5
    6
    7
    8
    9
    10
    11
    12
    ```

    ```java
    public static void main( String[] args )
    {
    Scanner keyboard = new Scanner(System.in); int secret, guess;
    ```

    ```java
    secret = 1 + (int)(Math.random()*10);

    System.out.println( "I have chosen a number between 1 and 10\. Try to guess it." );
    13
    14
    15
    16
    17
    18
    19
    20
    21
    22
    23
    24 }
    ```

    ```java
    System.out.print( "Your guess: " ); guess = keyboard.nextInt();
    ```

    ```java
    while ( secret != guess )
    {
    System.out.println( "That is incorrect. Guess again." ); System.out.print( "Your guess: " );
    }

    System.out.println( "That's right! You're a good guesser." );
    ```

    ```java
    }
    ```

    有时让学生感到惊讶的是，制作一个重复“永远”的循环是多么容易。这些被称为“无限循环”，有时我们故意制造它们，但通常它们是逻辑错误的结果。这里有一个例子：

    ### 你应该看到的是

    ```java

    I have chosen a number between 1 and 10\. Try to guess it. Your guess: 4
    That is incorrect. Guess again.
    Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again.
    ```

    ![image](img/Image_036.png)

1.  例如，在大学时，我在网络协议课上的一个作业是写一个网络服务器。网络服务器监听网络以获取页面请求。然后它找到请求的页面并将其发送到请求的网络浏览器。然后它等待另一个请求。我在那个作业中故意使用了一个无限循环，因为网络服务器软件旨在在机器启动时自动启动，全天候运行，并且只在机器关闭时关闭。

    ```java
    Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: That is incorrect. Guess again. Your guess: ^C
    ```

    程序实际上没有自行停止；在程序一遍又一遍地重复时，我不得不按下 CTRL-C 来停止它。

    这段代码中有一个无限循环。第 16 行检查变量*secret*的值是否与变量*guess*的值不同。如果是，它执行循环体，如果不是，它跳过循环体到第 21 行。

    问题是一旦*secret*和*guess*不同，程序就永远无法到达另一行代码来改变任一变量，所以循环将永远重复第 16 行到第 20 行。

    所以当你写一个 while 循环的条件时，试着记住：“我需要确保这个条件最终会变成假”。

    ### 学习练习

    1.  修复代码，使其不再产生无限循环。

## 练习 29：使用循环进行错误检查

到目前为止，在这本书中，我们大多数时间都在忽略错误检查。我们假设人类会遵循指示，如果他们的缺乏方向性导致我们的程序出错，我们只是责怪用户，不予理会。

当你只是在学习时，这是完全可以的。错误检查很难，这就是为什么大多数大型程序都有错误，并且需要一整群人非常努力地工作，以确保软件尽可能少地出现错误。

```java

1 import java.util.Scanner; 2
3 public class SafeSquareRoot 4 {
```

```java
5
6
7
8
9
10
```

```java
public static void main( String[] args )
{
Scanner keyboard = new Scanner(System.in); double x, y;
```

```java
System.out.print("Give me a number, and I shall find the square root
```

```java
of it. "); 11
12
13
14
15
16
```

```java
System.out.print("(No negatives, please.) "); x = keyboard.nextDouble();
```

```java
while ( x < 0 )
{
System.out.print("Sorry, I won't take the square root of a negative.\nNew number: ");
```

```java
17
18
19
20
21
22
23
24 }
```

```java
x = keyboard.nextDouble();
```

```java
}
```

```java
y = Math.sqrt(x);

System.out.println("The square root of "+x+" is "+y);
```

```java
}
```

但是你终于到了能够编写一点错误检查的程度。

### 你应该看到的

```java

Give me a number, and I shall find the square root of it. (No negatives, please.)
­8
Sorry, I won't take the square root of a negative. New number: ­7
Sorry, I won't take the square root of a negative. New number: ­200
Sorry, I won't take the square root of a negative. New number: 5
The square root of 5.0 is 2.23606797749979
```

从第 14 行开始是我所说的“输入保护循环”的一个例子。在第 20 行，我们将对变量 x 中的任何值取平方根，并且在这样做之前，我们希望确保它包含一个正数。（Java 没有内置支持虚数。）我们可以使用内置的绝对值函数`Math.abs()`，但我想演示错误检查，好吗？

在第 12 行，我们让人类输入一个数字。我们已经很客气地要求他们只输入一个正数，但他们可以输入任何他们喜欢的东西。（他们甚至可以输入“Mister Mxyzptlk”，但我们的错误检查技能还不够先进，无法幸存下来。）

所以在第 14 行，我们检查他们是否遵守了指示。如果*x*中的值为负数（小于零），我们会打印出一个错误消息，让他们再试一次。然后，在他们输入新数字之后，我们*回到*第 14 行，检查条件是否仍然为真。他们是否仍然没有遵循指示？如果是，再次显示错误消息并给他们另一个机会。

计算机不会不耐烦或无聊，所以人类**被困**在这个循环中，直到他们遵守。他们可以输入负数两十亿次，每次计算机都会礼貌地抱怨并让他们重新输入。

最终，人类会变得聪明，输入一个非负数。然后`while`循环的条件将为假（终于），循环的主体将被跳过（终于），执行将在第 20 行继续，我们可以安全地计算一个我们知道是正数的数的平方根。

真正的程序到处都有这样的东西。你必须这样做，因为人类不可靠，经常做出意想不到的事情。当你的孩子在程序运行时拉起笔记本电脑并开始乱按键时会发生什么？我们希望程序不会崩溃。

哦，你有没有注意到？我在这个程序中改变了一些东西。到目前为止，我在这本书中每次在屏幕上打印东西时，我都在括号和引号之间放了一个空格，就像这样：

```java

System.out.println( "This is a test." );
```

我这样做是因为我想要清楚地表明引号内的东西（技术上称为“字符串文字”）是一回事，而括号是另一回事。但是 Java 实际上并不在乎这些空格。（记住我充满了谎言。）如果你去掉空格，你的程序仍然会编译并且工作得和原来一样：

```java

System.out.println("This is a test.");
```

你可能已经注意到，在第 22 行，我甚至省略了字符串文字和加号之间的空格。这样的间距不会影响 Java 程序的语法，尽管许多公司和其他软件编写团体都有“样式指南”，告诉你如果你想让团体的其他成员满意，应该以什么样的方式格式化你的代码。

有些人对此非常激动。他们认为你应该始终使用空格来缩进你的代码，或者始终将代码块的开放大括号放在上一行的末尾：

```java

if ( age < 16 ) { allowed = false;
}
```

…就像那样。我认为对于你自己的代码，你应该尝试其他风格，并做让你快乐的事情。当你和其他人一起工作时，你应该以让他们满意的方式格式化代码。

甚至有一些工具可以自动更改代码的格式以适应特定的风格！（搜索“源代码美化器”或“Java 代码美化器”来看一些例子。）

### 学习方法

1. 不要使用输入保护循环，使用`if`语句和`Math.abs()`来处理负数的平方根。当数字为负时，取正数的平方根，并在答案旁边打印一个小的`"i"`。

## 练习 30：Do-While 循环

在这个练习中，我要做一些我通常不做的事情。我要向你展示在 Java 中制作循环的另一种方法。因为你只看了四个练习的`while`循环，向你展示一种不同类型的循环可能会让你感到困惑。通常我喜欢等到学生做了很长时间的事情后再向他们展示做同样事情的新方法。

所以如果你认为你会感到困惑，随时可以跳过这个练习。这几乎不会伤害你，你可以在更有信心的时候再回来。

无论如何，在 Java 中有几种制作循环的方法。除了`while`循环之外，还有 do-while 循环。它们几乎相同，因为它们都在括号中检查条件。如果条件为真，则执行循环体。如果条件为假，则跳过循环体（或停止循环）。

那么有什么区别呢？输入代码，然后我们再谈论它。

```java

1 import java.util.Scanner; 2
3 public class CoinFlip
4 {
5

public static void main( String[] args )
6

{
7

Scanner keyboard = new Scanner(System.in);
8

9

String coin, again;
10

int flip, streak = 0;
11

12

do
13

{
14

flip = 1 + (int)(Math.random()*2);
15

16

if ( flip == 1 )
17

coin = "HEADS";
18

else
19

coin = "TAILS";
20

21

System.out.println( "You flip a coin and it is... " + coin );
22

23

if ( flip == 1 )
24

{
25

streak++;
26

System.out.println( "\tThat's " + streak + " in a row...." );
27

System.out.print( "\tWould you like to flip again (y/n)? " );
28

again = keyboard.next();
29

}
30

else
31

{
32

streak = 0;
33

again = "n";
34

}
35

} while ( again.equals("y") );
36

37

System.out.println( "Final score: " + streak );
38

}
39
}

```

### 你应该看到什么

```java
You flip a coin and it is... HEADS That's 1 in a row....
Would you like to flip again (y/n)? y You flip a coin and it is.  HEADS
That's 2 in a row....
Would you like to flip again (y/n)? y You flip a coin and it is.  HEADS
That's 3 in a row....
Would you like to flip again (y/n)? n Final score: 3
```

`while`循环和 do-while 循环之间只有两个区别。

1.  `while`循环的条件在循环体之前，但是 do-while 循环在循环体之前有关键字`do`，条件在循环体结束后，紧跟着右花括号。 （并且在循环条件的右括号后有一个分号，而`while`循环没有。）

1.  `while`循环在进入循环体之前检查它们的条件，但是 do-while 循环无论如何都会运行一次循环体，并且只在第一次通过后检查条件。

在计算机科学领域，`while`循环被称为“前测试”循环（因为它首先检查条件），而 do-while 被称为“后测试”循环（因为它在之后检查条件）。

如果`while`循环的条件在第一次检查时为真，那么使用`while`循环的代码和使用 do-while 循环的等效代码将表现完全相同。任何你可以用`while`循环做的事情，你也可以用 do-while 循环（和稍微不同的代码）做，反之亦然。

那么为什么 Java 的开发者要费心制作 do-while 循环呢？因为有时你在条件中检查的是一些在至少执行一次循环体后才知道的东西。

在这种情况下，我们通过选择 1-2 之间的随机数来抛硬币，并使用`if`语句。然后我们问他们是否想再抛一次或停止。如果他们说想再抛一次，我们的循环条件会重复。

如果我们用`while`循环来做这个，条件会是这样的：

```java

while ( again.equals("y") )
{
```

这是可以的，也可以工作，但是变量*again*直到第 28 行才得到一个值。所以我们的代码不会编译，因为*again*（用 Java 编译器的话）“可能尚未初始化”。所以我们必须在循环之前给它一个没有意义的值，只是为了取悦编译器。

这很烦人，所以 do-while 循环允许我们保持条件不变，但等到最后再检查它。这很方便。

### 学习训练

1.  更改代码，使用`while`循环代替 do-while 循环。确保它能编译并且运行结果相同。

1.  将它改回 do-while 循环。（当你忘记如何编写 do-while 循环时，你可能会回头看这段代码，我们不希望你唯一的例子被改成`while`循环。）

## 练习 31：逐个添加值

这个练习将演示一件你必须经常做的事情：处理一次只得到一个值。

如果我让你让人类输入三个数字并将它们相加，并且我保证他们只需要输入确切的三个数字（不多，不少），你可能会写出这样的东西：

```java

int a, b, c, total;
a = keyboard.nextInt(); b = keyboard.nextInt(); c = keyboard.nextInt(); total = a + b + c;
```

如果我告诉你人类要输入*五*个数字，你的代码可能是这样的：

```java

double num1, num2, num3, num4, num5, total; num1 = keyboard.nextDouble();
num2 = keyboard.nextDouble(); num3 = keyboard.nextDouble(); num4 = keyboard.nextDouble(); num5 = keyboard.nextDouble(); total = num1+num2+num3+num4+num5;
```

但是，如果我告诉你他们想要输入一百个数字呢？或者一万个？或者*可能*是三个，*可能*是五个，我不确定？那么你需要另一种方法。你需要一个循环（这就是我们重复事情的方式），并且你需要一个变量，它将随着值的逐个添加而逐渐增加。一个从“空白”开始并逐个添加值的变量称为“累加器”变量，尽管这是一个相当古老的词，所以如果你的编程朋友年龄不到四十岁，他们可能从未听说过。

无论如何，基本想法看起来是这样的：

```java

1 import java.util.Scanner; 2
3 public class RunningTotal
4 {
5

public static void main( String[] args )
6

{
7

Scanner keyboard = new Scanner(System.in);
8

9

int current, total = 0;
10

11

System.out.print("Type in a bunch of values and I'll add them up. ");
12

System.out.println("I'll stop when you type a zero.");
13

14

do
15

{
16

System.out.print("Value: ");
17

current = keyboard.nextInt();
18

int newtotal = current + total;
19

total = newtotal;
20

System.out.println("The total so far is: " + total);
21

} while ( current != 0 );
22

23

System.out.println("The final total is: " + total);
24

}
25
}

```

### 你应该看到的是

```java

Type in a bunch of values and I'll add them up. I'll stop when you type a zero. Value: 3
The total so far is: 3 Value: 4
The total so far is: 7 Value: 5
The total so far is: 12 Value: 6
The total so far is: 18 Value: 0
The total so far is: 18 The final total is: 18
```

我们需要两个变量：一个用于保存他们刚刚输入的值（*current*），一个用于保存运行总数（嗯...*total*）。在第 9 行，我们确保首先将零放入*total*中。很快你就会明白为什么。

在第 17 行，人类可以输入一个数字。这是在 do-while 循环的主体内，无论如何都会运行至少一次，所以这段代码总是会发生。假设他们一开始输入`3`。

在第 18 行，魔法的第一部分发生了。我们声明了一个名为*newtotal*的新变量，并将其值设置为人类刚刚输入的数字加上*变量*total 中已经存在的值。一开始*total*中有一个零，所以这行代码将零添加到*current*中，并将该数字存储到*newtotal*中。

然后在第 19 行，魔法的第二部分发生了：我们用 newtotal 的当前值替换 total 中的值（零）。所以现在 total 不再是零；它具有与 current 相同的值。所以 total 是`0`，现在是`3`。

然后我们打印小计，并在第 21 行检查*current*是否为零。如果不是，则循环重复到第 14 行。

人类可以输入第二个数字。假设是`4`。变量 newtotal 被初始化为

current（`4`）加上 total（`3`），所以 newtotal 是`7`。然后在第 19 行，我们将 total 的值更改为`7`。

条件再次被检查，过程继续。最终，人类输入了一个`0`，那个`0`被添加到总数中（这不会伤害它），条件变为假，所以 do-while 循环停止循环。

在练习结束之前，我应该提到两件事：

1.  因为变量*newtotal*在第 18 行被声明（并定义），所以该变量的范围仅限于 do-while 循环的主体。这意味着在第 21 行，*newtotal*不再在范围内，因此在 do-while 循环的条件中引用*newtotal*的任何尝试都会导致错误。该变量在每次循环中不断创建和销毁。这有点低效。

1.  我们甚至可以编写代码而不使用*newtotal*变量。由于 Java 在将右侧的最终值存储到左侧命名的变量之前，我们可以将第 18 行和第 19 行合并为一行：

    ```java

    total = current + total;
    ```

    这个工作完全正常。（事实上，你以前见过它。）

    ### 学习训练

    1.  重写代码，使用`while`循环而不是 do-while 循环。确保它能够编译并确保它仍然有效。然后改回来。

    1.  更改 do-while 循环的条件，使得当*newtotal*恰好为 20 时循环停止。

哦？它不编译，因为*newtotal*超出了范围？更改*newtotal*声明的位置，使其正常工作。

## 练习 32：为骰子游戏添加值

Pig 是一个简单的骰子游戏，适用于两个或更多玩家。（如果您想了解更多信息，可以阅读维基百科关于 Pig 的条目。）基本思想是成为第一个“存入”100 分的人。当您掷出 1 时，您的回合结束，这一回合您不会获得任何分数。任何其他掷骰都会增加您这一回合的分数，但只有在您决定“保留”时才能保留这些分数。如果在保留之前掷出 1，那么您这一回合的所有分数都将丢失。

1 导入 java.util.Scanner; 2

3 public class PigDiceComputer 4 {

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

public static void main(String[] args)

{

Scanner keyboard = new Scanner(System.in);

int roll, total;

total = 0;

做

{

roll = 1 + (int)(Math.random()*6);

System.out.println("计算机掷出了" + roll + "。"); if (roll == 1)

{

System.out.println("\t 这结束了它的回合。"); total = 0;

}

else

{

total += roll;

System.out.println("\t 计算机到目前为止获得了" + total + "分。");

回合。"); 26

27

28

29

30

31

32

33

34

如果（总数<20）

{

System.out.println("\t 计算机选择再次掷骰。");

}

}

} while (roll != 1 && total < 20);

System.out.println("计算机以" + total + "分结束本轮。");

35 }

36 }

您已经掌握了整个 Pig 游戏的代码，但与您之前看到的较小程序相比，这是一次性的*很多*，所以我将把它分成两节课。今天我们只会为计算机玩家编写人工智能（A.I.）代码。这个计算机玩家将使用“在 20 时保留”策略，这意味着计算机会继续掷骰，直到他们这一回合的分数达到 20 或更多，然后无论如何都会保留。这实际上并不是一个糟糕的策略，而且编码起来也很容易。

### 预期输出

```java

Computer rolled a 2.
Computer has 2 points so far this round. Computer chooses to roll again.
Computer rolled a 3.
Computer has 5 points so far this round. Computer chooses to roll again.
Computer rolled a 1.
That ends its turn.
Computer ends the round with 0 points.
```

基本上整个程序都在一个大的 do-while 循环体中，告诉计算机何时停止：要么掷出 1，要么总数达到 20 或更多。只要掷骰不是 1 *并且*总数小于 20，条件就会成立，循环将从开始重新开始（在第 13 行）。我们选择 do-while 循环是因为我们希望计算机无论如何都至少掷一次骰子。

掷骰发生在第 15 行：从 1 到 6 的随机数字是掷骰的良好替代品。

在第 17 行，我们检查是否掷出了 1。如果是，所有分数都将丢失。如果不是（`else`），我们将此次掷骰的分数加到总分上。请注意我们使用了“加等于”，这是我们以前见过的。

第 26 行的`if`语句只是为了得到一个漂亮的消息，即计算机将再次掷骰。不错，对吧？所以下一课我们将回来玩完整的游戏！

### 学习练习

1. 找到一个骰子（技术上应该是“骰子”，因为“骰子”是复数形式，而您只需要一个）或找到一个模拟掷骰子的应用程序或网站。拿出一张纸和一支笔。在纸张中间画一条线并制作两列。在左列上标注“掷骰”，在右列上标注“总数”。在总数列中放入`0`，并一开始将另一列留空。

然后掷骰子，并将您掷出的数字写在掷骰列的顶部。由于骰子掷出的行号是代码中的第 15 行，所以在掷骰值旁边用括号括起数字`(15)`。

然后逐行执行代码，就像计算机一样。将掷骰的当前值与 1 进行比较。如果它们相等，则划掉总数列中的当前值，并在那里放入`0 (20)`，因为总数将在代码的第 20 行变为零。

继续进行，直到程序结束。以下是程序“预期输出”部分所示程序示例运行的表格样式示例。

掷骰

总数

0 (11)

2 (15)

2 (24)

3 (15)

5 (24)

1 (15)

0 (20)

## 练习 33：名为“Pig”的骰子游戏

在上一课中，我们为骰子游戏*Pig*编写了计算机 A.I.（记住，如果你想要更多关于这个游戏的信息，你可以阅读维基百科关于 Pig 的条目。）在这一课中，我们将有整个游戏的代码，有一个人类玩家和一个计算机玩家轮流进行。

你上次写的整个程序大致对应于这个程序中的第 43 到 67 行。唯一的主要区别是，我们将有一个*turnTotal*变量来保存一个回合的点数，而*total2*变量则保存计算机从一轮到另一轮的总点数。

1 import java.util.Scanner; 2

3 public class PigDice 4 {

5 public static void main( String[] args ) 6 {

7 Scanner keyboard = new Scanner(System.in); 8

1.  int roll, total1, total2, turnTotal;

1.  String choice = ""; 11

1.  total1 = 0;

1.  total2 = 0; 14

15 do

16 {

1.  turnTotal = 0;

1.  System.out.println( "你有 " + total1 + " 点。" ); 19

20 do

21 {

1.  roll = 1 + (int)(Math.random()*6);

1.  System.out.println( "\t 你掷出了 " + roll + "。" );

1.  if ( roll == 1 )

25 {

1.  System.out.println( "\t 这结束了你的回合。" );

1.  turnTotal = 0;

28 }

29 else

30 {

1.  turnTotal += roll;

1.  System.out.println( "\t 你这一轮到目前为止有 " + turnTotal + " 点。" );

1.  System.out.print( "\t 你想再“roll”一次还是“hold”？ " );

1.  choice = keyboard.next(); 35 }

36 } while ( roll != 1 && choice.equals("roll") ); 37

1.  total1 += turnTotal;

1.  System.out.println( "\t 你以 " + total1 + " 点结束这一轮。" ); 40

41 if ( total1 < 100 )

42 {

1.  turnTotal = 0;

1.  System.out.println( "计算机有 " + total2 + " 点。" ); 45

46 do

47 {

1.  roll = 1 + (int)(Math.random()*6);

1.  System.out.println( "\t 计算机掷出了 " + roll + "。" );

1.  if ( roll == 1 )

51 {

1.  System.out.println( "\t 这结束了它的回合。" );

1.  turnTotal = 0;

54 }

55 else

56 {

1.  turnTotal += roll;

1.  System.out.println( "\t 计算机到目前为止这一轮有 " + turnTotal + " 点。" );

1.  if ( turnTotal < 20 )

60 {

61 System.out.println( "\t 计算机选择再次掷骰子。" ); 62 }

63 }

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82 }

} while ( roll != 1 && turnTotal < 20 );

total2 += turnTotal;

System.out.println( "\t 计算机以 " + total2 + " 点结束这一轮。" );

}

} while ( total1 < 100 && total2 < 100 );

if ( total1 > total2 )

{

System.out.println( "人类获胜！" );

}

else

{

System.out.println( "计算机获胜。" );

}

}

### 你应该看到的是

```java

You have 0 points.
You rolled a 2.
You have 2 points so far this round.
Would you like to "roll" again or "hold"? roll You rolled a 1.
That ends your turn.
You end the round with 0 points.
Computer has 0 points.
Computer rolled a 6.
Computer has 6 points so far this round. Computer chooses to roll again.
Computer rolled a 6.
Computer has 12 points so far this round. Computer chooses to roll again.
Computer rolled a 1\. That ends its turn.
Computer ends the round with 0 points.
You have 0 points.
You rolled a 3.
You have 3 points so far this round.
Would you like to "roll" again or "hold"? roll You rolled a 5.
You have 8 points so far this round.
Would you like to "roll" again or "hold"? roll You rolled a 2.
You have 10 points so far this round.
Would you like to "roll" again or "hold"? roll You rolled a 2.
You have 12 points so far this round.
Would you like to "roll" again or "hold"? hold You end the round with 12 points.
Computer has 0 points.
Computer rolled a 5.
Computer has 5 points so far this round. Computer chooses to roll again.
Computer rolled a 4.
Computer has 9 points so far this round. Computer chooses to roll again.
Computer rolled a 4.
Computer has 13 points so far this round. Computer chooses to roll again.
Computer rolled a 3.
Computer has 16 points so far this round. Computer chooses to roll again.
Computer rolled a 5.
Computer has 21 points so far this round.
```

```java
Computer ends the round with 21 points.
You have 12 points.
You rolled a 2.
You have 2 points so far this round.
Would you like to "roll" again or "hold"? roll

...etc

Computer has 20 points so far this round. Computer ends the round with 102 points.
The computer wins.
```

我们从两个变量开始程序：*total1*保存人类的总点数，*total2*保存计算机的总点数。两者都从 0 开始。

然后在第 15 行开始一个非常庞大的 do-while 循环，基本上包含了整个游戏，直到第 70 行才结束。向下滚动，你会看到这个循环会重复，只要*total1*和*total2*都小于 100。当任一玩家达到 100 或更多时，条件不再成立，do-while 循环不会再重复。

然后在那个 do-while 循环结束之后（从第 72 行开始），有一个`if`语句和一个`else`来确定赢家。

让我们往上滚动一下，看看人类的回合，从第 17 行开始。*turnTotal*是人类到目前为止在这一轮中赚得的点数。由于这是一轮的开始，我们应该从 0 开始。

第 20 行是一个包含人类回合的 do-while 循环的开始。它在第 36 行结束，所有在第 20 行和第 36 行之间的代码都会重复，只要人类没有掷出 1，只要人类继续选择再次掷骰子。

人类的每次掷骰子都和计算机一样开始：选择一个从 1 到 6 的随机数。我们在第 22 行打印出来。

现在可能发生两件事：要么掷骰子是 1——人类失去本轮获得的所有分数——要么掷骰子是 2-6，然后将掷骰子的点数加到他们的*turnTotal*上。我们显示适当的消息，在第 33 和 34 行，我们给人类选择再次掷骰的机会，或者通过保持来安全地玩。然后在第 36 行，do-while 循环的条件将检查并在适当的情况下重复回到第 20 行。

一旦玩家的回合结束，我们将*turnTotal*（可能为 0）加到玩家的总分上，并显示他们当前的分数。

在第 41 行，计算机的回合开始了。然而，如果人类已经达到了 100 分，计算机就不会轮到了：在这种情况下游戏结束。因此，为了防止计算机玩游戏，我们必须将整个计算机的回合包装在一个大的`if`语句中，以便在人类的总分（total1）大于或等于 100 时跳过。这个`if`语句从第 41 行开始，到第 68 行结束。

所以在第 43 行，计算机的回合真正开始了。这基本上与上一个练习相同，所以我不会再解释一遍。请注意，计算机正在根据其回合总数决定是否继续掷骰子。

第 70 行结束了包含整个游戏的 do-while 循环，第 72 到 79 行确定并显示赢家。

希望你能够很好地跟上游戏的流程。这相当复杂。

我还要指出，对于这样一个程序来说，每次你放一个左大括号，将其后的所有内容缩进一级是*非常重要*的。如果你可以从第 47 行的左大括号直观地扫描你的眼睛到第 64 行的右大括号，看看 do-while 循环中有什么，没有什么，这将为你节省很多烦恼。

## 练习 34：调用一个函数

上一个练习相当复杂。所以我们今天的练习会放松一下。我们将学习如何在 Java 中编写“函数”，以及如何通过“调用”来执行它。10

```java

1 public class ThereAndBackAgain 2 {
3

public static void main( String[] args )
4

{
5

System.out.println( "Here." );
6

erebor();
7

System.out.println( "Back first time." );
8

erebor();
9

System.out.println( "Back second time." );
10

}
11

12

public static void erebor()
13

{
14

System.out.println( "There." );
15

}
16
}

```

### 你应该看到什么

```java

Here.
There.
Back first time.
There.
Back second time.
```

因此，第 5 到 9 行相当无聊，除了在第 6 和第 8 行我们提到了一些叫做“erebor”的东西，你在 Java 中以前没有见过。你知道为什么你没有见过它吗？因为它根本不存在！

跳到第 12 到 15 行，你会注意到我在我们的程序中添加了一些不在`main()`主体内的东西。通常情况下，`public static void main`的右大括号几乎在代码的末尾，而它之后的唯一内容就是`public class` `Whatevs`的右大括号。但这次不是！

第 12 到 15 行定义了一个名为`erebor()`的函数。（`erebor()`这个词在 Java 中没有特别的含义。我们可以将其命名为`bilbo()`或`smaug()`或者任何我们喜欢的名字。）

这个函数在第 13 行有一个左大括号，就像`main()`总是有一个左大括号一样。在第 15 行是函数主体的结束，有一个右大括号。所以函数定义从第 12 行开始，到第 15 行结束。

这个函数是做什么的？它在屏幕上打印字符串`"There."`。

![image](img/Image_041.png)

10 这是我充满谎言的事情之一。从技术上讲，Java 甚至没有*函数*。它只有“方法”，这是一个方法，而不是函数。

但这只是一个方法，因为这就是 Java 所拥有的。在任何其他编程语言中，我们写的内容都会被称为函数而不是方法。这是因为方法是面向对象的东西，而这个程序根本不是面向对象的。

因此，尽管从技术上讲是不正确的，我将这种事情称为*函数*，并且只使用*方法*这个词。

当我做出的东西实际上像一个方法时。

我的故意错误的词汇只会在你与一个迂腐的 Java 程序员交谈时引起问题，因为他们可能会取笑你。如果发生这种情况，给他们看这个脚注，并问问他们教初学者编程多少年了。我保证这样做比从一开始就向你展示真正的方法，或者现在就这样做并尝试区分“像函数一样运行的方法”和“行为像真正方法的方法”要好。

那么现在让我们回到`main()`，看看`main()`体内的函数调用。

第 5 行我们在屏幕上打印字符串"Here."。然后第 6 行你会看到一个“函数调用”。这行代码告诉计算机跳到函数`erebor()`，运行该函数主体中的所有代码，然后在完成后返回到第 6 行。

所以你看到当我们调用`erebor()`函数时，字符串"There."会在字符串"Here."之后打印在屏幕上。当计算机运行第 6 行时，程序的执行在`main()`中暂停，跳过`main()`中的所有其余代码，跳到第 12 行，运行`erebor()`函数主体中的所有代码（只有 1 行），然后一旦执行到第 15 行的右花括号，它返回到第 6 行的末尾，恢复`main()`的执行。接着运行第 7 行。

第 7 行显示屏上显示另一条消息，然后第 8 行有另一个函数调用。函数 erebor 被第二次调用。它在第 8 行暂停了`main()`，跳下去运行 erebor 的主体（再次打印字符串"There."），然后返回到第 8 行，`main()`的执行继续。

最后第 9 行在屏幕上打印最后一个字符串。然后执行继续到

`main()`在第 10 行。当`main()`结束时，程序也结束。

这很重要，所以我会再说一遍：当`main()`结束时，程序也结束。即使在`class`内有很多不同的函数，程序执行也是从`main()`的第一行开始的。一旦`main()`的最后一行被执行，程序就停止运行，即使有一些从未被调用的函数。（我们将在下一个练习中看到一个例子。）

### 学习练习

1.  删除第 6 行第一个函数调用末尾的括号，使其看起来像这样：

```java

erebor;
```

编译后会发生什么？（然后把括号放回去。）

1. 删除第二个函数调用（第 8 行）。你可以直接删除整行，或者在行前加上斜杠，这样编译器会认为它是注释，就像这样：

```java
// erebor();
```

编译它，但在运行之前，你认为输出会有什么不同？运行它，看看你是否正确。

## 练习 35：调用函数绘制旗帜

现在你已经了解了如何定义函数和调用函数的绝对基础知识，让我们通过定义*十一个*函数来进行一些练习！

这个程序中没有零（`0`）。所有看起来像`O`的东西都是大写字母 O。还要注意，第 45 行和第 50 行使用的是`print()`而不是`println()`。

```java

1 import static java.lang.System.*; 2
3 public class OverlyComplexFlag
4 {
5
public static void main( String[] args )

6
{

7
printTopHalf();

8

9
print48Colons();

10
print48Ohs();

11
print48Colons();

12
print48Ohs();

13
print48Colons();

14
print48Ohs();

15
}

16

17
public static void print48Colons()

18
{

19
out.println( "|::::::::::::::::::::::::::::::::::::::::::::::::|"
);
20
}

21

22
public static void print48Ohs()

23
{

24
out.println( "|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO|"
);
25
}

26

27
public static void print29Colons()

28
{

29
out.println( "|:::::::::::::::::::::::::::::|" );

30
}

31

32
public static void printPledge()

33
{

34
out.println( "I pledge allegiance to the flag." );

35
}

36

37
public static void print29Ohs()

38
{

39
out.println( "|OOOOOOOOOOOOOOOOOOOOOOOOOOOOO|" );

40
}

41

42
public static void print6Stars()

43
{

44
out.print( "| * * * * * * " );

45
}

46

47
public static void print5Stars()

48
{

49
out.print( "|  * * * * * " );

50
}

51

52
public static void printSixStarLine()

53
{

54
print6Stars();

55
print29Ohs();

56
}

57
58
59
60
61
62
63
64
65
66
```

```java
public static void printFiveStarLine()
{
print5Stars(); print29Colons();
}
```

```java
public static void printTopHalf()
{
out.println( "  " ); //
1 space then 48 underscores
```

```java
67
68
69
70
71
72
73
74
75
76 }
```

```java
printSixStarLine(); printFiveStarLine(); printSixStarLine(); printFiveStarLine(); printSixStarLine(); printFiveStarLine(); printSixStarLine();
```

```java
}
```

```java

| * * * * * * |OOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|  * * * * * |:::::::::::::::::::::::::::::|
| * * * * * * |OOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|  * * * * * |:::::::::::::::::::::::::::::|
| * * * * * * |OOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|  * * * * * |:::::::::::::::::::::::::::::|
| * * * * * * |OOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|::::::::::::::::::::::::::::::::::::::::::::::::|
|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|::::::::::::::::::::::::::::::::::::::::::::::::|
|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
|::::::::::::::::::::::::::::::::::::::::::::::::|
|OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO|
```

### 你应该看到的

这个练习很荒谬。没有任何值得尊重的程序员会以这种方式在屏幕上绘制旗帜。如果编写这个程序感觉有点傻，那没关系。但是函数很重要，我更喜欢从你实际能理解的愚蠢例子开始，而不是从太难跟随的现实例子开始。

那么我们如何追踪执行这样的程序呢？我们从开始开始：`main()`的第一行。在第 7 行，main 做的第一件事是调用函数`printTopHalf()`。所以 main 被暂停，执行跳到`printTopHalf()`函数的第一行，即第 66 行。

`printTopHalf` 的第一件事是在屏幕上打印一堆下划线，这将是我们旗帜的顶部。之后，执行移动到第 67 行，这是另一个函数调用！所以`main()`  仍然在暂停之前，等待`printTopHalf()`  完成，现在`printTopHalf()`  本身也在暂停，等待`printSixStarLine()`  完成并返回控制权到这里。

`printSixStarLine()` 从第 54 行开始，它调用`print6Stars()`  函数。那个函数（幸运的是）只在屏幕上显示一些东西，所以当`print6Stars()`  的右大括号出现在第 45 行时，它将控制权返回到`printSixStarLine()`  的第二行（第 55 行），然后又有一个函数调用。这通过`print29Ohs()`  函数的主体运行，并返回到第 56 行。然后`printSixStarLine()`  结束，将控制权返回到第 67 行的末尾。

在这一点上，我认为解释所有的函数调用会比跟随执行路径更加混乱，所以在这里我将按顺序打印所有执行的行号。调用一个函数会增加缩进级别，从该函数返回会减少缩进级别。

```java
5 ­ begin main 6
7 ­ call printTopHalf
64 ­ begin printTopHalf 65
66
67 ­ call printSixStarLine
52 ­ begin printSixStarLine 53
54 ­ call print6Stars
42 ­ begin print6Stars 43
44
45 ­ end print6Stars
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ call print29Ohs
    ```

```java
37 ­ begin print29Ohs 38
39
40 ­ end print29Ohs
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ end printSixStarLine
    ```

```java
67 ­ resume printTopHalf
68 ­ call printFiveStarLine
58 ­ begin printFiveStarLine 59
60 ­ call print5Stars
47 ­ begin print5Stars 48
49
50 ­ end print5Stars
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ call print29Colons
    ```

```java
27 ­ begin print29Colons 28
29
30 ­ end print29Colons
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ end printFiveStarLine
    ```

1.  ```java
    ­ resume printTopHalf
    ```

1.  ```java
    ­ call printSixStarLine
    ```

```java
52 ­ begin printSixStarLine 53
54 ­ call print6Stars
42 ­ begin print6Stars 43
44
45 ­ end print6Stars
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ call print29Ohs
    ```

```java
37 ­ begin print29Ohs 38
39
40 ­ end print29Ohs
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ end printSixStarLine
    ```

```java
69 ­ resume printTopHalf
70 ­ call printFiveStarLine
58 ­ begin printFiveStarLine

59
60 ­ call print5Stars
47 ­ begin print5Stars 48
49
50 ­ end print5Stars
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ call print29Colons
    ```

```java
27 ­ begin print29Colons 28
29
30 ­ end print29Colons
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ end printFiveStarLine
    ```

1.  ```java
    ­ resume printTopHalf
    71 ­ call printSixStarLine
    52 ­ begin printSixStarLine 53
    54 ­ call print6Stars
    42 ­ begin print6Stars 43
    44
    45 ­ end print6Stars
    ```

    1.  ```java
        ­ resume printSixStarLine
        ```

    1.  ```java
        ­ call print29Ohs
        ```

    ```java
    37 ­ begin print29Ohs 38
    39
    40 ­ end print29Ohs
    ```

    1.  ```java
        ­ resume printSixStarLine
        ```

    1.  ```java
        ­ end printSixStarLine
        ```

1.  ```java
    ­ resume printTopHalf
    ```

1.  ```java
    ­ call printFiveStarLine
    ```

```java
58 ­ begin printFiveStarLine 59
60 ­ call print5Stars
47 ­ begin print5Stars 48
49
50 ­ end print5Stars
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ call print29Colons
    ```

```java
27 ­ begin print29Colons 28
29
30 ­ end print29Colons
```

1.  ```java
    ­ resume printFiveStarLine
    ```

1.  ```java
    ­ end printFiveStarLine
    ```

```java
72 ­ resume printTopHalf
73 ­ call printSixStarLine
52 ­ begin printSixStarLine 53
54 ­ call print6Stars
42 ­ begin print6Stars 43
44
45 ­ end print6Stars
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ call print29Ohs
    ```

```java
37 ­ begin print29Ohs 38
39
40 ­ end print29Ohs
```

1.  ```java
    ­ resume printSixStarLine
    ```

1.  ```java
    ­ end printSixStarLine
    ```

```java

73 ­ resume printTopHalf
74 ­ end printTopHalf
7 ­ resume main 8
9 ­ call print48Colons
17 ­ begin print48Colons 18
19
20 ­ end print48Colons
```

1.  ```java
    ­ resume main
    ```

1.  ```java
    ­ call print48Ohs
    ```

```java
22 ­ begin print48Ohs 23
24
25 ­ end print48Ohs
```

1.  ```java
    ­ resume main
    ```

1.  ```java
    ­ call print48Colons
    ```

```java
17 ­ begin print48Colons 18
19
20 ­ end print48Colons
```

1.  ```java
    ­ resume main
    ```

1.  ```java
    ­ call print48Ohs
    ```

```java
22 ­ begin print48Ohs 23
24
25 ­ end print48Ohs
```

1.  ```java
    ­ resume main
    ```

1.  ```java
    ­ call print48Colons
    ```

```java
17 ­ begin print48Colons 18
19
20 ­ end print48Colons
```

1.  ```java
    ­ resume main
    ```

1.  ```java
    ­ call print48Ohs
    ```

```java
22 ­ begin print48Ohs 23
24
25 ­ end print48Ohs
14 ­ resume main
```

天哪！如果你能成功地追踪到这一点，那么你就已经在成为一个称职的程序员的路上了。

### 学习演习

1.  你真的没有完全追踪整个程序，是吗？好吧，回去做吧。这本书不叫“学习 Java 的一半”，对吧？打印出代码，拿起一支铅笔，在一个函数调用其他地方时画一条线，当函数返回时画一条线。完成后，它应该看起来有点像一盘石墨意面！

1.  在 32 到 35 行，你会找到一个名为`printPledge()`  的函数的定义。但是这个函数的输出从来没有出现过。为什么？在`main()`  的末尾添加一个函数调用来运行这个函数，以便它出现在旗帜下面。

    （尽管这个程序很邪恶，但我对那面旗帜感到非常自豪。如果你用尺子测量一切的尺寸，你会发现我的旗帜与真正的美国国旗的尺寸几乎一样。我实际上花了很长时间测量和调整一切。）

    ## 练习 36：使用函数显示骰子

    上一个练习在一个函数实际上使事情变得更糟的程序中使用了函数。所以今天我们准备看一个情况，使用函数实际上使程序变得更好。

    Yacht 是一个古老的骰子游戏，后来被修改为商业游戏 Yahtzee。它涉及一次掷五个骰子，并为各种组合赚取积分。最罕见的组合是“游艇”，当五个骰子都显示相同的数字时。

    这个程序不做任何其他的评分，它只是掷五个骰子，直到它们都相同。（计算机速度很快，所以即使这需要很多次尝试，也不会花费很长时间。）

    ```java

    1 public class YachtDice 2 {
    3   public static void main( String[] args ) 4   {
    ```

    1.  ```java
        int roll1, roll2, roll3, roll4, roll5;
        ```

    1.  ```java
        boolean allTheSame; 7
        ```

    ```java
    8    do
    9    {
    ```

    1.  ```java
        roll1 = 1 + (int)(Math.random()*6);
        ```

    1.  ```java
        roll2 = 1 + (int)(Math.random()*6);
        ```

    1.  ```java
        roll3 = 1 + (int)(Math.random()*6);
        ```

    1.  ```java
        roll4 = 1 + (int)(Math.random()*6);
        ```

    1.  ```java
        roll5 = 1 + (int)(Math.random()*6);
        ```

    1.  ```java
        System.out.println("\nYou rolled: " + roll1 + " " + roll2 + " " + roll3 + " " + roll4 + " " + roll5);
        ```

    1.  ```java
        showDice(roll1);
        ```

    1.  ```java
        showDice(roll2);
        ```

    1.  ```java
        showDice(roll3);
        ```

    1.  ```java
        showDice(roll4);
        ```

    1.  ```java
        showDice(roll5);
        ```

    1.  ```java
        allTheSame = ( roll1 == roll2 && roll2 == roll3 && roll3 == roll4 && roll4 == roll5 );
        ```

```java
22
```

1.  ```java
    } while ( ! allTheSame );
    ```

1.  ```java
    System.out.println("The Yacht!!"); 25  }
    ```

```java
26
27   public static void showDice( int roll ) 28   {
```

1.  ```java
    System.out.println("+­­­+");
    ```

1.  ```java
    if ( roll == 1 )
    ```

```java
31    {
```

1.  ```java
    System.out.println("| |");
    ```

1.  ```java
    System.out.println("| o |");
    ```

1.  ```java
    System.out.println("| |"); 35    }
    ```

```java
36    else if ( roll == 2 )
37    {
```

1.  ```java
    System.out.println("|o |");
    ```

1.  ```java
    System.out.println("| |");
    ```

1.  ```java
    System.out.println("| o|"); 41    }
    ```

```java
42    else if ( roll == 3 )
43    {
```

1.  ```java
    System.out.println("|o |");
    ```

1.  ```java
    System.out.println("| o |");
    ```

1.  ```java
    System.out.println("| o|"); 47    }
    ```

```java
48    else if ( roll == 4 )
49    {
50
System.out.println("|o
o|");
51
System.out.println("|
|");
52
System.out.println("|o
o|");
53
}

54
else if ( roll == 5 )

55
{

56
System.out.println("|o
o|");
57

System.out.println("| o |");
58

System.out.println("|o o|");
59

}
60

else if ( roll == 6 )
61

{
62

System.out.println("|o o|");
63

System.out.println("|o o|");
64

System.out.println("|o o|");
65

}
66

System.out.println("+­­­+");
67

}

68
}

```

### 你应该看到的

```java

You rolled:
+­­­+
|o o|
| |
|o o|
+­­­+
+­­­+
|o o|
|o o|
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
|o o|
|o o|
+­­­+
4
6
5
5
6
You rolled:
+­­­+
|o |
| |
| o|
+­­­+
+­­­+
|o |
| |
| o|
+­­­+
+­­­+
|o o|
| o |
|o o|
2
2
5
6
6
+­­­+
+­­­+
|o o|
|o o|
|o o|
+­­­+
+­­­+
|o o|
|o o|
|o o|
+­­­+

...etc

You rolled: 5 5 5 5 5
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| o |
|o o|
+­­­+
The Yacht!!
```

除了第 21 行的花哨的布尔表达式之外，这个练习中有一个名为`showDice`  的单个函数。

在 10 到 14 行，我们选择五个随机数（每个数从 1 到 6）并将结果存储到五个整数变量*roll1*到*roll5*中。

我们想要使用一些`if` 语句在屏幕上显示骰子的值，但我们不想写五次相同的`if` 语句（因为变量是不同的）。解决方案是创建一个带参数的函数。

在第 27 行，你看到了`showDice`  函数定义的开始。在名称（或“标识符”）`showDice`  后面，有一组括号，在它们之间声明了一个变量！这个变量叫做“参数”。`showDice`  函数有一个参数。这个参数是一个整数。它的名字叫 roll。

这意味着每当你为`showDice`写一个函数调用时，你不能只写函数的名称和括号，比如`showDice()`。它不会编译。你必须在括号中包含一个整数值（这称为“参数”），要么是一个变量，要么是一个简化为整数值的表达式。

这里有一些例子。

showDice;

//

不 (没有括号，这指的是变量而不是函数调用)

showDice();

//

不 (函数调用必须有一个参数，而不是零)

showDice(1);

//

是的（一个参数刚刚好）

showDice(4);

//

是的

showDice(1+2);

//

是的

showDice(roll2);

//

是的

showDice(roll5);

//

是的

showDice( (roll3+roll4) / 2

);

//

是的（奇怪但合法）

showDice(17);

//

是的（尽管它不会显示一个合适的骰子图片）

showDice(3, 4);

//

不 (函数调用必须有一个参数，而不是两个)

showDice(2.0);

//

不 (参数必须是整数，而不是双精度)

showDice("two");

//

不 (参数必须是整数，而不是字符串)

showDice(false);

//

不 (参数必须是整数，而不是布尔值)

在所有情况下，参数的值的副本都存储在参数中。因此，如果你这样调用函数 `showDice(3);`，那么函数被调用，值`3`被存储到参数 roll 中。所以到第 29 行，参数变量 roll 已经被声明并初始化为值`3`。

如果我们使用变量调用函数，比如 `showDice(roll2);` 那么在函数体执行之前，函数被调用并且当前在 roll2 中的任何值的副本将被存储到参数变量 roll 中。

因此，在第 16 行，`showDice`函数被执行，roll 将被设置为 roll1 中的任何值。

然后在第 17 行，`showDice`再次被调用，但这次 roll 将被设置为 roll1 中的任何值。

roll2。第 18 行调用`showDice`，同时将其参数设置为 roll3 的值。等等。

这样我们基本上运行了相同的代码块五次，但用不同的变量替换

每次掷骰子。这为我们节省了很多代码。

为了对比，我还写了一个简化的两个骰子版本的练习，而不使用函数。请注意，我必须重复完全相同的`if`语句序列两次：每个变量一次。

还要注意的是，虽然定义函数比只是复制和粘贴要多一点工作

```java

1 public class YachtDiceNoFunctions 2 {
```

```java
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
```

```java
public static void main( String[] args )
{
int roll1, roll2;
```

```java
do
{
```

```java
roll1 = 1 + (int)(Math.random()*6); roll2 = 1 + (int)(Math.random()*6); int total = roll1 + roll2;
System.out.println("\nYou rolled a " + roll1 + " and a " + roll2); System.out.println("+­­­+");
if ( roll1 == 1 )
{
```

```java
System.out.println("|
```

```java
|");
```

```java
System.out.println("| o |"); System.out.println("| |");
}
else if ( roll1 == 2 )
{
System.out.println("|o |"); System.out.println("| |"); System.out.println("| o|");
}
else if ( roll1 == 3 )
{
```

`if`语句并更改变量，两个骰子版本比五个骰子版本更长。

```java

28
System.out.println("|o |");

29
System.out.println("| o |");

30
System.out.println("| o|");

31
}

32
else if ( roll1 == 4 )

33
{

34
System.out.println("|o o|");

35
System.out.println("| |");

36
System.out.println("|o o|");

37
}

38
else if ( roll1 == 5 )

39
{

40
System.out.println("|o o|");

41
System.out.println("| o |");

42
System.out.println("|o o|");

43
}

44
else if ( roll1 == 6 )

45
{

46
System.out.println("|o o|");

47
System.out.println("|o o|");

48
System.out.println("|o o|");

49
}

50
System.out.println("+­­­+");

51

52

53
System.out.println("+­­­+");

54
if ( roll2 == 1 )

55
{

56
System.out.println("| |");

57
System.out.println("| o |");

58
System.out.println("| |");

59
}

60
else if ( roll2 == 2 )

61
{

62
System.out.println("|o |");

63
System.out.println("| |");

64
System.out.println("| o|");

65
}

66
else if ( roll2 == 3 )

67
{

68
System.out.println("|o |");

69
System.out.println("| o |");

70
System.out.println("| o|");

71
}

72
else if ( roll2 == 4 )

73
{

74
System.out.println("|o o|");

75
System.out.println("| |");

76
System.out.println("|o o|");

77
}

78
else if ( roll2 == 5 )

79
{

80
System.out.println("|o o|");

81
System.out.println("| o |");

82
System.out.println("|o o|");

83
}

84
else if ( roll2 == 6 )

85
{

86
System.out.println("|o o|");

87
System.out.println("|o o|");

88
System.out.println("|o o|");

89
}

90
System.out.println("+­­­+");

91

92
System.out.println("The total is
" + total + "\n");

93
94
95
96
97 }
```

```java
} while ( roll1 != roll2 );

System.out.println("Doubles! Nice job.");
```

```java
}
```

### 你应该看到的

```java

You rolled a
+­­­+
|o o|
| o |
|o o|
+­­­+
+­­­+
|o o|
| |
|o o|
+­­­+
The total is
5

9
and
a
4

You rolled a
+­­­+
|o o|
|o o|
|o o|
+­­­+
+­­­+
|o |
| |
| o|
+­­­+
The total is

6

8

and

a

2

You rolled a
+­­­+
|o |
| |
| o|
+­­­+
+­­­+
|o |
| |
| o|
+­­­+
The total is

2

4

and

a

2
Doubles! Nice job.
```

### 学习技巧

1. 添加第六个骰子。注意，只需添加一个函数调用就可以轻松显示*roll6*。

## 练习 37：从函数返回一个值

有些函数有参数，有些没有。参数是将值*传递*到函数的唯一方法。也只有一种方法可以从函数中得到一个值：返回值。

1 public class HeronsFormula 2 {

3

4

5

6

7

8

9

10

11

12

13

14

15

16

public static void main( String[] args )

{

double a;

a = triangleArea(3, 3, 3);

System.out.println("一个边长为 3,3,3 的三角形的面积为" + a );

a = triangleArea(3, 4, 5);

System.out.println("一个边长为 3,4,5 的三角形的面积为" + a );

a = triangleArea(7, 8, 9);

System.out.println("一个边长为 7,8,9 的三角形的面积为" + a );

System.out.println("一个边长为 5,12,13 的三角形的面积为" + triangleArea(5, 12, 13) );

1.  System.out.println("一个边长为 10,9,11 的三角形的面积为" + triangleArea(10, 9, 11) );

1.  System.out.println("一个边长为 8,15,17 的三角形的面积为" + triangleArea(8, 15, 17) );

19

20

21

22

}

public static double triangleArea( int a, int b, int c )

{

23 // 此函数中的代码计算具有长度 a、b 和 c 的三角形的面积

24

25

26

27

28

29

30

31

32 }

double s, A;

s = (a+b+c) / 2;

A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );

返回 A;

// ^ 计算面积后，“返回”它

}

这个练习给出了一个具有三个参数（三角形的边长）和一个输出（使用海伦公式计算三角形的面积）的函数的例子。

### 你应该看到的

```java

A triangle with sides 3,3,3 has an area of 2.0 A triangle with sides 3,4,5 has an area of 6.0
A triangle with sides 7,8,9 has an area of 26.832815729997478 A triangle with sides 5,12,13 has an area of 30.0
A triangle with sides 10,9,11 has an area of 42.42640687119285 A triangle with sides 8,15,17 has an area of 60.0
```

你可以看到函数`triangleArea`有三个参数。它们都是整数，它们的名字分别是 a、b 和 c。正如你已经知道的，这意味着我们不能在不提供三个整数值作为参数的情况下调用函数。

除此之外，`triangleArea`函数返回一个值。请注意，在第 21 行，它没有在`public static`和`triangleArea`之间说`void`。它说`double`。这意味着“这个函数返回一个值，它返回的值的类型是`double`。”

如果在这个位置上有关键字`void`，这意味着“这个函数不返回任何值。” 如果我们想让`triangleArea`返回不同类型的值：

```java

public static int int
```

```java
triangleArea( int a, int b, int c ) // this would return an
```

```java
public static String triangleArea( int a, int b, int c ) // this would return a String

public static boolean triangleArea( int a, int b, int c ) // this would return either true or false

public static void  triangleArea( int a, int b, int c ) // this cannot return any value of any type
```

有时我的学生会对返回值和不返回值的函数感到困惑。类比是有帮助的。

假设我们坐在我的学校教室里。我们听到雷声，我记得我把车窗开着。我不想让雨水把车里弄湿，所以我让你出去停车场。

“学生，请出去停车场，把我的车窗摇上。” “好的，先生，”你说。

如果你需要我关于我的车是什么样子的信息，那么这些就是参数。如果你已经知道哪辆是我的，你就不需要参数。

最终你返回并说“我完成了任务。”这种类型的函数不返回值。

```java

rollUpWindows(); // if you don't need parameters

rollUpWindows("Toyota", "Corolla", 2008, "blue"); // if you do need parameters
```

无论哪种情况，函数都会被执行并完成其任务，但不返回任何值。现在，例子#2：

我们再次在我的教室里。我正在网上更新我的汽车保险，网页要求我输入我的车牌号。我不记得了，所以我让你去停车场帮我拿。

最终你返回并*告诉我车牌号*。也许你把它写在一张纸上，也许你记住了。当你给我时，我自己抄下来。这种类型的函数返回一个值。

```java

String plate;

plate = retrieveLicensePlate(); // if you don't need parameters

plate = retrieveLicensePlate("Toyota", "Corolla", 2008, "blue"); // if you do need them
```

如果我粗鲁，你可以回到我的教室，把值给我，我可以把手指放在耳朵上，这样我就听不到你，或者拒绝自己写下来，这样我很快就会忘记它。如果你调用一个返回值的函数，你可以选择*不*将返回值存储到一个变量中，而是让这个值消失：

```java

retrieveLicensePlate("Toyota", "Corolla", 2008, "blue"); // returns a value which is lost

triangleArea(3, 3, 3); // returns the area but we refuse to store it into a variable
```

这通常是一个坏主意，但也许你有你的理由。

无论如何，在第 10 行我们调用`triangleArea`函数。我们传入`3`、`4`和`5`作为三个参数。`3`被存储为 a 的值（在第 21 行）。`4`被存储为 b，`5`被放入

c. 使用这些参数值运行第 23 到 28 行的所有代码。最后，变量 A 中存储了一个值。

在第 29 行，我们*返回*变量*A*中的值。这个值返回到第 10 行，存储到变量*a*中。

```java

1 public class HeronsFormulaNoFunction 2 {
```

```java
3
4
5
6
7
8
9
10
11
12
13
A ); 14
15
16
17
18
19
20
A ); 21
22
23
24
25
26
27
A ); 28
29
30
31
32
33
34
); 35
36
37
38
39
40
41
); 42
43
```

```java
public static void main( String[] args )
{
int a, b, c; double s, A;
```

```java
a = 3;
b = 3;
c = 3;
s = (a+b+c) / 2;
A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
System.out.println("A triangle with sides 3,3,3 has an area of " +

a = 3;
b = 4;
c = 5;
s = (a+b+c) / 2;
A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
System.out.println("A triangle with sides 3,4,5 has an area of " +

a = 7;
b = 8;
c = 9;
s = (a+b+c) / 2;
A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
System.out.println("A triangle with sides 7,8,9 has an area of " +

a = 5;
b = 12;
c = 13;
s = (a+b+c) / 2;
A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
System.out.println("A triangle with sides 5,12,13 has an area of " + A

a = 10;
b = 9;
c = 11;
s = (a+b+c) / 2;
A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
System.out.println("A triangle with sides 10,9,11 has an area of " + A

a = 8;
```

为了确保你能明白函数值得麻烦的原因，这里有一个例子，写出了同样的程序，但没有使用函数。

![image](img/Image_052.png)

1.  （变量 A 本身并没有被返回，只有它的值。事实上，要记住变量的“作用域”仅限于它所定义的代码块内吗？（你在练习 21 中学到了这一点。）变量 a 只在函数 main 内部的作用域内，变量 s、A 和参数变量 a、b 和 c 只在函数 triangleArea 内部的作用域内。）

    ```java
    44

    b = 15;
    45

    c = 17;
    46

    s = (a+b+c) / 2;
    47

    A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
    48

    System.out.println("A triangle with sides 8,15,17 has an area of " + A
    );

    49

    }

    50
    }

    ```

    ### 你应该看到的

    ```java

    A triangle with sides 3,3,3 has an area of 2.0 A triangle with sides 3,4,5 has an area of 6.0
    A triangle with sides 7,8,9 has an area of 26.832815729997478 A triangle with sides 5,12,13 has an area of 30.0
    A triangle with sides 10,9,11 has an area of 42.42640687119285 A triangle with sides 8,15,17 has an area of 60.0
    ```

    ### 学习训练

    1.  哪一个更长，有函数的还是没有函数的？

    1.  这两个文件的公式中有一个错误。当`(a+b+c)`是奇数时，除以`2`会丢失`.5`。将其修正为`(a+b+c)/2.0`。在没有使用函数的版本中修复会更难吗？

    1.  再添加一个测试：找到一个边长为 9、9 和 9 的三角形的面积。添加起来难吗？如果在不使用函数的版本中添加测试会更难吗？

    ### 在完成了学习练习后，你应该看到的内容

    ```java

    A triangle with sides 3,3,3 has an area of 3.897114317029974 A triangle with sides 3,4,5 has an area of 6.0
    A triangle with sides 7,8,9 has an area of 26.832815729997478 A triangle with sides 5,12,13 has an area of 30.0
    A triangle with sides 10,9,11 has an area of 42.42640687119285 A triangle with sides 8,15,17 has an area of 60.0
    A triangle with sides 9,9,9 has an area of 35.074028853269766
    ```

    这更好。

    ## 练习 38：形状的面积

    今天的练习没有什么新东西。这只是对函数的额外练习。这个程序有三个函数（如果算上`main`就有四个），它们都有参数，三个都有返回值。

    ```java

    1 import java.util.Scanner; 2
    3 public class ShapeArea 4 {
    5  public static void main( String[] args ) 6  {
    7    Scanner keyboard = new Scanner(System.in); 8
    12  System.out.println("Shape Area Calculator version 0.1 (c) 2013 Mitchell Sample Output, Inc.");
    13
    14    do
    15    {
    16      System.out.println("\n­=­=­=­=­=­=­=­=­=­=­=­=­=­=­\n");
    24      if ( choice == 1 )
    25      {
    33      else if ( choice == 2 )
    34      {
    40      else if ( choice == 3 )
    41      {
    computeRectangleArea(length, width) );
    47

    }
    48

    else if ( choice != 4 )
    49

    {
    50

    System.out.println("ERROR.");
    51

    }
    52

    53

    } while ( choice != 4 );
    54

    55
    }

    56

    ```

    1.  ```java
        int choice;
        ```

    1.  ```java
        double area = 0; 11
        ```

    1.  ```java
        System.out.println("1) Triangle");
        ```

    1.  ```java
        System.out.println("2) Circle");
        ```

    1.  ```java
        System.out.println("3) Rectangle");
        ```

    1.  ```java
        System.out.println("4) Quit");
        ```

    1.  ```java
        System.out.print("> ");
        ```

    1.  ```java
        choice = keyboard.nextInt(); 23
        ```

    1.  ```java
        System.out.print("\nBase: ");
        ```

    1.  ```java
        int b = keyboard.nextInt();
        ```

    1.  ```java
        System.out.print("Height: ");
        ```

    1.  ```java
        int h = keyboard.nextInt();
        ```

    1.  ```java
        area = computeTriangleArea(b, h);
        ```

    1.  ```java
        System.out.println("The area is " + area); 32      }
        ```

    1.  ```java
        System.out.print("\nRadius: ");
        ```

    1.  ```java
        int r = keyboard.nextInt();
        ```

    1.  ```java
        area = computeCircleArea(r);
        ```

    1.  ```java
        System.out.println("The area is " + area); 39      }
        ```

    1.  ```java
        System.out.print("\nLength: ");
        ```

    1.  ```java
        int length = keyboard.nextInt();
        ```

    1.  ```java
        System.out.print("Width: ");
        ```

    1.  ```java
        int width = keyboard.nextInt();
        ```

    1.  ```java
        System.out.println("The area is " +
        ```

    ```java
    57

    public static double computeTriangleArea( int base, int height )
    58

    {
    59

    double A;
    60

    A = 0.5 * base * height;
    61

    return A;
    62

    }
    63

    64

    public static double computeCircleArea( int radius )
    65

    {
    66

    double A;
    67

    A = Math.PI * radius * radius;
    68

    return A;
    69

    }
    70

    71

    public static int computeRectangleArea( int length, int width )
    72

    {
    73

    return (length * width);
    74

    }
    75
    }

    ```

    ### 你应该看到的内容

    ```java

    Shape Area Calculator version 0.1 (c) 2013 Mitchell Sample Output, Inc.

    ­=­=­=­=­=­=­=­=­=­=­=­=­=­=­

    ```

    1.  ```java
        Triangle
        ```

    1.  ```java
        Circle
        ```

    1.  ```java
        Rectangle
        ```

    1.  ```java
        Quit
        ```

    ```java
    > 1

    Base: 3
    Height: 5
    The area is 7.5

    ­=­=­=­=­=­=­=­=­=­=­=­=­=­=­

    ```

    1.  ```java
        Triangle
        ```

    1.  ```java
        Circle
        ```

    1.  ```java
        Rectangle
        ```

    1.  ```java
        Quit
        ```

    ```java
    > 2

    Radius: 3
    The area is 28.274333882308138

    ­=­=­=­=­=­=­=­=­=­=­=­=­=­=­

    ```

    1.  ```java
        Triangle
        ```

    1.  ```java
        Circle
        ```

    1.  ```java
        Rectangle
        ```

    1.  ```java
        Quit
        ```

    ```java
    > 4
    ```

    在第 57 行，我们定义了一个计算三角形面积的函数（这次只使用底边和高）。它需要两个参数，并将返回一个`double`值。在第 59 行，我们声明了一个名为 A 的变量。这个变量是函数“局部”的。尽管在第 66 行声明了一个名为 A 的变量，但它们并不是同一个变量。（就像有两个名叫“迈克尔”的朋友。只是因为他们有相同的名字并不意味着他们是同一个人。）

    变量*b*（在第 27 行定义）的值作为函数调用中参数*base*的初始值传入。*b*被存储到*base*中，因为*b*是首先出现的，而不是因为*base*以*b*开头。

    计算机对此并不在乎。只有顺序才重要。

    在第 61 行，A 的值返回到`main`，最终被存储在名为 area 的变量中。在矩形面积函数的定义开始于第 71 行时，我做了三件奇怪的事情。

    首先，形式参数与实际参数具有相同的名称。（记住，参数是函数定义中声明的变量，位于第 71 行，参数是函数调用中括号中的变量。）这是一个巧合，但并不意味着什么。这就像一个名叫“史蒂文”的演员扮演一个名叫“史蒂文”的角色。`main`版本的 length 的值被存储到`computeRectangleArea`的 length 变量中，因为它们都在括号中首先列出，没有其他原因。

    其次，我没有费心为函数将要返回的值创建一个变量。我只是返回了表达式`length*width`的值。函数会计算出值并立即返回，而不会将其存储到变量中。

    第三，矩形面积值在第 46 行返回到`main`，但我没有费心将返回值存储到变量中：我直接在屏幕上打印出来。(我在`HeronsFormula`中也这样做了，但我没有特别指出。)这是完全可以的，实际上非常常见。我们经常调用函数，几乎总是使用函数的返回值，但我们并不总是需要将返回值存储到自己的变量中。

    最后，在我们转到另一个话题之前，我应该提到，在 Java 中，函数只能返回一个值。在其他一些编程语言中，函数可以返回多个值。但在 Java 中，函数可以返回一个值或没有值（如果函数是`void`），但绝不会超过一个。

    P.S.这些函数有点傻。如果我*真的*需要一个形状面积计算器，我不确定是否值得为一个只有一行代码的方程创建一个完整的函数。但是这个例子用来解释是很好的。

    ### 学习练习

    1. 添加一个计算正方形面积的函数。也将其添加到菜单中。

    ## 练习 39：使用 Javadoc 重新审视三十天

    在上一个练习中，我们写了一些可能更好被省略的函数。在今天的练习中，我们将重新做一个之前的练习，使用函数使其更好。

    而且，因为我总是不断努力，我在类的上方和每个函数的上方添加了称为“Javadoc 注释”的特殊注释。

    ```java

    1 import java.util.Scanner; 2
    3 /**
    4 * Contains functions that make it easier to work with months. 5 */
    6 public class ThirtyDaysFunctions 7 {
    8   public static void main( String[] args ) 9   {
    10    Scanner kb = new Scanner(System.in); 11
    ```

    1.  ```java
        System.out.print( "Which month? (1­12) " );
        ```

    1.  ```java
        int month = kb.nextInt(); 14
        ```

    ```java
    15    System.out.println( monthDays(month) + " days hath " + monthName(month) );
    16
    17  }
    18
    19  /**
    20   * Returns the name for the given month number (1­12).
    21  *
    ```

    1.  ```java
        * @author Graham Mitchell
        ```

    1.  ```java
        * @param month the month number (1­12)
        ```

    1.  ```java
        * @return    a String containing the English name for the given month, or "error" if month out of range
        ```

    ```java
    25  */
    26   public static String monthName( int month ) 27   {
    28    String monthName = "error"; 29
    ```

    1.  ```java
        if ( month == 1 )
        ```

    1.  ```java
        monthName = "January";
        ```

    1.  ```java
        else if ( month == 2 )
        ```

    1.  ```java
        monthName = "February";
        ```

    1.  ```java
        else if ( month == 3 )
        ```

    1.  ```java
        monthName = "March";
        ```

    1.  ```java
        else if ( month == 4 )
        ```

    1.  ```java
        monthName = "April";
        ```

    1.  ```java
        else if ( month == 5 )
        ```

    1.  ```java
        monthName = "May";
        ```

    1.  ```java
        else if ( month == 6 )
        ```

    1.  ```java
        monthName = "June";
        ```

    1.  ```java
        else if ( month == 7 )
        ```

    1.  ```java
        monthName = "July";
        ```

    1.  ```java
        else if ( month == 8 )
        ```

    1.  ```java
        monthName = "August";
        ```

    1.  ```java
        else if ( month == 9 )
        ```

    1.  ```java
        monthName = "September";
        ```

    1.  ```java
        else if ( month == 10 )
        ```

    1.  ```java
        monthName = "October";
        ```

    1.  ```java
        else if ( month == 11 )
        ```

    1.  ```java
        monthName = "November";
        ```

    1.  ```java
        else if ( month == 12 )
        ```

    1.  ```java
        monthName = "December";
        ```

    ```java

    54
    55
    56
    57
    58
    59
    60
    61
    62
    63
    ```

    ```java
    return monthName;
    ```

    ```java
    }
    ```

    ```java
    /**
    ```

    +   ```java
        Returns the number of days in a given month.
        *
        ```

    +   ```java
        @author Graham Mitchell
        ```

    +   ```java
        @param month the month number (1­12)
        ```

    ```java
    * @return
    ```

    ```java
    the number of days in a non­leap year for that month, or
    ```

    ```java
    64
    65
    66
    67
    68
    69
    70
    71
    72
    73
    74
    75
    76
    77
    78
    79
    80
    81
    82
    83
    84
    85
    86
    87
    88 }
    ```

    ```java
    31 if month out of range
    */
    public static int monthDays( int month )
    {
    int days;
    ```

    ```java
    /* Thirty days hath September April, June and November
    All the rest have thirty­one
    Except the second month alone.  */

    switch(month)
    {
    case  9:
    case  4:
    case  6:
    case 11: days = 30;
    break; case 2: days = 28;
    break; default: days = 31;
    }

    return days;
    ```

    ```java
    }
    ```

    ### 您应该看到的内容

    ```java

    Which month? (1­12) 9
    30 days hath September
    ```

    如果现在忽略 Javadoc 注释，希望您应该能够看到在这里使用函数实际上改进了代码。`main()`非常简短，因为大部分有趣的工作都是在函数中完成的。

    与月份名称相关的所有代码和变量都被隔离在`monthName()`函数中。查找月份天数的所有代码都包含在`monthDays()`函数中。

    像这样将变量和代码收集到函数中被称为“过程式编程”，这被认为是比将所有代码放在`main()`中更重要的进步。这使得您的代码更容易调试，因为如果您遇到月份名称的问题，您就知道它必须在`monthName()`函数中。

    好了，现在让我们谈谈 Javadoc 注释。

    `javadoc` 是随同 Java 编译器一起提供的自动生成文档的工具。您可以通过在类、函数或变量上方使用特殊类型的块注释来在代码中编写文档。

    注释以`/**`开头，以`*/`结尾，中间的每一行都以星号(`*`)开头

    就像您在练习中看到的那样排列。

    javadoc 注释的第一行是关于该事物（类或函数）的一句话摘要。然后有标签如`@author`或`@return`，提供了更多关于谁编写了代码，函数期望的参数或它将返回的值的详细信息。

    好了，现在是魔法部分。打开终端窗口，就像您要编译代码一样，然后输入以下命令：

    ```java

    $ javadoc ThirtyDaysFunctions.java
    Loading source file ThirtyDaysFunctions.java... Constructing Javadoc information...
    Standard Doclet version 1.7.0_21
    Building tree for all the packages and classes... Generating /ThirtyDaysFunctions.html...
    Generating /package­frame.html... Generating /package­summary.html... Generating /package­tree.html...
    Generating /constant­values.html...
    Building index for all the packages and classes... Generating /overview­tree.html...
    Generating /index­all.html... Generating /deprecated­list.html... Building index for all classes...
    Generating /allclasses­frame.html... Generating /allclasses­noframe.html... Generating /index.html...
    Generating /help­doc.html...
    $
    ```

    然后，如果您查看`ThirtyDaysFunctions.java`所在的文件夹，您将看到许多新文件。（也许我应该先警告您。）在您选择的 Web 浏览器中打开名为`index.html`的文件。

    这是 javadoc 文档，其中包含*大量*的信息。您可以在顶部附近找到您为类放置的注释，函数的注释在名为“Method Summary”的部分中。

    有关参数和返回类型的详细信息在名为“Method Detail”的部分下面。

    ### 学习练习

    1. 查看内置 Java 类 java.util.Scanner 的 javadoc 文档。注意它看起来与 javadoc 工具生成的文档有多相似？所有官方的 Java 文档都是使用 javadoc 工具创建的，因此学习如何阅读它将成为成为专业 Java 程序员的重要部分。不过现在不要太担心细节，只是试着感受一下它的外观。

    左上角是包含在 Java 中的所有代码包的列表，下面是左侧是您可以导入以避免编写代码的所有类/库的列表。专业的 Java 程序员的工作的一大部分是编写代码来粘合现有的 Java 库。

    现在这可能让您感到不知所措。这没关系，因为您刚刚开始。希望没有人期望您现在就了解太多。事实上，大多数程序员只了解 Java 的内置库的一小部分，并且当他们需要做一些新的事情时，他们会在互联网上搜索并阅读文档，就像您一样！

    ## 练习 40：导入标准库

    在上一个练习中，您看到了 Java 中可用的所有内置模块，这可能让您感到恐慌。今天我们将看一个“简单”的程序，我花了大约半个小时的时间编写，因为我花了很多时间在互联网上搜索和导入东西，尝试了一些不起作用的东西。

    这段代码有效。它允许用户输入密码（或任何内容），然后打印出该密码的 SHA-256 消息摘要。

    当您在编写此代码时，不要忘记在第 7 行的末尾加上`throws Exception`。

    ```java

    5 public class PasswordDigest
    6 {
    7

    public static void main( String[] args ) throws Exception
    8

    {
    9

    Scanner keyboard = new Scanner(System.in);
    10

    11

    String pw, hash;
    12

    13

    MessageDigest digest = MessageDigest.getInstance("SHA­256");
    14

    15

    System.out.print("Password: ");
    16

    pw = keyboard.nextLine();
    17

    18

    digest.update( pw.getBytes("UTF­8") );
    19

    hash = DatatypeConverter.printHexBinary( digest.digest() );
    20

    21

    System.out.println( hash );
    22

    }
    23
    }

    ```

    1.  ```java
        import java.util.Scanner;
        ```

    1.  ```java
        import java.security.MessageDigest;
        ```

    1.  ```java
        import javax.xml.bind.DatatypeConverter; 4
        ```

    ### 您应该看到的内容

    ```java

    Password: password 5E884898DA28047151D0E56F8DC6292773603D0D6AABBDD62A11EF721D1542D8
    ```

    那个 64 个字符长的字符串是字符串`password`的 SHA­256 摘要。该消息摘要对于该输入始终是相同的。

    如果您输入不同的密码，当然会得到不同的摘要：

    ```java

    Password: This is a really long password and no one will ever guess it. A113B65D8BA8DB72D631D97B7A3698E82CDB9D1F52456C8957312CB91EC02B10
    ```

    在编程的早期，当机器开始拥有用户名和密码时，很明显您不希望直接在数据库中存储密码本身。相反，他们会存储密码的某种加密哈希。

    加密哈希具有两个有用的属性：

    1.  它们是一致的。给定的输入将始终产生完全相同的输出。

    1.  它们是单向的。您可以轻松计算给定输入的输出，但找出给您某个输出的输入是非常困难或不可能的。

    SHA­256 是一个非常好的加密哈希函数，它始终产生一个给定输入（或“消息”）的“摘要”，长度恰好为 256 位。在这里，我们没有尝试处理位，而是打印出了这些位的 base­64 表示，最终是 64 个字符长，其中每个字符都是十六进制数字。

    回到 20 世纪 70 年代，要在某台机器上更改密码，您需要输入密码，然后机器会将您的用户名和新密码的哈希存储在文件中。

    然后，当您以后想要登录到机器时，它会让您输入用户名和密码。它会在密码数据库文件中找到用户名，并找到您密码的存储哈希值。然后它会找到您刚刚输入的密码的哈希值。如果存储的哈希值和计算的哈希值匹配，那么您必须输入了正确的密码，您将被允许访问该机器。

    这是一个聪明的方案。这也比直接在数据库中存储密码要好得多。然而，现在计算机速度太快，存储空间太大，这已经不足以提供足够的安全性。由于机器可以非常快速地计算密码的 SHA­256，一个决心的黑客不需要很长时间就能够弄清楚您的密码是什么。

    （如果您真的想要在数据库中安全存储密码，您应该使用`bcrypt`，它专门用于此类事情。不幸的是，bcrypt 并没有内置到 Java 中，因此您需要下载其他人制作的 bcrypt 库。）

    好了，关于安全密码就说这么多，让我们走一遍这段代码。您可能希望打开这两个库的 javadoc 文档。

    +   java.security.MessageDigest

    +   javax.xml.bind.DatatypeConverter

        在第 2 和 3 行，我们导入了两个库，这两个库将用于执行此练习的难点。

        在第 13 行，我们创建了一个`MessageDigest`类型的变量（现在存在，因为我们导入了`java.security.MessageDigest`）。我们的变量名为 digest，尽管我也可以叫它其他名字。变量的值来自于`MessageDigest.getInstance()`方法的返回值。我们将一个字符串作为该方法的参数传递，这是我们想要的摘要。在这种情况下，我们使用了`"SHA­256"`，但`"SHA­1"`和`"MD5"`也可以工作。您可以在 javadoc 文档中阅读有关此内容的信息。

        第 15 和 16 行希望是无聊的。请注意，我使用`nextLine()`而不是`next()`来读取密码，这允许用户输入多个单词。

        在第 18 行，我们调用了 String 类的`getBytes()`方法，参数为`"UTF­8"`。这将把字符串值转换为 UTF­8 格式的原始字节列表，然后将其直接作为参数传递给名为 digest 的 MessageDigest 对象的`update()`方法。我通过阅读 String 类的 javadoc 文档了解了`getBytes()`方法！

    +   java.lang.String

        第 19 行我们调用了名为 digest 的 MessageDigest 对象的`digest()`方法。这给了我们一个原始的字节列表，不适合在屏幕上打印，所以我们直接将这个原始的字节列表作为参数传递给 DatatypeConverter 类的`printHexBinary()`方法。这将返回一个字符串，我们将其存储到变量 hash 中。

        然后我们在屏幕上显示哈希值。哇！

        如果这个练习让你有点紧张，别担心。如果你能完成本书的前 39 个练习，那么你也可以学会做这种事情。你必须学会阅读 javadoc 文档，了解其他人已经为你写好了什么样的工具，以及如何将它们连接在一起以获得你想要的东西。这只是需要大量的练习！记住，第一次写这个练习花了我半个多小时，而我从上世纪 80 年代开始编程，1996 年开始编写 Java 代码！

        ### 学习 Drill

        1.  查看本练习中使用的所有方法的 javadoc 文档：getInstance、getBytes、update、digest 和 printHexBinary。查看它们期望的参数和它们将返回的值的类型。

        1.  从第 7 行的末尾删除`throws Exception`。尝试编译它。（然后再放回去。）你将在下一个练习中学到一点关于异常。

        ## 练习 41：写入文件的程序

        我们现在要暂时停下来专注于函数，学习一些简单的东西。我们要创建一个程序，可以将信息放入文本文件，而不仅仅是在屏幕上打印东西。

        当你在输入这段代码时，不要错过第 6 行末尾的`throws Exception`。（在这个练习中，我会解释这意味着什么。）

        ### 你应该看到的

        ![image](img/Image_055.png)

        没错。当你运行你的程序时，它似乎什么都没做。但如果你写得正确，它应该在与你的代码相同的文件夹中创建一个名为`letter.txt`的文件。你可以使用与写代码相同的文本编辑器查看这个文件。

        如果由于某种原因你正在使用随 Windows 95 一起提供的版本的记事本，它看起来可能会像这样：

        ![image](img/Image_056.gif)

        （那个截图是很久以前做的，好吧？记住我做这个已经很长时间了。当我第一次

        当我把这个作业给学生时，Windows 95 是最新版本的 Windows……实际上，我猜邮政编码在某个时候改变了。）

        在第 1 行和第 2 行有两个新的`import`语句，分别是用于这两个 Java 类的。

        在第 8 行，我们声明了一个变量。这个变量的类型是`PrintWriter`，我选择将它命名为 fileout（尽管变量的名称并不重要）。

        fileout（尽管变量的名称并不重要）。

        在第 10 行，我们给 PrintWriter 变量赋了一个值：一个新的 PrintWriter 对象的引用。创建 PrintWriter 对象需要一个参数。我们给它的参数是一个新的`FileWriter`对象，它本身是用文件名作为参数创建的。

        可以只使用`FileWriter`对象而不使用任何 PrintWriter 来写入文本文件。然而，PrintWriters 更容易使用，你可以通过查看代码的其余部分来看出来。所以我们不直接使用 FileWriter 对象，而是用 PrintWriter 对象“包装”FileWriter 对象，然后通过 PrintWriter 对象进行操作。

        （如果你不理解最后两段，没关系。你不需要理解它们来写文件。）

        好消息是，一旦 PrintWriter 对象设置好了，其他的事情就很容易了。因为你从一开始就在秘密地使用 PrintWriters！这是因为`System.out`是一个 PrintWriter！

        因此，在第 12 行，您可以看到写入文件看起来与在屏幕上打印非常相似。但是字符串（`+­­­­­`）不会被打印在屏幕上。它将被存储为文件`letter.txt`的第一行！

        如果该文件夹中已经存在名为`letter.txt`的文件，则其内容将被覆盖而不会有警告。如果文件不存在，则将创建该文件。

        练习中的另一个重要行是第 23 行。这实际上保存了文件的内容并关闭了它，因此您的程序无法再对其进行写入。如果删除此行，您的程序很可能会创建一个名为`letter.txt`的文件，但该文件将为空。

        好的，在结束练习之前，我想简要讨论一下`throws Exception`。这在真正的编程中并不常见，并且适当地解释它超出了本书的范围，但我确实想谈一下。

        在练习的原始版本中，当您在函数的第一行之后放置`throws Exception`时，它的意思是“我已经在这个函数中编写了可能不起作用的代码，如果失败，它将会失败（通过抛出异常）。”

        在这种情况下，可能不起作用的是`new FileWriter（“letter.txt”）`这一行，因为它试图在当前文件夹中打开一个文件进行写入。如果已经有一个名为“letter.txt”的文件并且该文件是只读的，这可能会失败。或者整个文件夹是只读的。或者有其他原因导致程序无法获得对文件的写入权限。

        因此，我们不是简单地使程序崩溃，而是应该检测异常并处理它。就像这样：

        `try`块的意思是“这段代码可能会抛出异常，但尝试执行它。”如果一切顺利（如果没有抛出异常），那么`catch`块将被跳过。如果抛出异常，则会执行`catch`块，并将抛出的异常作为参数传递进去。（我已经将异常参数命名为 err，尽管它可以被命名为任何东西。）

        在`catch`块中，我打印出一个合适的错误消息，然后通过调用内置函数`System.exit()`来结束程序。如果向`System.exit()`传递参数`0`，程序将结束，但零表示“一切正常”。参数`1`表示“程序正在结束，因为出了问题”。

        所以我不会在这本书中再使用`try`和`catch`了，但至少现在你知道通过使用`throws Exception`来避免什么了。

        ## 练习 42：从文件中获取数据

        能够将信息放入文件的程序只是故事的一部分。因此，在这个练习中，您将学习如何读取已经存在于文本文件中的信息。

        如果你输入这段代码并编译并运行，它会崩溃。这是因为它试图从一个名为`name-and-numbers.txt`的文本文件中读取，这个文件必须与你的代码在同一个文件夹中。你可能没有这样的文件！

        因此，在你写代码之前，让我们创建一个包含一个字符串和三个整数的文本文件。我的文件看起来像这样：

        ![image](img/Image_058.jpg)

        （这是一个稍微更新的记事本版本。现在开心了吗？）好了，来看代码吧！

        ```java
        4 public class GettingFromFile
        5 {
        6

        public static void main( String[] args ) throws Exception
        7

        {
        8

        Scanner fileIn = new Scanner(new File("name­and­numbers.txt"));
        9

        10

        int a, b, c, sum;
        11

        String name;
        12

        13

        System.out.print("Getting name and three numbers from file...");
        14

        name = fileIn.nextLine();
        15

        a = fileIn.nextInt();
        16

        b = fileIn.nextInt();
        17

        c = fileIn.nextInt();
        18

        fileIn.close();
        19

        20

        System.out.println("done.");
        21

        System.out.println("Your name is " + name);
        22

        sum = a + b + c;
        23

        System.out.println( a + "+" + b + "+" + c + " = " + sum );
        24

        }
        25
        }

        ```

        1.  ```java
            import java.util.Scanner;
            ```

        1.  ```java
            import java.io.File; 3
            ```

        ### 你应该看到什么

        ```java

        Getting name and three numbers from file...done. Your name is Samantha Showalter
        5+6+7 = 18
        ```

        你知道 Scanner 对象不一定要从键盘上的人那里获取输入吗？它也可以从文本文件中读取数据！

        我们只是稍微不同地创建了 Scanner 对象：不再使用`System.in`作为参数，而是使用`new File("blah.txt")`。这将以只读方式打开文本文件。我选择称之为 fileIn 的 Scanner 对象将附加到文件上，就像吸管插入果汁盒一样。（果汁盒就是文本文件，Scanner 对象就是吸管。）

        第 14 行看起来相当无聊。它“暂停”程序并从 Scanner 对象中读取一个字符串，这个字符串来自文件。这个来自文件的字符串被存储到变量中。

        第 15 到 17 行也很简单。除了从文件中读取的内容在放入变量之前被转换为整数。

        如果文件中的下一个内容不是整数会怎样？那么你的程序将崩溃。现在你不能再责怪人类了：你创建了这个文件。你的工作是确保你知道里面有什么值，以及顺序是什么。

        在第 18 行，文件被关闭，这意味着你的 Scanner 对象不再与它连接。这比你预期的要容易吗？希望是这样。

        ### 学习训练

        1.  打开文本文件并更改名称或数字。保存它。然后再次运行程序（您不必重新编译它；代码没有更改，直到运行程序时它才会打开文件）。

            ## 练习 43：保存最高分

            现在你知道如何从文件中获取信息*以及*如何将信息放入文件，我们可以创建一个保存最高分的游戏！

            这是之前几个练习中的抛硬币游戏，但现在高分保存在运行之间。

            ```java

            6 public class CoinFlipSaved 7 {
            8  public static void main( String[] args ) throws Exception 9  {
            10    Scanner keyboard = new Scanner(System.in); 11
            14
            15
            File in = new File(saveFile);

            16
            if ( in.createNewFile() )

            17
            {

            18
            System.out.println("Save game file doesn't exist. Created.");

            19
            best = ­1;

            20
            bestName = "";

            21
            }

            22
            else

            23
            {

            24
            Scanner input = new Scanner(in);

            25
            bestName = input.next();

            26
            best = input.nextInt();

            27
            input.close();

            28
            System.out.println("High score is " + best + " flips in a row
            by "
            + bestName
            );

            29
            }

            30

            31

            32
            do

            33
            {

            34
            flip = 1 + (int)(Math.random()*2);

            35

            36
            if ( flip == 1 )

            37
            coin = "HEADS";

            38
            else

            39
            coin = "TAILS";

            40

            41
            System.out.println( "You flip a coin and it is... " + coin );

            42

            43
            if ( flip == 1 )

            44
            {

            50      else
            51      {
            54      }
            55    } while ( again.equals("y") );
            ```

            1.  ```java
                import java.util.Scanner;
                ```

            1.  ```java
                import java.io.File;
                ```

            1.  ```java
                import java.io.FileWriter;
                ```

            1.  ```java
                import java.io.PrintWriter; 5
                ```

            1.  ```java
                String coin, again, bestName, saveFile = "coin­flip­score.txt";
                ```

            1.  ```java
                int flip, streak = 0, best;
                ```

            1.  ```java
                streak++;
                ```

            1.  ```java
                System.out.println( "\tThat's " + streak + " in a row...." );
                ```

            1.  ```java
                System.out.print( "\tWould you like to flip again (y/n)? " );
                ```

            1.  ```java
                again = keyboard.next(); 49      }
                ```

            1.  ```java
                streak = 0;
                ```

            1.  ```java
                again = "n";
                ```

            ```java

            56
            57
            58
            59
            60
            61
            62
            63
            64
            65
            66
            67
            68
            69
            70
            71
            72
            ```

            ```java
            System.out.println( "Final score: " + streak );

            if ( streak > best )
            {
            System.out.println("That's a new high score!"); System.out.print("Your name: ");
            bestName = keyboard.next(); best = streak;
            }
            else if ( streak == best )
            {
            System.out.println("That ties the high score. Cool.");
            }
            else
            {
            System.out.println("You'll have to do better than " + streak + "
            ```

            ```java
            if you want a high score.");
            ```

            ```java
            73
            74
            75
            76
            77
            78
            79
            80
            81 }
            ```

            ```java
            }
            ```

            ```java
            // Save this name and high score to the file.
            PrintWriter out = new PrintWriter( new FileWriter(saveFile) ); out.println(bestName);
            out.println(best); out.close();
            ```

            ```java
            }
            ```

            ### 你应该看到什么

            ```java

            Save game file doesn't exist. Created. You flip a coin and it is... HEADS
            That's 1 in a row....
            Would you like to flip again (y/n)? y You flip a coin and it is.  HEADS
            That's 2 in a row....
            Would you like to flip again (y/n)? y You flip a coin and it is.  HEADS
            That's 3 in a row....
            Would you like to flip again (y/n)? n Final score: 3
            That's a new high score! Your name: Mitchell
            ```

            （好吧，我作弊了。我尝试了很多次才连续三次猜对。）

            在第 15 行，我们使用文件名`coin-flip-score.txt`创建了一个`File`对象。即使文件不存在，我们也可以这样做。

            在第 16 行有一个`if`语句，在条件中我调用了 File 对象的`createNewFile()`方法。这将检查文件是否存在。如果是，它将什么也不做并返回布尔值`false`。如果文件不存在，它将创建一个空文件并返回值`true`。

            当`if`语句为真时，这意味着保存游戏文件不存在。我们会这样说，并将合适的初始值放入变量 best 和 bestName 中。如果不是，那么已经有一个文件存在，所以我们使用 Scanner 对象从文件中获取现有的名称和最高分。很酷，对吧？

            第 32 到 57 行是现有的抛硬币游戏。我一点也没有改变这段代码。

            在第 59 行，我们需要弄清楚他们是否打破了最高分。如果是，我们会打印出相应的消息并让他们输入他们的名字。

            如果他们打破了最高分，我们会这样说，但他们不会因此而得到任何名声。

            并且在第 70 行，如果他们没有打破或并列最高分，`else`将运行。所以我们当然会嘲笑他们。

            在第 75 到 79 行，我们将当前的最高分以及最高得分者的名字保存到文件中。这可能是一个新分数，也可能是我们在程序开始时读取的先前值。

            ### 学习训练

            1.  更改程序，只有在高分发生变化时才保存到高分文件。

            1.  通过在文本编辑器中打开高分文件并手动更改它来“黑客”高分文件。用您惊人的幸运连胜给朋友留下深刻印象！

        ## 练习 44：使用 for 循环计数

        正如您在以前的练习中看到的，`while`循环和 do-while 循环可以用来多次执行某些操作。

        ```java

        1 import java.util.Scanner; 2
        3 public class CountingFor 4 {
        ```

        ```java
        5
        6
        7
        8
        9
        10
        11
        12
        ```

        ```java
        public static void main( String[] args )
        {
        Scanner keyboard = new Scanner(System.in);
        ```

        ```java
        int n;
        String message;

        System.out.println( "Type in a message, and I'll display it five
        ```

        ```java
        times." ); 13
        14
        15
        16
        17
        18
        19
        20
        21
        ); 22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32
        ```

        ```java
        System.out.print( "Message: " ); message = keyboard.nextLine();
        ```

        ```java
        for ( n = 1 ; n <= 5 ; n++ )
        {
        System.out.println( n + ". " + message );
        }
        System.out.println( "\nNow I'll display it ten times and count by 5s." for ( n = 5 ; n <= 50 ; n += 5 )
        {
        System.out.println( n + ". " + message );
        }

        System.out.println( "\nFinally, three times counting backward." ); for ( n = 3 ; n > 0 ; n ­= 1 )
        {
        System.out.println( n + ". " + message );
        }
        ```

        ```java
        33 }
        34 }
        ```

        但是，这两种循环都设计成只要条件为真就继续进行。如果我们事先知道要做某事的次数，Java 有一种专门设计用于改变变量值的循环：`for`循环。

        ### 您应该看到的内容

        ```java

        Type in a message, and I'll display it five times. Message: Howdy, y'all!
        ```

        1.  ```java
            Howdy, y'all!
            ```

        1.  ```java
            Howdy, y'all!
            ```

        1.  ```java
            Howdy, y'all!
            ```

        1.  ```java
            Howdy, y'all!
            ```

        1.  ```java
            Howdy, y'all!
            ```

        ```java

        Now I'll display it ten times and count by 5s.
        5\. Howdy, y'all!
        10\. Howdy, y'all!
        15\. Howdy, y'all!
        20\. Howdy, y'all!
        25\. Howdy, y'all!
        ```

        ```java
        30\. Howdy, y'all!
        35\. Howdy, y'all!
        40\. Howdy, y'all!
        45\. Howdy, y'all!
        50\. Howdy, y'all!

        Finally, three times counting backward.
        3\. Howdy, y'all!
        2\. Howdy, y'all!
        1\. Howdy, y'all!
        ```

        第 16 行演示了一个非常基本的`for`循环。每个`for`循环都有三个部分，它们之间用分号分隔。

        第一部分（`n=1`）无论循环重复多少次，都只会发生一次。它发生在循环的最开始，并且通常为将要用于控制循环的某个变量设置一个起始值。在这种情况下，我们的“循环控制变量”是 n，它将以`1`的值开始。

        第二部分（`n <= 5`）是一个条件，就像`while`或 do-while 循环的条件一样。`for`循环是一个前测试循环，就像`while`循环一样，这意味着在循环开始之前会测试这个条件。如果条件为真，循环体将执行一次。如果条件为假，循环体将被跳过，循环结束。

        第三部分（`n++`）在每次循环迭代之后运行，就在再次检查条件之前。请记住，`++`会将变量加一。

        因此，如果我们*展开*这个循环，这些语句将会发生并按顺序执行：

        ```java

        n = 1;
        // check if ( n <= 5 ), which is true System.out.println( 1 + "." + message ); n++; // so now n is 2
        // check if ( n <= 5 ), which is true System.out.println( 2 + "." + message ); n++; // so now n is 3
        // check if ( n <= 5 ), which is true System.out.println( 3 + "." + message ); n++; // so now n is 4
        // check if ( n <= 5 ), which is true System.out.println( 4 + "." + message ); n++; // so now n is 5
        // check if ( n <= 5 ), which is true System.out.println( 5 + "." + message ); n++; // so now n is 6
        // check if ( n <= 6 ), which is false. The loop stops
        ```

        注意，第一部分只发生了一次，第三部分发生的次数正好与循环体发生的次数一样多。

        在第 22 行有另一个`for`循环。循环控制变量仍然是 n。（请注意，循环控制变量出现在循环的所有三个部分中。这几乎总是这种情况。）

        第一部分（“初始化表达式”）将循环控制变量设置为`5`。然后第二部分检查 n 是否小于或等于`50`。如果是，循环体将执行一次，然后执行第三部分。第三部分将`5`添加到循环控制变量中，然后再次检查条件。如果条件仍然为真，循环将重复。一旦条件为假，循环停止。

        在第 28 行有一个最后的`for`循环。这次循环控制变量从`3`开始，只要 n 大于零，循环就会重复。并且在循环体的每次迭代之后，第三部分（“更新表达式”）会从循环控制变量中减去`1`。

        那么何时应该使用`for`循环而不是`while`循环？

        当我们事先知道要做某事的次数时，最好使用`for`循环。

        +   做这件事十次。

        +   做这件事五次。

        +   选择一个随机数，并执行相应次数。

        +   拿这个物品清单，对列表中的每个物品执行一次。

            另一方面，`while`和 do-while 循环最适合在条件为真时重复执行：

        +   只要他们没有猜到，就继续进行。

        +   只要你没有得到对子，就继续进行。

        +   只要他们继续输入负数，就继续进行。

        +   只要他们没有输入零，就继续进行。

        ### 学习训练

        1. 从第三个循环中删除第一部分（“初始化表达式”）。如果您正确删除它，它仍将编译。当您运行它时会发生什么？

        ## 练习 45：凯撒密码（遍历字符串）

        凯撒密码是一种非常简单的密码学形式，以朱利叶斯·凯撒命名，他用它来保护他的私人信件。在密码中，每个字母都会按照字母表中的某个数量上下移动。例如，如果移位是`2`，那么消息中的所有`A`都会被替换为`C`，`B`被替换为`D`，依此类推。

        1 import java.util.Scanner; 2

        3 public class CaesarCipher

        4 {

        5

        /**

        6

        *返回移动了给定字母数的字符。

        7

        */

        8

        public static char shiftLetter(char c, int n)

        9

        {

        10

        int ch = c;

        11

        12

        if (!Character.isLetter(c))

        13

        返回 c;

        14

        15

        ch = ch + n;

        16

        if (Character.isUpperCase(c) && ch > 'Z' || Character.isLowerCase(c) && ch > 'z')

        17

        ch ­= 26;

        18

        if (Character.isUpperCase(c) && ch < 'A' || Character.isLowerCase(c) && ch < 'a')

        19

        ch += 26;

        20

        21

        return (char)ch;

        22

        }

        23

        24

        public static void main(String[] args)

        25

        {

        26

        Scanner keyboard = new Scanner(System.in);

        27

        String plaintext, cipher = "";

        28

        int shift;

        29

        30

        System.out.print("Message: ");

        31

        plaintext = keyboard.nextLine();

        32

        System.out.print("Shift (0­26): ");

        33

        shift = keyboard.nextInt();

        34

        35

        for (int i=0; i<plaintext.length(); i++)

        36

        {

        37

        cipher += shiftLetter(plaintext.charAt(i), shift);

        38

        }

        39

        System.out.println(cipher);

        40

        41

        }

        42

        }

        ### 你应该看到的

        ```java

        Message: This is a test. XyZaBcDeF Shift (0­26): 2
        Vjku ku c vguv. ZaBcDeFgH
        ```

        你知道`main()`不一定要是类中的第一个函数吗？好吧，它不是。函数可以以任何顺序出现。

        除了`int`，`double`，`String`和`boolean`之外，还有一种基本的变量类型我没有提到：`char`。`char`变量可以像`String`一样保存字符，但一次只能保存一个字符。代码中的字符串文字用双引号括起来，如`"Axe"`，而代码中的`char`文字用单引号括起来，如`'A'`。

        从第 8 行开始有一个名为`shiftLetter()`的函数。它有两个参数：c 是要移动的字符，n 是要移动的空格数。这个函数返回一个`char`。所以`shiftLetter('A', 2)`将返回字符`'C'`。

        我们不想尝试移动任何不是字母的东西，所以在第 10 行我们使用内置的 Character 类

        告诉我们。

        然后我们将对字符进行一些简单的数学运算，所以我们在第 13 行将字符的 Unicode 值存储到一个`int`中，以便更容易进行操作。然后在第 15 行，我们将所需的偏移量添加到字符上。

        这就是它，除了我们希望偏移“环绕”，所以第 16 到 19 行确保最终值仍然是一个字母。最后在第 21 行，我们取 ch 的值，将其转换为`char`，并返回它。

        在`main()`中，第 27 到 34 行非常无聊。在我解释`for`循环之前，我需要解释两个`String`类方法：`charAt()`和`length()`。

        如果你有一个`String`，你可以使用`charAt()`方法从中获取一个单独的`char`。就像这样：

        ```java

        String s = "Howdy"; char c = s.charAt(2);
        // Now c == 'w'
        // s.length() is 5
        ```

        `charAt()`是从零开始的，所以`s.charAt(0)`从字符串 s 中获取第一个字符。如果`s.length()`告诉你 s 中有多少个字符，那么`s.charAt(s.length()­1)`获取最后一个字符。

        现在我们可以理解第 36 行的`for`循环了。初始化表达式声明并设置了一个循环控制变量 i，将其设置为`0`。条件是只要 i 小于消息中的字符数。更新表达式将每次将`1`添加到 i。

        在第 38 行，发生了很多事情。我们使用`charAt`方法只提取消息的第 i 个字符。该字符和移位值作为参数传递给`shiftLetter()`函数，该函数返回移位后的字母。最后，该移位后的字母被添加到 String cipher 的末尾。

        当循环结束时，它已经逐个遍历了消息的每个字母，并从字母的移位版本中构建了一个新的消息。

        也许这一次太多了。让我知道。

        ### 学习演练

        1.  制作这个练习的新版本，从文本文件中获取消息，并创建一个“加密”文件，而不仅仅是在屏幕上打印它。

            ## 练习 46：嵌套 for 循环

            ```java

            1 public class NestingLoops 2 {
            ```

            ```java
            3
            4
            5
            6
            7
            8
            9
            10
            11
            12
            13
            14
            15
            16
            17
            18
            19
            20
            21
            22
            23
            24
            25
            26
            27
            28
            29 }
            ```

            ```java
            public static void main( String[] args )
            {
            // this is #1 ­ I'll call it "CN" for ( char c='A'; c <= 'E'; c++ )
            {
            for ( int n=1; n <= 3; n++ )
            {
            System.out.println( c + " " + n );
            }
            }
            ```

            ```java
            System.out.println("\n");

            // this is #2 ­ I'll call it "AB" for ( int a=1; a <= 3; a++ )
            {
            for ( int b=1; b <= 3; b++ )
            {
            System.out.print( "(" + a + "," + b + ") " );
            }
            // * You will add a line of code here.
            }

            System.out.println("\n");
            ```

            ```java
            }
            ```

            在编程中，“嵌套”一词通常意味着将某物放在同一物体内。“嵌套循环”将是两个循环，一个在另一个内部。如果你做对了，那么内部循环将在外部循环执行一次迭代时重复所有迭代。

            ### 你应该看到什么

            ```java

            A
            1
            A
            2
            A
            3
            B
            1
            B
            2
            B
            3
            C
            1
            C
            2
            C
            3
            D
            1
            D
            2
            D
            3
            E
            1
            E
            2
            E
            3
            (1,1) (1,2) (1,3)
            (2,1) (2,2) (2,3) (3,1) (3,2)
            (3,3)
            ```

            ### 学习演习

            1.  看看嵌套循环的第一组（“CN”）。哪个变量变化更快？是变量

                由外部循环（c）控制还是由内部循环（n）控制的变量？

            1.  更改循环的顺序，使“c”循环在内部，“n”循环在外部。输出如何改变？

            1.  看看第二组嵌套循环（“AB”）。将`print（）`语句更改为`println（）`。输出如何改变？（然后将其改回`print（）`。）

            1.  在内部循环（“b”循环）的关闭大括号后添加一个`System.out.println（）`语句，但仍在外部循环内。输出如何改变？

        ## 练习 47：生成和过滤值

        嵌套的`for`循环有时很方便，因为它们非常紧凑，可以使一些变量通过许多不同的值组合进行更改。

        多年前，一名学生向我提出了以下数学问题：

        “布朗农场主想要花费 100.00 美元，并且想要购买确切的 100 只动物。如果每只羊的成本为 10 美元，每只山羊的成本为 3.50 美元，每只鸡的成本为 0.50 美元，那么他应该购买多少只动物？”

        他离开后，我想了几秒钟，然后写了以下程序。

        ```java

        1 public class FarmerBrown 2 {
        3  public static void main( String[] args ) 4 {
        5    for ( int s = 1 ; s <= 100 ; s++ )
        6    {
        7      for ( int g = 1 ; g <= 100 ; g++ )
        8      {
        9        for ( int c = 1 ; c <= 100 ; c++ )
        10        {
        11          if ( s+g+c == 100 && 10.00*s + 3.50*g + 0.50*c == 100.00 )
        12         {
        ```

        1.  ```java
            System.out.print( s + " sheep, " );
            ```

        1.  ```java
            System.out.print( g + " goats, and " );
            ```

        1.  ```java
            System.out.println( c + " chickens." ); 16         }
            ```

        ```java
        17        }
        18      }
        19    }
        20 }
        21 }
        ```

        ### 你应该看到什么

        ```java

        4 sheep, 4 goats, and 92 chickens.
        ```

        这个程序很整洁，因为它非常简短。但是，坐在最内部循环内（在第 11 行的`if`语句前面）的观察者将看到一百万种不同的 s、g 和 c 组合。尝试的第一个组合将是 1 只羊，1 只山羊，1 只鸡。这将被插入到`if`语句中的数学方程式中。它们不会是真的，也不会打印任何东西。

        然后下一个组合将是 1 只羊，1 只山羊和 2 只鸡。这也会失败。然后是 1 只羊，1 只山羊，3 只鸡。等等，直到 1 只羊，1 只山羊和 100 只鸡，当内部循环运行最后一次迭代时。

        然后，第 7 行的`g ++`将执行，第 7 行的条件将检查 g 是否仍然小于或等于 100（是的），并且中间`for`循环的主体将再次执行。

        这将导致最内层循环的初始化表达式再次运行，将 c 重置为 1。因此，在`if`语句中将测试的下一个变量组合是 1 只羊，2 只山羊和 1 只鸡。然后是 1 只羊，2 只山羊，2 只鸡，然后是 1 只羊，2 只山羊，3 只鸡。依此类推。

        到最后，所有 100 * 100 * 100 种组合都经过了测试，其中 999,999 种失败了。但是因为计算机非常快，答案立即出现。

        由于在`if`的主体中只有一行代码时，Java 中的大括号是可选的

        1 public class FarmerBrownCompact 2 {

        3

        4

        5

        6

        7

        8

        9

        public static void main（String[] args）

        {

        对于（int s = 1; s <= 100; s ++）

        对于（int g = 1; g <= 100; g ++）

        对于（int c = 1; c <= 100; c ++）

        如果（s + g + c == 100 && 10.00 * s + 3.50 * g + 0.50 * c == 100.00）

        System.out.println（s +“只羊，”+ g +“只山羊和”+ c +“只

        小鸡。“）; 10 }

        11 }

        在`if`的主体或`for`循环的主体中，我可以使代码更加紧凑：

        这是完全合法的，并且与以前的版本行为完全相同。将其与我们使用`while`循环而不是`for`循环解决此程序时需要编写多少代码进行比较：

        ```java

        1 public class FarmerBrownWhile 2 {
        3  public static void main( String[] args ) 4 {
        5    int s = 1;
        6    while ( s <= 100 )
        7    {
        8      int g = 1;
        9      while ( g <= 100 )
        10      {
        11        int c = 1;
        12        while ( c <= 100 )
        13        {
        14          if ( s+g+c == 100 && 10.00*s + 3.50*g + 0.50*c == 100.00 )
        15         {
        ```

        1.  ```java
            System.out.print( s + " sheep, " );
            ```

        1.  ```java
            System.out.print( g + " goats, and " );
            ```

        1.  ```java
            System.out.println( c + " chickens." ); 19         }
            ```

        ```java
        20         c++;
        21        }
        22        g++;
        23      }
        24      s++;
        25    }
        26 }
        27 }
        ```

        `while`循环版本也更加脆弱，因为很容易忘记将变量重置为`1`或在循环体的末尾递增它。使用`while`循环可能更容易编译，但更有可能出现细微的逻辑错误，编译后却不能按预期工作。

        ### 学习练习

        1.我们的代码可以运行，但不够高效。（例如，没有理由让“sheep”循环尝试 11 只或 12 只或更多的羊，因为我们买不起。看看你是否可以改变循环边界，使组合更少浪费。

        ## 练习 48：数组-单个变量中的多个值

        在这个练习中，你将学到两件新事物。第一件事*非常*重要，第二件事只是有点有趣。

        ```java

        1 public class ArrayIntro 2 {
        3  public static void main( String[] args ) 4 {
        5  String[] planets = { "Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune" };
        ```

        ```java
        6
        7
        8
        9
        10
        11
        12 }
        ```

        ```java
        for ( String p : planets )
        {
        System.out.println( p + "\t" + p.toUpperCase() );
        }
        ```

        ```java
        }
        ```

        在 Java 中，“数组”是一种类型的变量，它有一个名称（“标识符”），但包含多个变量。在我看来，只有当你能够处理数组时，你才能成为一个真正的程序员。所以，这是个好消息。你快要成功了！

        ### 你应该看到的内容

        ```java

        Mercury MERCURY Venus VENUS
        Earth EARTH
        Mars MARS Jupiter JUPITER Saturn SATURN Uranus URANUS Neptune NEPTUNE
        ```

        在第 5 行，我们声明并定义了一个名为*planets*的变量。它不仅仅是一个字符串：注意方括号。这个变量是一个字符串数组。这意味着这个变量包含了所有八个字符串，并且它们被分成不同的槽，所以我们可以逐个访问它们。

        这一行上的花括号用于不同于通常的目的。所有这些值都在引号中，因为它们是字符串。每个值之间有逗号，然后整个初始化列表在花括号中。最后有一个分号。

        这个练习中的第二个新东西是一种新的`for`循环。（有时被称为`foreach`循环，因为它有点像另一种编程语言中的循环，那里的关键字实际上是`foreach`而不是`for`。）

        在第 7 行，你将看到这个 foreach 循环在运行。你可以这样大声朗读：“对于数组‘planets’中的每个字符串‘p’……”

        因此，在这个 foreach 循环的循环体内，字符串变量 p 将获得字符串数组 planets 中每个值的副本。也就是说，第一次循环时，p 将包含数组中的第一个值（`"Mercury"`）的副本。然后第二次循环时，p 将包含数组中的第二个值（`"Venus"`）的副本。依此类推，直到数组中的所有值都被看到。然后循环将自动停止。

        在循环体内（第 9 行），我们只是打印出*p*的当前值和*p*的大写版本。可能只是为了好玩。

        这种新的`for`循环只适用于像这样的复合变量：只有一个名称的变量。

        但包含多个值。数组不是 Java 中唯一的复合变量，但我们在本书中不会研究其他任何复合变量。

        数组很重要，所以这就够了。在给你增加更多内容之前，我想要*绝对确定*你理解了这个任务中发生的事情。

        ## 练习 49：在数组中查找东西

        ```java

        1 import java.util.Scanner; 2
        3 public class ArrayLinearSearch 4 {
        5  public static void main( String[] args ) 6 {
        7    Scanner keyboard = new Scanner(System.in); 8
        ```

        ```java
        9
        271828 };
        10
        11
        ```

        ```java
        int[] orderNumbers = { 12345, 54321, 78753, 101010, 8675309, 31415,
        ```

        ```java
        int toFind;
        ```

        ```java
        12    System.out.println("There are " + orderNumbers.length + " orders in the database.");
        ```

        ```java
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32 }
        ```

        ```java
        System.out.print("Orders: "); for ( int num : orderNumbers )
        {
        System.out.print( num + " " );
        }
        System.out.println();
        ```

        ```java
        System.out.print( "Which order to find? " ); toFind = keyboard.nextInt();

        for ( int num : orderNumbers )
        {
        if ( num == toFind )
        {
        System.out.println( num + " found.");
        }
        }
        ```

        ```java
        }
        ```

        更多关于数组的内容！在这个练习中，我们将研究如何找到特定的值。我们在这里使用的技术有时被称为“线性搜索”，因为它从数组的第一个槽开始查找，然后移动到第二个槽，然后是第三个，依此类推。

        ### 你应该看到的内容

        ```java

        There are 7 orders in the database.
        Orders: 12345 54321 78753 101010 8675309 31415 271828
        Which order to find? 78753 78753 found.
        ```

        这次数组的名称是 orderNumbers，它是一个整数数组。它有七个槽。`12345`是第一个槽，`271828`在数组的最后一个槽。这七个槽中的每一个都可以容纳一个整数。

        当我们创建一个数组时，Java 会给我们一个内置变量，告诉我们数组的容量。这个变量是只读的（你可以检索它的值，但不能改变它），被称为`.length`。在这种情况下，由于数组 orderNumbers 有七个槽，变量`orderNumbers.length`等于`7`。这在第 12 行中使用。

        在第 15 行，我们有一个 foreach 循环，以在屏幕上显示所有订单号。 “对于数组`orderNumbers`中的每个整数‘num’...”。因此，在此循环的主体中，*num*将逐个接受数组中的每个值，并将它们全部显示出来。

        在第 22 行，我们让人类输入订单号。然后我们使用循环让*num*逐个接受每个

        订单号并将它们与*toFind*逐个比较。当我们找到匹配时，我们会这样说。

        （你必须想象我们的数据库中有数百或数千个订单，而不仅仅是七个，当我们找到匹配时，我们会打印出更多内容。我们很快就会到那里。）

        ### 学习演习

        1.  我们在两个 foreach 循环中都创建了一个名为 num 的`int`。我们是否可以只在第 10 行声明变量一次，然后从两个循环中删除`int`？试一试看看。

        1.  尝试更改代码，以便如果未找到订单号，则打印出一条单一消息。这很棘手。即使您没有成功，也要努力尝试，然后再进行下一个练习。

            ## 练习 50：说数组中没有某个东西

            在生活中，某些类型的陈述之间存在一般缺乏对称性。

            存在一只白色的乌鸦。

            这个陈述很容易证明。开始观察乌鸦。一旦找到一只白色的，就停下。完成。

            不存在白色的乌鸦。

            这个陈述*要难得多，因为要证明它，我们必须收集世界上所有符合乌鸦资格的东西。如果我们已经*全部*看过它们，却没有找到任何白色的乌鸦，那么我们才能安全地说*没有*存在。

            1 import java.util.Scanner; 2

            3 public class ItemNotFound 4 {

            5

            6

            7

            8

            9

            10

            11

            12

            13

            14

            15

            16

            17

            18

            19

            20

            21

            22

            23

            24

            25

            26

            27

            28

            29

            30

            31

            32

            33

            34

            35 }

            public static void main( String[] args )

            {

            Scanner keyboard = new Scanner(System.in);

            String[] heroes = {

            "阿布德鲁斯"，"阿喀琉斯"，"埃涅阿斯"，"阿贾克斯"，"安菲特里翁"，"贝勒福龙"，"卡斯特尔"，"克里西普"，"戴达罗斯"，"迪俄米德"，"埃琉西斯"，"尤诺斯图斯"，"盖尼米德"，"赫克托尔"，"伊阿索"，"贾森"，

            "梅勒阿格尔"，"奥德修斯"，"奥耳佩斯"，"佩尔修斯"，"忒修斯"}; String guess;

            boolean found;

            System.out.print( "小测验！说出希腊神话中的任何凡人英雄：" ); guess = keyboard.next();

            found = false;

            for ( String hero : heroes )

            {

            if ( guess.equals(hero) )

            {

            System.out.println( "那是正确的！" ); found = true;

            }

            }

            if ( found == false )

            {

            System.out.println( "不，" + guess + "不是希腊凡人英雄。" );

            }

            }

            希望您尝试了昨天练习中的学习演习。

            ### 你应该看到的

            ```java

            Pop Quiz! Name any mortal hero from Greek mythology: Hercules No, Hercules wasn't a Greek mortal hero.
            ```

            大多数学生希望通过在循环内部放置另一个`if`语句（或`else`）来解决这个问题，以表明“未找到”。但这是行不通的。如果我想知道是否找到了某物，那么一旦我找到它，就可以这样说。但是，如果我想知道某物从未被找到，您必须等到循环结束才能确定。

            所以在这种情况下，我使用了一种称为“标志”的技术。标志是一个以一个值开始的变量。如果发生了某事，该值将被更改。然后在程序的后面，您可以使用标志的值来查看是否发生了该事件。

            我的标志变量是一个名为 found 的布尔变量，在第 20 行设置为`false`。如果找到匹配，我们会这样做，并在第 26 行将标志更改为`true`。请注意，在循环内部没有可以将标志更改为`false`的代码，因此一旦它被翻转为`true`，它将保持不变。

            然后在第 30 行，在循环结束后，您可以检查标志。如果它仍然是`false`，那么我们知道

            循环内的`if`语句从未为真，因此我们从未找到我们要找的东西。

            ## 练习 51：没有 foreach 循环的数组

            正如您现在可能已经注意到的那样，数组和 foreach 循环被设计为很好地配合使用。但也有一些情况下，我们一直在做的事情不起作用。

            +   foreach 循环无法*向后*迭代数组；它只能向前。

            +   foreach 循环不能用来更改数组槽中的值。foreach 循环变量是数组中的一个只读副本，更改它不会改变数组。

                此外，我们一直在使用初始化列表（花括号的东西）将值放入数组中，这有其自身的局限性：

            +   初始化列表只在声明数组时有效；你不能在代码的其他地方使用它。

            +   初始化列表最适合相对较小的数组，如果数组中有 1000 个值，初始化列表就不好玩了。

            +   如果我们希望数组中的值来自文件或者我们在输入代码时没有的其他地方，初始化列表就帮不上忙了。

                ```java

                1 public class ArraySlotAccess 2 {
                ```

                ```java
                3
                4
                5
                6
                7
                8
                9
                10
                11
                ```

                ```java
                public static void main( String[] args )
                {
                int[] arr = new int[3]; int i;
                ```

                ```java
                arr[0] = 0;
                arr[1] = 0;
                arr[2] = 0;
                ```

                ```java
                12
                arr[2] ); 13
                14
                15
                16
                17
                18
                19
                20
                arr[2] ); 21
                22
                23
                24
                25
                26
                27
                28
                29
                30
                31
                32
                33
                34
                35
                36
                37
                ```

                ```java
                System.out.println("Array contains: " + arr[0] + " " + arr[1] + " " +
                ```

                ```java
                // Fill each slot of this array with a random number 1­100 arr[0] = 1 + (int)(Math.random()*100);
                arr[1] = 1 + (int)(Math.random()*100); arr[2] = 1 + (int)(Math.random()*100);

                // Display them again.
                System.out.println("Array contains: " + arr[0] + " " + arr[1] + " " +

                // This is a bit silly, but try to understand it. i = 0;
                arr[i] = 1 + (int)(Math.random()*100); i = 1;
                arr[i] = 1 + (int)(Math.random()*100); i = 2;
                arr[i] = 1 + (int)(Math.random()*100);

                // Display them again. System.out.print("Array contains: "); i = 0;
                System.out.print(arr[i] + " "); i = 1;
                System.out.print(arr[i] + " "); i = 2;
                System.out.print(arr[i] + " ");
                ```

                所以还有另一种方法可以存储数组中的值并访问它们。事实上，这种方法比你一直在做的更常见。使用方括号和槽号，我们可以单独访问数组的槽。

                ```java

                61
                for ( i=0 ; i < arr.length ; i++ )
                62
                {
                63
                arr[i] = 1 + (int)(Math.random()*100);
                64
                }
                65

                66
                // Display them again.
                67
                System.out.print("Array contains: ");
                68
                for ( i=0 ; i < arr.length ; i++ )
                69
                {
                70
                System.out.print(arr[i] + " ");
                71
                }
                72
                System.out.println();
                73  }
                74 }

                38
                39
                40
                headed? 41
                42
                43
                44
                45
                46
                47
                48
                49
                50
                51
                52
                53
                54
                55
                56
                57
                58
                59
                60
                ```

                ```java
                System.out.println();
                ```

                ```java
                // This is even more silly but it works. Can you guess where this is

                i = 0;
                arr[i] = 1 + (int)(Math.random()*100); i++;
                arr[i] = 1 + (int)(Math.random()*100); i++;
                arr[i] = 1 + (int)(Math.random()*100); i++;

                // Display them again. System.out.print("Array contains: "); i = 0;
                System.out.print(arr[i] + " "); i++;
                System.out.print(arr[i] + " "); i++;
                System.out.print(arr[i] + " "); i++;
                System.out.println();

                // Ah! Let's just use a regular 'for' loop!
                ```

                ### 你应该看到的

                ```java

                Array contains: 0 0 0
                Array contains: 98 49 18
                Array contains: 83 77 1
                Array contains: 62 74 32
                Array contains: 40 17 54
                ```

                在第 5 行，我们创建了一个整数数组，没有使用初始化列表。`[3]`表示数组的容量为 3。由于我们没有提供值，数组中的每个槽最初都存有值`0`。一旦数组被创建，它的容量就不能改变。

                在第 8 到 10 行有一个惊喜。数组有 3 个槽，但槽号是基于 0 的。（指代数组槽的数字称为“索引”。总体上应该称为“索引”（INN-duh-SEEZ），但大多数人只说“索引”）。

                所以数组中的第一个槽是索引`0`。这个数组可以容纳三个值，所以最后一个索引是`2`。除了习惯它，你无法做任何事情。所以`arr.length`是`3`，但没有一个槽的索引是`3`。这可能会在一开始给你带来 bug，但最终你会学会的。

                无论如何，第 8 到 10 行将值`0`存储到数组的所有三个槽中。（这个值已经在其中了，所以这段代码没有任何用处。）

                在第 12 行，我们打印出数组中所有三个当前值，这样你就可以看到它们都是零。

                在第 15 到 17 行，我们将随机数放入数组的每个槽中。然后在第 20 行再次打印出来。

                从第 22 行开始，我做了一些傻事。在练习结束之前，请不要下判断。

                不管你为什么要这样做，你看到第 24 行基本上与第 15 行相同吗？第 24 行将一个随机数存储到数组的一个位置。哪个位置？索引取决于 i 的当前值。而 i 当前是`0`。所以我们将随机数存储到索引为`0`的槽中。明白了吗？

                所以在第 25 行，我们将 i 的值从`0`改为`1`。然后在第 26 行，我们将一个随机值存储在由 i 的值索引的槽中，所以索引是`1`。明白了吗？奇怪，但合法。

                我在第 31 到 38 行使用了类似的花招来再次在屏幕上显示所有的值。现在，这显然比我在第 20 行做的要糟糕。我的意思是，我用了 8 行代码来做我之前用一行代码做的事情。（跟着我。）

                在第 40 到 47 行，我们做的事情甚至可能比第 22 到 28 行更糟糕。第 41 和 42 行是一样的，但在第 43 行，我没有直接将`1`放入 i，而是说“增加 i 的值 1”。所以 i 原来是`0`；在第 43 行之后它变成了`1`。

                这种方法的唯一优势几乎是复制和粘贴更容易。第 42 和 43 行*完全相同*于第 44 和 45 行。第 46 和 47 行也是如此。我的意思是，完全一样。

                我们以类似的愚蠢方式在第 50 到 58 行显示它们。

                但也许你会想到。“为什么我要连续三次输入完全相同的行，而不是……”你知道一种允许你重复一段代码的东西，同时使一个变量每次增加一个的东西，对吧？

                没错：`for`循环就是这样的。我一点都不傻，对吧？

                第 61 到 64 行与第 41 到 47 行相同，只是我们让`for`循环处理重复和索引的变化。`for`循环的初始化表达式（第一部分）将 i 设置为`0`，这恰好是数组的最小合法索引。条件说“只要 i 小于`arr.length`（即`3`）就重复这个操作。”请注意，这是小于，而不是小于或等于，那样就太多了。更新表达式（第三部分）每次只是将 i 加 1。

                第 67 到 72 行显示了屏幕上的值。

                事实上，这种代码在 61 到 72 行之间可能看起来有点复杂，但在 Java 中使用数组时，你会一直写这样的代码。我甚至无法告诉你我有多少次为了处理数组而写了一个像那样的`for`循环。

                实际上，如果你的问题是“我怎么才能一个数组？”（在空白处填入你喜欢的任何任务。）答案是“用`for`循环。”几乎可以肯定。

                ### 学习演习

                1. 在代码的顶部，将数组的容量改为 1000 而不是 3。不要改变任何其他代码，然后重新编译和运行。猜猜看？底部的那些`for`循环可能会更难写和理解，但一旦写好，它们对于 1000 个值和 3 个值一样有效。这很酷。

                ## 练习 52：最低温度

                在我们离开数组之前，这个练习将整合函数、循环、数组和从文件中读取数据，做一些（希望）有趣的事情！

                我已经创建了一个文本文件，其中包含了 1995 年 1 月 1 日至 2013 年 6 月 23 日德克萨斯州奥斯汀市的平均日温度。文件中有一些数据点丢失，所以文件中共有 6717 个温度。你可以在这里看到这些数字：

            +   http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt

        ```java

        4 public class LowestTemperature 5 {
        6  public static void main(String[] args) throws Exception 7 {
        ```

        [8 double[] temps = arrayFromUrl("http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt");](http://learnjavathehardway.org/txt/avg)

        ```java
        9
        10
        System.out.println( temps.length + " temperatures in database.");
        11

        12
        double lowest = 9999.99;
        13

        14
        for ( int i=0; i<temps.length; i++ )
        15
        {
        16
        if ( temps[i] < lowest )
        17
        {
        18
        lowest = temps[i];
        19
        }
        20
        }
        21

        25
        26  public static double[] arrayFromUrl( String url ) throws Exception 27 {
        31    double[] dubs = new double[count]; 32
        37   return dubs; 38 }
        39
        40  public static double fToC( double f ) 41 {
        42    return (f­32)*5/9;
        43 }
        44
        45 }
        ```

        1.  ```java
            import java.net.URL;
            ```

        1.  ```java
            import java.util.Scanner; 3
            ```

        1.  ```java
            System.out.print( "The lowest average daily temperature was " );
            ```

        1.  ```java
            System.out.println( lowest + "F (" + fToC(lowest) + "C)" ); 24 }
            ```

        1.  ```java
            Scanner fin = new Scanner((new URL(url)).openStream());
            ```

        1.  ```java
            int count = fin.nextInt(); 30
            ```

        1.  ```java
            for ( int i=0; i<dubs.length; i++ )
            ```

        1.  ```java
            dubs[i] = fin.nextDouble();
            ```

        1.  ```java
            fin.close(); 36
            ```

        这些值是以华氏度为单位。这个练习将把文件中的所有值（甚至直接从互联网上）读入一个`double`数组，然后使用循环来找到整个 17 年半范围内的最低温度。听起来有趣吗？让我们开始吧。

        ### 你应该看到的是

        ```java

        6717 temperatures in database.
        The lowest average daily temperature was 22.1F (­5.499999999999999C)
        ```

        （如果你必须在没有互联网访问权限的机器上运行这个程序，那么这段代码就行不通了。因为你已经知道如何从文本文件中读取数据，你可以自己修改它，让它从一个本地文件中读取（一个与你的代码在同一个文件夹中的文件，而不是在互联网上）。但如果你懒得动手，我在下面列出了一个备用版本。）

        嗯，一开始我就扔了一个曲线球。在第 8 行，我们声明了一个名为`double`的数组

        温度，但是不是像这样简单地设置它的容量：

        ```java

        double[] temps = new double[6717];
        ```

        ……我用一个函数的返回值初始化了数组！所以在继续之前，让我们看看函数。

        在第 26 行，函数定义开始。这个函数叫做`arrayFromUrl()`，它有一个参数：一个字符串。它返回什么？它返回的不是`double`，而是`double[]`（一个`double`数组）。

        在第 28 行，我们创建了一个 Scanner 对象来从文件中读取数据，但是我们并没有从文件中获取数据，而是从一个 URL 中获取信息。Java 的一个好处就是这只是一个微小的改变。

        现在，我用了一个我多年前学会的文本文件技巧。在我写这一章的时候，我的文件包含了 6717 个温度。但也许你是在一年后读到这篇文章，我想更新文件以添加更多的温度。所以文件的第一行只是一个数字：`6717`。然后在那之后，我有 6717 行温度，每行一个。

        在这段代码的第 29 行，我从文件中的第一行读取*count*。我使用该计数来决定第 31 行上我的数组应该有多大。所以，六个月后，如果我决定向文件中添加更多温度，我只需要更改文件的第一行，这段代码仍然可以工作。是不是一个不错的技巧？

        在第 31 行，我们定义了一个具有*count*槽的双精度数组。（目前为 6717。）

        在第 33 行，有一个`for`循环，它遍历数组中的每个槽，并且在第 34 行，我们每次从文件中读取一个`double`（`fin.nextDouble()`）并将其存储到数组中的下一个索引槽中。

        然后当循环结束时，我`close()`了文件。然后在第 37 行，数组从函数中返回，这个数组就是存储在`main()`的第 8 行的数组 temps 中的。

        在第 10 行，我们打印出数组的当前长度，以确保读取没有出错。

        在第 12 行，我们创建一个变量，最终将保存整个数组中的最低温度。起初，我们在那里放了一个非常大的值。

        第 14 行是另一个`for`循环，将给出数组中的所有合法索引。在这种情况下，由于数组中有 6717 个值，索引将从`0`到`6716`。

        第 16 行比较了我们当前在数组中查看的值（取决于当前值*i*）。如果该值小于*lowest*中的任何值，那么我们就有了一个新的记录！在第 18 行，我们用这个新的更小的值替换了以前在*lowest*中的值。

        循环会一直持续，直到数组中的所有值都被比较。当循环结束时，变量*lowest*现在实际上包含了最小的值。

        在第 40 到 43 行有一个小函数，用于将华氏度转换为摄氏度的温度。所以在第 23 行，我们显示了来自文件的最低温度，也转换为摄氏度。

        你可能会认为 22.1 华氏度（-5.5 摄氏度）不是非常寒冷的温度。好吧，这就是德克萨斯。还要记住，这些温度不是一天中最低的温度，它们是每天 24 小时温度样本的平均值。

        ### 学习演习

        1.  将代码更改为显示最低平均日温度和最高平均日温度。

        1.  尝试在网上找到另一个离你更近的城市的温度文件，并将你的代码更改为从该文件中读取！

        （我上面提到过，但这是修改后的代码，用于从本地文件中读取温度数据，以防你无法在具有互联网访问权限的计算机上运行 Java 程序。）

        ```java

        4 public class LowestTemperatureLocal
        5 {
        6

        public static void main(String[] args) throws Exception
        7

        {
        8

        double[] temps;
        9

        double lowest = 9999.99;
        10

        11

        // Read values from file
        12

        Scanner fin = new Scanner(new File("avg­daily­temps­atx.txt"));
        13

        temps = new double[fin.nextInt()];
        14

        15

        System.out.println( temps.length + " temperatures in database.");
        16

        17

        for ( int i=0; i<temps.length; i++ )
        18

        temps[i] = fin.nextDouble();
        19

        fin.close();
        20

        21

        for ( int i=0; i<temps.length; i++ )
        22

        if ( temps[i] < lowest )
        23

        lowest = temps[i];
        24

        25

        System.out.print( "The lowest average daily temperature was " );
        26

        System.out.println( lowest + "F (" + fToC(lowest) + "C)" );
        27

        }
        28

        29

        public static double fToC( double f ) { return (f­32)*5/9; }
        30
        }

        ```

        1.  ```java
            import java.io.File;
            ```

        1.  ```java
            import java.util.Scanner; 3
            ```

        ## 练习 53：邮寄地址（记录）

        今天的练习是关于我所谓的“记录”。在 C 和 C++编程语言中，它们被称为“结构”。数组是一个变量中的许多不同值，其中值都是*相同类型*的，并且它们由*索引*（槽号）区分。记录是一个变量中的几个不同值，但值可以是不同类型的，并且它们由*名称*（通常称为“字段”）区分。

        将以下代码输入到一个名为`MailingAddresses.java`的单个文件中。（第一行说

        ```java

        1 class Address 2 {
        ```

        1.  ```java
            String street;
            ```

        1.  ```java
            String city;
            ```

        1.  ```java
            String state;
            ```

        1.  ```java
            int zip; 7 }
            ```

        ```java
        8
        9 public class MailingAddresses 10 {
        ```

        ```java
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32
        33
        ```

        ```java
        public static void main(String[] args)
        {
        Address uno, dos, tres;
        ```

        ```java
        uno = new Address();
        uno.street = "191 Marigold Lane"; uno.city = "Miami";
        uno.state = "FL"; uno.zip  = 33179;

        dos = new Address(); dos.street = "3029 Losh Lane"; dos.city = "Crafton"; dos.state = "PA";
        dos.zip  = 15205;

        tres = new Address();
        tres.street = "2693 Hannah Street"; tres.city = "Hickory";
        tres.state = "NC"; tres.zip  = 28601;

        System.out.println(uno.street + "\n" + uno.city + ", " + uno.state + "
        ```

        ```java
        " + uno.zip + "\n");
        ```

        ```java
        34
        ```

        ```java
        System.out.println(dos.street + "\n" + dos.city + ", " + dos.state + "
        ```

        ```java
        " + dos.zip + "\n");
        ```

        ```java
        35
        ```

        ```java
        System.out.println(tres.street + "\n" + tres.city + ", " + tres.state
        ```

        ```java
        + " " + tres.zip + "\n"); 36 }
        37 }
        ```

        `class Address`是正确的，但你不能把你的文件命名为`Address.java`，否则它就不会工作。

        ### 你应该看到的是

        ```java

        191 Marigold Lane
        ```

        ![image](img/Image_069.png)

1.  这一切只有一个问题：Java 实际上并没有记录。事实证明，如果你创建一个没有方法，只有公共变量的嵌套类，它就像一个结构一样工作，即使它不是 Java 的方式。

我不在乎这是否是 Java 的方式。我已经教了很多学生，我坚信如果你不先理解记录，就很难理解面向对象的编程。

如果你不先理解记录，就很难理解面向对象的编程。所以我要以一种完全正常的方式伪造它们，这在许多不同的编程语言中都是非常好的代码。

一些顽固的面向对象的 Java 爱好者会偶然发现这个练习，并给我发送一封恶毒的电子邮件，说我做错了，为什么我要用谎言来填充这些可怜的孩子的头脑？哦，好吧。

```java
Miami, FL 33179

3029 Losh Lane
Crafton, PA 15205

2693 Hannah Street
Hickory, NC 28601
```

因此，在第 1 到 7 行，我们定义了一个名为`Address`的记录。

（我知道它说`class`，而不是`record`。如果我能做点什么，我发誓我会。无论如何，您应该将其称为`record`，或者如果您真的想要的话，称为“struct”。如果您将其称为`class`，它将使任何热爱面向对象编程的 Java 程序员感到困惑，如果您将其称为“struct”，至少 C 和 C++程序员会理解您。）

我们的记录有四个字段。 第一个字段是名为*street*的字符串。 第二个字段是称为

城市。等等。

然后在第 9 行开始我们的“真正”类。

在第 13 行，我们声明了三个名为 uno，dos 和 tres 的变量。 这些变量不是整数或字符串； 它们是记录。 类型为`Address`。 每个记录中都有四个字段。

在第 15 行，我们必须将一个 Address 对象存储在变量中，因为请记住，我们只声明了变量，它们还没有被初始化。

一旦处理好这些，您将看到我们可以将字符串`"191 Marigold Lane"`存储到

Address 记录名为 uno 的 street 字段，这正是我们在第 16 行所做的。 第 17 行将字符串`"Miami"`存储到记录 uno 的 city 字段中。

我不打算解释程序的其余部分发生了什么，因为我认为这是

非常清楚。 我想值得一提的是，尽管记录中的三个字段都是字符串，但*zip*字段是整数。 记录的字段可以是您想要的任何类型。

### 学习演练

1.  在第 13 行创建第四个 Address 变量，并更改代码以将*您的*邮寄地址放入其中。不要忘记在底部打印出来。

    ### 常见问题

    +   你从哪里得到这些地址的？

        我编造了它们。 我相当肯定这些街道在这些城市中并不存在。 如果我奇迹般地编造了一个真实地址，请告诉我，我会更改它。

        ## 练习 54：从文件中读取记录

        这个练习将向您展示如何从文本文件中读取记录的值。 还有一个示例，演示了一个循环，该循环会读取整个文件，无论文件有多长。

        如果你在一个没有连接到互联网的机器上运行这个程序，这段代码将无法正常工作，尽管更改非常小。 该代码访问此文件，如果需要，您可以下载该文件。

        +   http://learnjavathehardway.org/txt/s01e01­cast.txt

            ```java

            1 import java.util.Scanner; 2
            3 class Actor 4 {
            ```

            1.  ```java
                String name;
                ```

            1.  ```java
                String role;
                ```

            1.  ```java
                String birthdate; 8 }
                ```

            ```java
            9
            10 public class ActorList 11 {
            ```

            ```java
            12
            13
            14
            15
            16
            17
            18
            19
            20
            21
            22
            23
            24
            25
            26
            27
            28
            29
            30
            31
            32
            33
            34
            35
            36 }
            ```

            ```java
            public static void main(String[] args) throws Exception
            {
            ```

            [String url =](http://learnjavathehardway.org/txt/s01e01) ["http://learnjavathehardway.org/txt/s01e01­cast.txt";](http://learnjavathehardway.org/txt/s01e01)

            ```java
            // Scanner inFile = new Scanner(new java.io.File("s01e01­cast.txt")); Scanner inFile = new Scanner((new java.net.URL(url)).openStream());
            ```

            ```java
            while ( inFile.hasNext() )
            {
            Actor a = getActor(inFile);
            System.out.print(a.name + " was born on " + a.birthdate); System.out.println(" and played the role of " + a.role);
            }
            inFile.close();
            ```

            ```java
            }
            ```

            ```java
            public static Actor getActor( Scanner input )
            {
            Actor a = new Actor(); a.name = input.nextLine(); a.role = input.nextLine();
            a.birthdate = input.nextLine();
            ```

            ```java
            return a;
            ```

            ```java
            }
            ```

            将以下代码键入名为`ActorList.java`的单个文件中。（说`class` `Actor`的行是正确的，但您不能将文件命名为`Actor.java`，否则它将无法工作。）

            ### 你应该看到什么

            ```java

            Sean Bean was born on 1959­04­17 and played the role of Eddard 'Ned' Stark Mark Addy was born on 1964­01­14 and played the role of Robert Baratheon Nikolaj Coster­Waldau was born on 1970­07­27 and played the role of Jaime Lannister
            Michelle Fairley was born on 1964 and played the role of Catelyn Stark
            ```

            这次我们的记录称为`Actor`，有三个字段，所有字段都是字符串。

            在第 16 行，我们创建了一个与输入文本文件的互联网地址连接的 Scanner 对象。 您注意到我在顶部没有导入`java.net.URL`吗？ 只有在您想要能够输入类名的简短版本时，才需要导入类。

            在这种情况下，如果我在代码顶部导入了`java.net.URL`，我可以直接写：

            ```java

            Scanner inFile = new Scanner((new URL(url)).openStream());
            // instead of
            Scanner inFile = new Scanner((new java.net.URL(url)).openStream());
            ```

            有时，如果我只打算使用一个类一次，我宁愿在我的代码中使用完整的名称，而不是导入它。 我在第 15 行也使用了同样的技巧； 而不是导入`java.io.File`，我只是在这里使用了完整的类名。

            （如果您的机器没有互联网访问权限，请删除第 15 行开头的两个斜杠，这样它就不再是注释，然后在第 16 行开头*添加*两个斜杠*使*它成为注释。

            然后程序将在本地读取文件，而不是通过互联网读取。）

            无论您是从互联网还是从您自己的计算机打开文件，在第 17 行之后，我们都有一个名为*inFile*的 Scanner 对象，它连接到一个文本文件。

            当我们从文本文件中读取数据时，很多时候我们事先不知道它的长度。在最低温度练习中，我向你展示了一个处理这个问题的技巧：将项目数量存储为文件的第一行。但更常见的技术是我在这里使用的：只需使用一个循环，直到我们到达文件的末尾。

            Scanner 对象的`.hasNext()`方法将在尚未读取的数据时返回`true`。如果没有更多数据，则返回`false`。因此，在第 18 行，我们创建一个`while`循环，只要`.hasNext()`继续返回`true`，就会重复。

            在我们查看第 20 行之前，让我们跳到第 27 到 35 行，我在那里创建了一个函数，该函数将从文件中读取单个演员记录的所有数据。

            该函数名为 getActor。它有一个参数：一个 Scanner 对象！没错，你将一个已经打开的 Scanner 对象传递给函数，它会从中读取。getActor 函数返回一个`Actor`。它返回整个记录。

            如果我们要从函数中返回一个`Actor`对象，我们需要一个`Actor`类型的变量来返回，因此我们在第 29 行定义了一个。我只是称它为 a，因为在函数内部我们对这个变量的目的一无所知。您应该为变量提供良好的名称，但在这种情况下，像 a 这样的简短、无意义的名称是完全可以的。

            第 30 到 32 行读取文本文件中的三行并将它们存储到记录的三个字段中。然后函数完成了它的工作，我们将记录返回到`main()`中的第 20 行。

            为什么我们在`main()`中和函数中都要创建一个名为 a 的`Actor`变量？因为变量作用域。变量只在其所在的块中（也就是“可见”）。

            声明。不管变量是否从函数中“返回”，因为请记住，返回的不是变量本身，而是变量的*值*的副本。

            在`main()`的第 20 行声明（和定义）了一个名为 a 的`Actor`变量，但当第 23 行的闭合大括号出现时，该变量就超出了作用域。在`getActor()`函数的第 29 行声明（和定义）了另一个名为 a 的`Actor`变量，但当第 35 行的闭合大括号出现时，该变量也超出了作用域。

            好的，回到第 20 行。变量 a 的值来自函数`getActor()`的返回值。我们将打开的 Scanner 对象 inFile 作为函数的参数传递给它，它会返回一个填充了所有字段的`Actor`对象。

            （为什么参数称为*inFile*，而参数称为*input*？因为它们不是同一个变量。参数*input*在第 27 行声明，并从参数*inFile*获取值的副本。它们是两个具有相同值的不同变量。）

            经过所有这些，第 21 和 22 行非常无聊：它们只是显示记录的所有字段的值。在第 23 行，循环会再次重复检查条件：现在我们从文件中读取了另一条记录，文件是否仍然有更多？如果是，继续循环。如果不是，跳到第 24 行，关闭文件。

            请注意，在函数和`main()`中的`while`循环中，变量 a 一次只保存一个记录。我们从文件中读取所有记录并将它们全部打印在屏幕上，但当程序最后一次通过循环时，变量 a 只保存最近的记录。所有其他记录仍然在文件中，并且已经显示在屏幕上，但它们的值目前没有保存在任何变量中。

            我们可以修复这个问题，但要等到下一个练习。

            ## 练习 55：记录数组

            记录很棒，数组更好，但是当你把记录放入数组时，这个生活中几乎没有你不能编码的东西。

            ```java

            1
            class Student
            2
            {
            3
            String name;
            4
            int credits;
            5
            double gpa;
            6
            }
            7

            8
            public class StudentDatabase
            9
            {
            10

            public static void main( String[] args )
            11

            {
            12

            Student[] db;
            13

            db = new Student[3];
            14

            15

            db[0] = new Student();
            16

            db[0].name = "Esteban";
            17

            db[0].credits = 43;
            18

            db[0].gpa = 2.9;
            19

            20

            db[1] = new Student();
            21

            db[1].name = "Dave";
            22

            db[1].credits = 15;
            23

            db[1].gpa = 4.0;
            24

            25

            db[2] = new Student();
            26

            db[2].name = "Michelle";
            27

            db[2].credits = 132;
            28

            db[2].gpa = 3.72;
            29

            30

            for ( int i=0; i<db.length; i++ )
            31

            {
            32

            System.out.println("Name: " + db[i].name);
            33

            System.out.println("\tCredit hours: " + db[i].credits);
            34

            System.out.println("\tGPA: " + db[i].gpa + "\n");
            35

            }
            36

            37

            int max = 0;
            38

            for ( int i=1; i<db.length; i++ )
            39

            if ( db[i].gpa > db[max].gpa )
            40

            max = i;
            41

            42

            System.out.println(db[max].name + " has the highest GPA.");
            43

            }
            44
            }

            ```

            ### 你应该看到的

            ```java

            Name: Esteban
            Credit hours: 43
            GPA: 2.9

            Name: Dave
            Credit hours: 15
            GPA: 4.0

            Name: Michelle
            Credit hours: 132
            GPA: 3.72
            ```

            ```java

            Dave has the highest GPA.
            ```

            当你看到变量定义中某物的右侧有方括号时，那就是“某物的数组”。实际上，由于这本书快要结束了，也许我应该解释一下`public static` `void main`的业务。至少部分地。

            ```java

            public static void main( String[] args )
            ```

            这一行声明了一个名为 main 的函数。该函数需要一个参数：名为 args 的字符串数组（缩写为“arguments”）。该函数不返回任何值；它是`void`。

            无论如何。

            第 12 行声明了*db*作为一个可以容纳“学生数组”的变量。还没有数组，只是一个可能容纳数组的变量。就像我们说…

            ```java

            int n;
            ```

            …还没有整数。变量*n*可能容纳一个整数，但它里面还没有数字。*n*被声明但未定义。同样，一旦第 12 行执行完毕，*db*是一个*可能*指向学生数组的变量，但仍未定义。

            幸运的是，我们不必等太久；第 13 行通过创建一个实际的具有三个槽的学生数组来初始化 db。此时，db 被定义，`db.length`为`3`，db 有三个合法索引：`0`，`1`和`2`。

            好吧，在这一点上，*db*是一个学生记录的数组。除了它不是。*db*是一个学生*变量*的数组，每个变量都*可能*容纳一个学生记录，但没有一个变量是这样的。数组中的所有三个槽都未定义。

            （从技术上讲，它们包含值`null`，这是 Java 中引用变量在其中没有对象时具有的特殊值。）

            因此，在第 15 行，重要的是创建一个学生对象并将其存储到数组的第一个槽（索引`0`）中。然后在第 16 行，我们可以将一个值存储到数组 db 中索引`0`的学生记录的名字字段中。

            让我们从外到内追踪它：

            表达式

            类型

            描述

            db

            学生[]

            一组学生记录

            db[0]

            学生

            一个单独的学生记录（第一个）

            db[0].name

            字符串

            数组中第一个学生的*name*字段

            db.name

            错误

            整个数组没有一个名字字段

            因此，第 16 行将一个值存储到数组中第一个记录的*name*字段中。第 17 和 18 行将值存储到该记录中的其余字段中。第 20 到 28 行创建并填充数组中的其他两个记录

            尽管在第 30 到 34 行，我们使用循环在屏幕上显示所有的值。

            然后，第 37 到 42 行找到了 GPA 最高的学生。这值得更详细解释。在第 37 行，定义了一个名为 max 的`int`。但 max 不会保存最高 GPA 的值；它只会保存它的索引。

            所以当我把`0`放入 max 时，我的意思是“在代码的这一点上，就我所知，最高分的学生

            在槽`0`中。”这可能不是真的，但由于我们还没有查看数据库中的任何值，这是一个很好的起点。

            然后在第 38 行，我们设置循环来查看数组的每个槽。然而，请注意，循环从索引`1`（第二个槽）开始。为什么？

            因为 max 已经是`0`。所以如果 i 也从`0`开始，那么`if`语句将进行以下比较：

            ```java

            if ( db[0].gpa > db[0].gpa )
            ```

            …这是浪费。因此，通过从`1`开始，第一次循环时，`if`语句将进行以下比较：

            ```java

            if ( db[1].gpa > db[0].gpa )
            ```

            “如果戴夫的 GPA 大于埃斯特万的 GPA，则将 max 从`0`更改为 i（`1`）的当前值。”

            因此，当循环结束时，*max*包含具有最高 GPA 的记录的**索引**。这正是我们在第 42 行显示的内容。

            ### 学习演习

            1.  将数组的容量更改为`4`而不是 3。不改变任何其他内容，编译并运行程序。你明白为什么程序会崩溃吗？

            1.  现在添加一些代码，将值放入新学生的字段中。给这个新学生一个比“Dave”更高的 GPA，并确认代码正确地将他们标记为具有最高的 GPA。

            1.  更改代码，使其查找具有最少学分的人，而不是具有最高 GPA 的人。

## 练习 56：从文件中读取记录的数组（温度重访）

这个练习从互联网上的一个文件中填充了一个记录数组。到目前为止，您应该知道您是否需要下载此文件的副本，还是您的计算机可以直接从互联网上打开它。

+   http://learnjavathehardway.org/txt/avg­daily­temps­with­dates­atx.txt

与本书中迄今为止使用的所有其他文件不同，这个数据文件正是我从戴顿大学的平均日温度档案中下载的。这意味着三件事：

1.  文件的第一行没有数字告诉我们有多少记录。

1.  除了温度之外，每个记录还包括样本的月份、日期和年份。

1.  文件中有错误数据。特别是，“当数据不可用时，我们使用‘-99’作为无数据标志。”

```java

1 import java.util.Scanner; 2
3 class TemperatureSample 4 {
```

1.  ```java
    int month, day, year;
    ```

1.  ```java
    double temperature; 7 }
    ```

```java
8
9 public class TemperaturesByDate 10 {
11  public static void main(String[] args) throws Exception 12 {

```

```java
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
```

```java
Scanner inFile = new Scanner((new java.net.URL(url)).openStream());
```

```java
TemperatureSample[] tempDB = new TemperatureSample[10000]; int numRecords, i = 0;

while ( inFile.hasNextInt() && i < tempDB.length )
{
TemperatureSample e = new TemperatureSample(); e.month = inFile.nextInt();
e.day = inFile.nextInt(); e.year = inFile.nextInt();
e.temperature = inFile.nextDouble(); if ( e.temperature == ­99 )
continue; tempDB[i] = e; i++;
}
inFile.close(); numRecords = i;
System.out.println(numRecords + " daily temperatures loaded."); double total = 0, avg;
int count = 0;
for ( i=0; i<numRecords; i++ )
{
if ( tempDB[i].month == 11 )
{
total += tempDB[i].temperature;
```

因此，有些天的温度是-99。我们将不得不在代码中处理这个问题。

```java

43
44
45
46
47
48
49
```

```java
count++;
```

```java
}
```

```java
}
```

```java
avg = total / count;
avg = roundToOneDecimal(avg);
System.out.println("Average daily temperature over " + count + " days
```

```java
in November: " + avg);
```

```java
50
51
52
53
54
55
56 }
```

```java
}
```

```java
public static double roundToOneDecimal( double d )
{
return Math.round(d*10)/10.0;
}
```

### 你应该看到的是

```java

6717 daily temperatures loaded.
Average daily temperature over 540 days in November: 59.7
```

第 3 到 7 行声明了我们的记录，它将存储单个平均日温度值（一个

`double`），还有月份、日期和年份的字段。

第 16 行定义了一个记录数组。但是我们有一个问题。我们无法在不提供容量的情况下定义数组，而在看到文件中有多少记录之前，我们不知道需要多大的容量。这个问题有三种可能的解决方案：

1.  不要使用数组。使用其他东西，比如一个可以在添加条目时自动增长的数组。这实际上可能是正确的解决方案，但是“其他东西”超出了本书的范围。

1.  读取文件两次。首先只计算记录的数量，然后使用完美大小创建数组。然后再次读取文件将所有值读入数组。这样做很慢，但有效。

1.  不要担心使数组的大小合适。只需使其“足够大”。然后在读取它们时计算实际拥有的记录数量，并在任何循环中使用该计数，而不是数组的容量。这并不完美，但它有效且简单。编写软件有时需要妥协，这就是其中之一。

    因此，第 16 行声明了数组并定义为有一万个槽位：“足够大”。

    在第 19 行，我们开始一个循环，读取文件中的所有值。我们使用索引变量*i*来跟踪数组中下一个需要填充的槽位。因此，只要文件中还有更多整数，并且我们的数组容量还没有用完，我们的循环就会继续。

    仅仅因为我们通过使数组“足够大”来节省了一些步骤，并不意味着我们会对此感到愚蠢。如果文件最终比我们的数组容量大，我们希望尽早停止读取文件，而不是因为 ArrayIndexOutOfBounds 异常而使程序崩溃。

    21 行定义了一个名为*e*的 TemperatureSample 记录。22 到 25 行将文件中的下几个值加载到该记录的适当字段中。

    但是！请记住，我们的文件中有“缺失”的值。有些天的温度读数是

    `-99`，所以我们在第 26 行放置了一个`if`语句来检测它，然后将它们放入我们的数据库中。

    然后在第 27 行有一些新东西：Java 关键字`continue`。`continue`只能在循环体内合法。它的意思是“跳过循环体中剩余的代码行，然后返回顶部进行下一次迭代。”

    这实际上丢弃了当前（无效）记录，因为它跳过了第 28 和 29 行，这两行将当前记录存储在数组中的下一个可用槽位中，然后增加索引。

    有些人不喜欢使用`continue`，他们会这样写：

    ```java

    if ( e.temperature != ­99 )
    {
    tempDB[i] = e; i++;
    }
    ```

    这也完全没问题。只有当温度不是`-99`时，才将此条目放入数组中。我更喜欢使用`continue`，因为这样的代码对我来说更清晰，但是理智的人可能会有不同意见。选择对你来说最有意义的方式。

    一旦在第 31 行完成循环，我们确保关闭文件，然后将最终索引存储到 numRecords 中，以便我们可以在任何循环中使用它，而不是`tempDB.length`。毕竟，我们使数组比我们需要的大，最后的 3283 个槽（在这个例子中）是空的。仅循环到 numRecords 会更有效一些，我们可以通过这种方式避免检查任何无效的记录。

    在第 34 行，我们在屏幕上显示记录的数量，这可以帮助您查看是否在读取时出现了任何问题。

    第 36 至 45 行循环遍历所有我们的记录。任何月份字段为`11`（11 月）的记录都会被添加到一个运行总数中，我们也在此过程中计算匹配记录的总数。

    然后，当循环结束时，我们可以通过将总和除以计数来获得数据库中所有 11 月份每日温度的平均值。

    现在，我的程序的第一个版本的整体平均温度是`59.662962962963`。这不仅看起来不好，而且不正确：所有输入温度只精确到十分之一度。因此，显示具有十几个有效数字的结果看起来比实际更准确。

    因此，在第 52 至 55 行，您将找到一个小小的函数，用于将数字四舍五入到小数点后一位。据我所知，Java 没有内置的此功能，但它确实有一个内置的将数字四舍五入到最接近的整数的函数：`Math.round()`。所以我将数字乘以十，四舍五入，然后再除以十。也许有更好的方法，但我喜欢这样做。

    第 48 行将平均温度作为参数传递给我的函数，然后取舍返回值并将其存储为*avg*的新值。

    ### 学习训练

    1.  访问戴顿大学的温度档案，并下载一个附近城市的温度数据文件！让你的代码从该文件中读取数据。

    1.  更改代码以查找其他内容，比如二月份的最高温度或其他你感兴趣的内容。

    1.  尝试在屏幕上打印整个 TemperatureSample 记录。类似于这样：

```java

TemperatureSample ts = tempDB[0]; System.out.println( ts );
```

请注意，它不会打印像 ts.year 这样的整数或像`ts.temperature`这样的双精度；它试图在屏幕上显示整个记录。编译并运行文件。屏幕上显示了什么？

尝试更改索引以从数组中提取不同的值，并查看它如何改变打印出来的内容。

## 练习 57：一副扑克牌

在这本书结束之前，我需要向你展示如何使用记录数组来模拟一副扑克牌。

1 类卡片 2 {

1.  int value;

1.  String suit;

1.  String name;

6

7 public String toString() 8 {

9 返回名称+ "of"+ suit; 10 }

11 }

12

13 public class PickACard 14 {

15 public static void main（String[] args）16 {

1.  Card[] deck = buildDeck();

1.  // displayDeck(deck); 19

1.  int chosen =（int）（Math.random（）* deck.length）;

1.  Card picked = deck[chosen]; 22

1.  System.out.println("你从牌组中挑选了" + picked + "。");

1.  System.out.println("在二十一点中，你的牌值为" + picked.value + "

点。");

25

}

26

27

public static Card[] buildDeck（）

28

{

29

String[] suits = { "clubs", "diamonds", "hearts", "spades" };

30

String[] names = { "ZERO", "ONE", "two", "three", "four", "five", "six",

31

"seven", "eight", "nine", "ten", "Jack", "Queen", "King", "Ace" };

32

33

int i = 0;

34

Card[] deck = new Card[52];

35

36

对于（String s：suits）

37

{

38

对于（int v = 2; v <= 14; v ++）

39

{

40

Card c = new Card();

41

c.suit = s;

42

c.name = names[v];

43

如果（v == 14）

44

c.value = 11;

45

否则，如果（v > 10）

46

c.value = 10;

47

否则

48

c.value = v;

49

50

deck[i] = c;

51

i++;

52

}

53

}

54

返回牌组;

55

}

56

57

public static void displayDeck（Card[] deck）

58

{

59

对于（Card c：deck）

60

System.out.println(c.value + "\t" + c);

61

}

62

}

### 你应该看到的

```java

You picked a seven of hearts out of the deck. In Blackjack your card is worth 7 points.
```

当然，即使这几乎是最后一个练习，我也忍不住加入了一些新东西。你想学点新东西，不是吗？

首先，我在记录中偷偷加了一个函数。（实际上，因为这个函数在一个类中，它不是一个函数，而是一个“方法”。）

这个方法被命名为 toString。它没有参数，并返回一个`String`。在这个方法的主体中，我们通过连接名称字段、花色字段和单词“of”来创建一个字符串。这个方法不需要任何参数，因为它可以访问记录的字段。（事实上，这就是它成为“方法”而不是“函数”的原因。）

否则，`Card`记录应该是你期望的：它有卡的值（2-11）、花色名称和卡本身的名称的字段。

在第 17 到 24 行，你可以看到`main()`，它真的很短。第 17 行声明了一个卡片数组，并使用`buildDeck()`函数的返回值进行初始化。

第 18 行被注释掉了，但当我最初编写这个程序时，我使用了`displayDeck()`

确保`buildDeck()`函数是否正常工作。

第 20 行选择了一个介于`0`和`deck.length - 1`之间的随机数。你可能会注意到这恰好是数组中合法索引的范围，这不是巧合。

实际上，你也可以说第 20 行选择了数组中的一个随机索引，或者第 20 行随机选择了数组的一个槽位。

然后在第 21 行，我们声明了一个新的 Card 变量*picked*，并给它一个从数组中随机选择的值。

第 23 行看起来相当无聊，但实际上发生了魔法。*picked*是什么类型的变量？它是一张卡。通常当你尝试像这样在屏幕上打印整个记录时，Java 不知道你想要打印哪些字段或以什么顺序打印，所以它只是在屏幕上打印垃圾。（你在上一个练习的学习中看到了吧？）

但是，如果你在记录中提供了一个名为`toString()`的方法，它返回一个`String`并且没有参数，那么在这种情况下，Java 将在幕后调用该方法。它将获取返回值并打印出来，而不是垃圾。

因此，第 23 行将在屏幕上打印出运行所选卡的`toString()`方法的结果。相比之下，第 24 行确实很无聊。它打印出所选卡的值字段。

在我们开始`buildDeck()`，这是这个练习中最复杂的部分之前，让我们跳到`displayDeck()`函数。`displayDeck()`期望你传入一个`Card`数组作为参数。

然后在第 59 行，我们看到了一些我们在前几个练习中没有见过的东西：一个 foreach 循环。这表示“对于牌组中的每张卡……”由于这个`for`循环的主体中只有一行代码，我省略了花括号。

第 60 行显示了当前卡片的值，一个制表符，然后调用`toString()`的结果。

代表 Card *c*的方法。

好吧，让我们来解决这个`buildDeck()`函数。`buildDeck()`不需要任何参数，因为它只是从无中创建牌组。不过它确实返回一个值：一组卡片。

在第 29 到 31 行，我们创建了两个字符串数组。第一个（第 29 行）包含了花色的名称。第二个包含了卡片的名称。

你可能会注意到我有一张叫做`"ZERO"`的卡片，另一张叫做`"ONE"`的卡片。为什么？这是为了我可以把这个数组当作“查找表”来使用。我将写我的循环，使得我的卡片值从`2`到`14`，我希望单词`"two"`在这个数组中的索引是`2`。所以我需要把一些字符串放到槽位`0`和`1`中来占用空间。

最初我只是放了两个空字符串，如下所示：

```java

String[] names = { "", "", "two", "three", "four", "five", "six",
```

...但后来我担心如果我的代码有 bug，那么很难判断是没有打印任何内容还是`names[0]`（或`names[1]`）的值。因此，我为这两个索引放入了单词，但将它们全部大写，这样如果它们被打印出来，我就会注意到。

在第 33 行，我们创建了 i，它将跟踪下一个需要放入卡片的索引。第 34 行定义了我们的 52 张卡片的数组（从 0 到 51 索引）。

第 36 行是另一个 foreach 循环。变量 s 将被设置为`"clubs"`，然后

“方块”，然后“红心”，最后“黑桃”。

第 38 行是另一个`for`循环，但这个循环是嵌套的。记住这意味着这个循环将进行

在外部循环改变 s 的值之前，v 会从 2 到 14 变化。

第 40 行定义了一个名为 c 的 Card。在第 41 行，我们将这张卡的花色字段设置为当前 s 中的任何值（一开始是`"clubs"`）。

根据循环的次数，v 将是 2 到 14 之间的某个值，所以在第 42 行，我们使用 v 作为 names 数组的索引。也就是说，当 v 是 5 时，我们进入数组的第六个位置，那里会找到字符串`"five"`。我们将这个值的副本放入当前卡片的名称字段。

第 43 到 48 行将一个从 2 到 11 的整数存储到当前卡片的值字段中。我们需要 v 从 2 到 14 进行查找表，但现在已经完成了，我们需要确保没有卡片的值为 12 到 14。

第 14 张卡是 A，所以我们使用 11 作为卡的值。然后第 11、12 和 13 张卡是花牌，所以它们的卡值都是 10。其他卡的值都可以不变。

最后，我们将这张卡存储到*deck*的下一个可用槽中（用*i*索引），并使*i*增加 1。

当嵌套循环结束时，我们已经成功创建了标准牌组中的所有 52 张卡，并为它们赋予了与二十一点中使用方式相匹配的卡值。如果您想要确保，可以取消注释第 18 行上的`displayDeck()`调用。

`buildDeck()`的最后一步是`return`现在已经填满的 Cards 数组，这样它就可以存储到`main()`第 17 行的 deck 变量中。

### 学习练习

1.  添加一个名为`shuffleDeck()`的函数。它应该以一组卡片的数组作为参数，并返回一组卡片。一种洗牌的方法是从 0 到 51 选择两个随机数，并“交换”这些槽中的卡片。然后将该代码放入一个重复大约 1000 次的循环中。这有点难以做到正确。

## 练习 58：最终项目-文本冒险游戏

如果您已经完成了到目前为止的所有练习，那么您应该准备好进行这个最终项目了。它比您之前做过的任何练习都要长，但比最近几个练习并不难。

您的最终练习是基于文本的冒险游戏*引擎*。通过*引擎*，我的意思是代码对冒险本身一无所知；游戏的进行完全取决于文件中的内容。更改文件就会改变游戏的进行。

所以首先要下载游戏数据文件的副本，并将其保存到与您要放置代码的相同文件夹中。

+   [`learnjavathehardway.org/txt/text­adventure­rooms.txt`](http://learnjavathehardway.org/txt/text-adventure-rooms.txt)

```java

1
import java.util.Scanner;

3
class Room
4
{
5
int roomNumber;
6
String roomName;
7
String description;
8
int numExits;
9
String[] exits = new String[10];
10
int[] destinations = new int[10];
11
}
12

13
public class TextAdventureFinal
14
{
15
public static void main( String[] args )
16
{
17
Scanner keyboard = new Scanner(System.in);
18

19
// initialize rooms from file
20
Room[] rooms = loadRoomsFromFile("text­adventure­rooms.txt");
21

22
// showAllRooms(rooms); // for debugging
23

24
// Okay, so let's play the game!
25
int currentRoom = 0;
26
String ans;
27
while ( currentRoom >= 0 )
28
{
29
Room cur = rooms[currentRoom];
30
System.out.print( cur.description );
31
System.out.print("> ");
32
ans = keyboard.nextLine();
33

34
// See if what they typed matches any of our exit names
35
boolean found = false;
36
for ( int i=0; i<cur.numExits; i++ )
37
{
38
if ( cur.exits[i].equals(ans) )
39
{
40
found = true;
41
// if so, change our next room to that exit's room
number
42
currentRoom = cur.destinations[i];

43
}

44
}

45
if ( ! found )

46
System.out.println("Sorry, I don't understand.");

```

然后，最好开始打字。这是一个很长的练习，但我认为它会很值得。

```java

2
47

}
48

49
}

50

51  public static Room[] loadRoomsFromFile( String filename ) 52  {
```

1.  ```java
    Scanner file = null;
    ```

1.  ```java
    try
    ```

```java
55    {
56      file = new Scanner(new java.io.File(filename)); 57    }
58    catch ( java.io.IOException e )
59    {
```

1.  ```java
    System.err.println("Sorry, I can't read from the file '" + filename + "'.");
    ```

1.  ```java
    System.exit(1); 62    }
    ```

```java
63
```

1.  ```java
    int numRooms = file.nextInt();
    ```

1.  ```java
    Room[] rooms = new Room[numRooms]; 66
    ```

1.  ```java
    // initialize rooms from file
    ```

1.  ```java
    int roomNum = 0;
    ```

1.  ```java
    while ( file.hasNext() )
    ```

```java
70    {
```

1.  ```java
    Room r = getRoom(file);
    ```

1.  ```java
    if ( r.roomNumber != roomNum )
    ```

```java
73      {
```

1.  ```java
    System.err.println("Reading room # " + r.roomNumber + ", but " + roomNum + " was expected.");
    ```

1.  ```java
    System.exit(2);
    ```

```java
76      }
```

1.  ```java
    rooms[roomNum] = r;
    ```

1.  ```java
    roomNum++;
    ```

```java
79    }
80 file.close(); 81
82   return rooms; 83  }
84
85  public static void showAllRooms( Room[] rooms ) 86  {
87    for ( Room r : rooms )
88    {
```

1.  ```java
    String exitString = "";
    ```

1.  ```java
    for ( int i=0; i<r.numExits; i++ )
    ```

1.  ```java
    exitString += "\t" + r.exits[i] + " (" + r.destinations[i] + ")";
    ```

1.  ```java
    System.out.println( r.roomNumber + ") " + r.roomName + "\n" + exitString );
    ```

```java
93    }
94  }
95
96  public static Room getRoom( Scanner f ) 97  {
```

1.  ```java
    // any rooms left in the file?
    ```

1.  ```java
    if ( ! f.hasNextInt() )
    ```

1.  ```java
    return null;
    ```

```java
102
Room r = new Room();
103
String line;
104

105
// read in the room # for error­checking later
106
r.roomNumber = f.nextInt();
107
f.nextLine();  // skip "\n" after room #

108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139 }
```

```java
r.roomName = f.nextLine();

// read in the room's description r.description = "";
while ( true )
{
line = f.nextLine();
if ( line.equals("%%") ) break;
r.description += line + "\n";
}

// finally, we'll read in the exits int i = 0;
while ( true )
{
line = f.nextLine();
if ( line.equals("%%") ) break;
String[] parts = line.split(":"); r.exits[i] = parts[0];
r.destinations[i] = Integer.parseInt(parts[1]); i++;
}
r.numExits = i;

// should be done; return the Room return r;
```

```java
}
```

### 您应该看到的内容

```java

This is the parlor. It's a beautiful room.

There looks to be a kitchen to the "north". And there's a shadowy corridor to the "east".
```

+   ```java
    north
    There is a long countertop with dirty dishes everywhere. Off to one side there is, as you'd expect, a refrigerator. You may open the "refrigerator" or "go back".
    ```

+   ```java
    go back
    This is the parlor. It's a beautiful room.

    There looks to be a kitchen to the "north". And there's a shadowy corridor to the "east".
    ```

+   ```java
    east
    The corridor has led to a dark room. The moment you step inside, the door slams shut behind you. There is no handle on the interior of the door.

    There is no escaping. Type "quit" to die.
    ```

+   ```java
    quit
    ```

在我开始讨论代码之前，让我花点时间谈谈冒险游戏的“文件格式”。

游戏由几个“房间”组成。每个房间都有一个房间号和一个房间名称；这些只用于游戏引擎，玩家看不到。

每个房间还有一个描述和一个或多个“出口”，这是通往另一个房间的路径。

冒险游戏文件以一个数字开头：游戏中的位置（房间）的总数。之后是每个房间的记录。这是一个例子：

```java

1
KITCHEN
There is a long countertop with dirty dishes everywhere. Off to one side there is, as you'd expect, a refrigerator. You may open the "refrigerator" or "go back".
%%
fridge:3 refrigerator:3 go back:0 back:0
%%
```

这个记录的第一行是房间号，所以这是房间号 1。记录的第二行是房间名称，我们只用于调试。

从记录的第三行开始是房间的描述，一直到有一行只有`%%`的行为止。描述中允许有空行。

在第一个双百分号之后是一个出口列表。每一行都有出口的名称（玩家输入的内容）后跟一个冒号，再跟着出口通往的房间号。

例如，在这个房间，如果玩家输入`"fridge"`，游戏引擎将把他们从这个房间（房间＃1）移动到房间＃3。如果他们输入`"go back"`，他们将“旅行”到房间＃0。您可能会注意到，为了让玩家更容易决定输入什么，我在列表中有重复的出口。无论是`"fridge"`还是`"refrigerator"`都会把他们带到房间＃3。

出口列表以另一行只包含`%%`的行结束。这就是记录的结尾。

好的，现在让我们转向代码。第 3 到 11 行声明了一个房间的记录。您可以看到我们为冒险游戏文件中的每个字段都有字段。您可能没有猜到的唯一一件事是，出口字符串数组（出口）和目的地房间号数组（目的地）的任意容量为`10`，然后有一个 numExits 字段来跟踪这个房间实际上有多少出口。如果您认为一个房间需要超过 10 个出口，请随时将此容量增加。

进入`main()`，第 20 行声明了房间数组并从中初始化。

`loadRoomsFromFile()`函数，稍后我会解释。

第 22 行有一个注释掉的`showAllRooms()`函数调用，我用于调试。

在第 25 行，您将看到我们当前房间变量的定义，它保存了玩家所在房间的房间号。他们从房间`0`开始，这是文件中的第一个房间。在第 26 行是`String` ans 的声明，它将保存玩家输入的内容。

第 27 行是主游戏循环的开始。只要 currentRoom 变量为`0`或更多，它就会重复。因此，我们将使用它来停止游戏：当玩家死亡（或获胜）时，我们将 currentRoom 设置为`-1`。

数组 rooms 包含游戏中所有位置的列表。包含玩家的房间号的房间的变量 currentRoom 存储在变量中。因此，`rooms[currentRoom]`是整个房间的记录...嗯，当前房间。在第 29 行，我们将这个房间的副本存储到`Room`变量 cur 中。（我这样做只是因为我懒，想要输入像`cur.description`而不是`rooms[currentRoom].description`这样的东西。）

说到这一点，第 30 行打印出当前房间的描述，它存储在

描述字段。

在第 31 和 32 行，我们打印出一个小提示，并让玩家输入他们想去的地方的字符串。

第 36 到 44 行搜索这个房间的出口数组，看看它们是否与玩家输入的内容匹配。请记住，出口数组的容量为`10`，但实际上这个房间可能并没有那么多出口。因此，在`for`循环中，我们计数到 numExits 字段的值，而不是`10`。

如果我们找到与玩家命令匹配的出口，我们将标志设置为`true`（这样我们就知道如果他们最终输入了我们列表中没有的内容，我们应该抱怨）。然后，由于出口数组中的单词与目的地数组中的房间号相对应，我们从目的地数组的相应槽中取出房间号，并将其作为我们的新房间号。这样，当主游戏循环再次重复时，我们将自动前往新的房间。

在第 45 行，我们检查我们的标志。如果它仍然是`false`，这意味着用户输入了我们在出口列表中从未找到的东西。我们可以礼貌地抱怨。因为当前房间没有改变，所以在主游戏循环中再次循环将只是再次打印出他们已经在的房间的描述。

这就是主游戏循环的结束，也是`main()`的结束。剩下的就是从冒险游戏文件中实际填充房间数组。

第 51 行是`loadRoomsFromFile()`函数的开始，它以要打开的文件名作为参数，并返回一个`Room`数组。

（我决定在这个文件中不想有`throws Exception`，所以这里有一个 try-catch 块。它打开文件。

如果我们成功到达第 64 行，这意味着文件已成功打开。我们读取文件的第一行，告诉我们有多少个房间。然后第 65 行定义了一个具有适当容量的 Room 记录数组。

在第 68 行，我创建了一个名为 roomNum 的变量，它有双重作用。首先：它是房间数组中下一个可用槽的索引。但其次，它用于双重检查文件中的房间号和房间的槽号是否相同。如果不是，游戏数据文件中可能存在某种错误。如果我们在这里检测到这样的错误（在第 72 行），我们会抱怨并结束程序。（`System.exit()`结束程序，即使是在函数调用内部。）

第 69 行是“读取所有房间”的循环的开始。只要文件中还有未见过的内容，它就会继续进行。这里存在潜在的错误：如果数据文件顶部的房间数量是错误的，那么这个循环可能会在数组中走得太远并导致错误。（例如，如果文件的第一行说你只有 7 个房间，但实际上有 8 个房间记录，那么这个循环将重复太多次。）

在第 71 行，我们使用`getRoom()`函数读取单个房间记录，我稍后会解释。

第 72 到 76 行是我已经提到的房间号健全性检查，然后第 77 行只是将这个新房间存储到房间数组的下一个可用槽中。第 78 行增加了房间索引。

循环结束后，所有房间都已从文件中读取并存储在数组的各自位置。因此，在第 82 行，我们可以将房间数组返回到`main()`的第 20 行。

第 85 到 94 行是我用于调试的`showAllRooms()`函数。它只是在屏幕上显示数组中的所有房间，并且对于每个房间，它还显示所有的出口以及它们的目的地。

我们的最后一个函数是`getRoom()`，它期望传入一个 Scanner 对象作为参数，并返回一个单独的 Room 对象。

在第 99 和 100 行，如果数据文件格式不正确，会进行简单的健全性检查。如果下一个

如果文件中的东西不是整数，那么只需返回`null`（未初始化对象的值）。在这里放置一个`return`将立即从函数中返回，而不必运行剩下的代码。

在第 102 行定义了空房间对象。第 103 行创建了一个名为*line*的字符串，我用它来做一些不同的事情。

第 106 行从文件中读取房间号。房间号是房间记录的第一部分。这个函数的其余部分将只使用 Scanner 对象的`nextLine()`方法，而在`nextInt()`之后的`nextLine()`通常不起作用，因为它只读取刚刚读取的整数后面的行尾。

因此，第 107 行调用`nextLine()`方法，但不必在任何地方存储它的返回值，因为它不会读取任何值值得保存。

第 109 行从文件中读取房间名称。我们只在调试时使用这个。

在第 112 行，我们首先将这个房间的描述字段设置为空字符串。这样我们就可以在不出错的情况下添加内容。（就像我们在循环中将“总数”变量设置为`0`一样，然后再进行累加。）

好吧。我喜欢写无限循环。告我吧。第 113 行是一个无限循环的开始。这是因为我们不知道房间描述中会有多少行；它会一直持续，直到我们看到一行什么都没有的`%%`。还有其他方法可以做到这一点，但我喜欢“写一个无限循环，然后在找到你要找的东西时跳出它”的方法。就像我以前说过的，理智的人意见不一。

一旦我们进入“无限”循环，我们就会将描述的一行读入 line 变量中。然后，在第 116 行，我们检查刚刚读取的内容是否为`%%`。如果是的话，我们就不想将其添加到描述中，所以我们跳出循环。break 有点像 continue 的相反；continue 跳回到循环的条件，而 break 直接跳到末尾并停止循环。

如果我们仍然在第 118 行附近，这意味着我们读入了一行描述，而且它不是`%%`。所以我们使用+=将该行（和一个\n）添加到描述字段的末尾。然后循环重复。（无论如何。）

最终，我们希望碰到`%%`，循环就会停止。

第 122 行定义了 i，我用它来表示 exits 和 destinations 数组中我们要放入下一个值的槽的索引。然后从第 123 行开始又是一个无限循环。我使用了一个非常类似的方法来读取所有的出口。

第 125 行读取整行，这意味着该行包含类似于“'refrigerator:3'”的内容。（如果不是这样，而实际上是`%%`，则第 126 行和第 127 行停止循环。）

所以现在我们需要将这行分成两部分。幸运的是，String 类有一个名为 split()的内置方法。

line.split(":")在字符串 line 中搜索并在每次看到`:`（冒号）时将其分割开。然后它返回一个字符串数组。例如，如果 line 包含 thisXisXaXtest，那么 line.split("X")将返回一个包含{"this"，"is"，"a"，"test"}的数组。在我们的情况下，line 中只有一个冒号，所以它返回类似于{"refrigerator"，"3"}的内容。

因此，在第 128 行之后，parts[0]包含出口词（如“refrigerator”），parts[1]包含目的地房间号的字符串（如`"3"`）。这对我们来说不太适用，因为我们需要房间号是整数，而不是字符串。

对我们来说（再次），Java 的标准库来拯救我们。有一个内置函数可以将字符串转换为整数：Integer.parseInt()。我们在第 130 行使用了这个函数。

回想一下，i 是我们需要存储下一个值的出口数组中的槽的索引。因此，第 129 行将 parts[0]（出口的名称）存储到出口数组的适当槽中。第 130 行将 parts[1]（要移动到的房间号）从字符串转换为 int，并将其存储在目的地数组的相同槽中。然后第 131 行增加下一轮的出口索引。

最终我们会碰到`%%`，这个循环也会停止循环。然而，这里存在一个潜在的错误。出口数组只有十个槽。如果数据文件中有一个房间有超过十个出口，这个循环将继续超出数组的末端，并导致程序崩溃。所以不要这样做。

循环结束后，我们的索引 i 将包含我们读入的房间的真实数量。所以我们将其存储到第 133 行当前房间的 numExits 字段中。

然后就是这样了。房间中的所有字段都已经被赋值，我们返回这个 Room。

对象到`loadRoomsFromFile()`函数的第 71 行。

### 学习演练

1.  写你自己的文字冒险。如果你觉得它变得相当不错，就把它发给我！

1.  添加一个保存游戏的功能，这样玩家可以输入一些内容来停止游戏，游戏将把他们当前的房间号存储到一个文本文件中，然后在游戏重新开始时加载它。
