## 练习 27：编程游戏的五个简单规则

信息

这个练习旨在在你学习下一个练习时定期学习。你应该慢慢来，将其与其他解释混合在一起，直到最终理解。如果在这个练习中迷失了方向，休息一下，然后进行下一个练习。然后，如果在后面的练习中感到困惑，回来学习我在这里描述的细节。一直坚持下去，直到“豁然开朗”。记住，你不会失败，所以继续努力直到理解为止。

如果你玩围棋或国际象棋这样的游戏，你会知道规则相当简单，但它们所启用的游戏却极其复杂。真正好的游戏具有简单规则和复杂互动的独特品质。编程也是一个具有少量简单规则的游戏，这些规则创造了复杂的互动，在这个练习中，我们将学习这些规则是什么。

在我们做这个之前，我需要强调的是，当你编写代码时，你很可能不会直接使用这些规则。有些语言确实直接利用这些规则，你的 CPU 也使用它们，但在日常编程中你很少会使用它们。如果是这样，那么为什么要学习这些规则呢？

因为这些规则无处不在，理解它们将帮助你理解你编写的代码。当代码出错时，它将帮助你调试代码。如果你想知道代码是如何工作的，你将能够将其“分解”到基本规则，真正看到它是如何工作的。这些规则就像是一个秘密的*代码*。完全是故意的双关语。

我还要警告你**不要期望立即完全理解这一点**。把这个练习看作是为本模块中其余练习做准备。你应该深入研究这个练习，当遇到困难时，继续进行下一个练习作为休息。你应该在这个练习和下一个练习之间来回跳动，直到概念“豁然开朗”并开始变得有意义。你也应该尽可能深入地研究这些规则，但不要在这里卡住。挣扎几天，继续前进，回来，继续努力。只要你继续努力，你实际上不可能“失败”。

### 规则 1：一切都是一系列指令

所有程序都是一系列指令，告诉计算机做某事。当你输入这样的代码时，你已经看到 Python 在做这个了：

```py
1   x = 10
2   y = 20
3   z = x + y
```

这段代码从第 1 行开始，到第 2 行，依此类推直到结束。这是一系列指令，但在 Python 中，这三行被转换为另一系列指令，看起来像这样：

```py
 1   LOAD_CONST  0 (10) # load the number 10
 2   STORE_NAME  0 (x)  # store that in x
 3
 4   LOAD_CONST  1 (20) # load the number 20
 5   STORE_NAME  1 (y)  # store that in y
 6
 7   LOAD_NAME   0 (x)  # loads x (which is 10)
 8   LOAD_NAME   1 (y)  # loads y (which is 20)
 9   BINARY_ADD         # adds those
10   STORE_NAME  2 (z)  # store the result in z
```

这看起来与 Python 版本完全不同，但我*敢打赌*你可能能够猜出这一系列指令在做什么。我已经添加了注释来解释每个指令，你应该能够将其与之前的 Python 代码联系起来。

我不是在开玩笑。现在花点时间将 Python 代码的每一行与这个“字节码”的行联系起来。使用我提供的注释，我相信你可以弄清楚，这样做可能会在你的脑海中点亮一盏灯，让你更好地理解 Python 代码。

不需要记住这些指令，甚至不需要理解每一条指令。你应该意识到的是，你的 Python 代码被翻译成了一系列简单的指令，告诉计算机做什么。这个指令序列被称为“字节码”，因为它通常以一系列计算机理解的数字的形式存储在文件中。你在上面看到的输出通常被称为“汇编语言”，因为它是这些字节的人类“可读”（勉强）版本。

这些简单的指令从顶部开始处理，一次执行一个小操作，当程序退出时到达末尾。这就像你的 Python 代码，但语法更简单，是`INSTRUCTION OPTIONS`的形式。另一种看待这个问题的方式是，`x = 10`的每个部分可能会在这个“字节码”中成为自己的指令。

这是《编码游戏》的第一条规则：你写的每一行最终都会成为一系列字节，作为计算机的指令输入，告诉计算机应该做什么。

#### 我怎样才能得到这个输出？

要自己得到这个输出，你可以使用一个名为`[dis](https://docs.python.org/3/library/dis.xhtml)`的模块，它代表“disassemble”。这种代码传统上被称为“字节码”或“汇编语言”，所以`dis`的意思是“反汇编”。要使用`dis`，你可以导入它并像这样使用`dis()`函数：

```py
1   # import the dis function
2   from dis import dis
3
4   # pass code to dis() as a string
5   dis('''
6   x = 10
7   y = 20
8   z = x + y
9   ''')
```

在这个 Python 代码中，我正在做以下事情：

1.  我从`dis`模块中导入`dis()`函数

2.  我运行`dis()`函数，但使用`'''`给它一个多行字符串

3.  我接着将想要反汇编的 Python 代码写入这个多行字符串中

4.  最后，我用`''')`结束多行字符串和`dis()`函数

当你在 Jupyter 中运行这个代码时，你会看到它像我上面展示的那样输出字节码，但也许会有一些我们马上会讨论的额外内容。

#### 这些字节存储在哪里？

当你运行 Python（版本 3）时，这些字节会存储在一个名为`__pycache__`的目录中。如果你将这段代码放入一个名为`ex19.py`的文件中，然后用`python ex19.py`运行它，你应该会看到这个目录。

在这个目录中，你应该会看到一堆以`.pyc`结尾的文件，名称类似于生成它们的代码。这些`.pyc`文件包含了你编译后的 Python 代码的字节。

当你运行`dis()`时，你正在打印`.pyc`文件中数字的人类可读版本。

### 规则 2：跳转使序列变得非线性

像`LOAD_CONST 10`这样的一系列简单指令并不是很有用。耶！你可以加载数字 10！太棒了！代码开始变得有用的地方是当你添加“跳转”概念使这个序列*非线性*。让我们看一个新的 Python 代码片段：

```py
1   while True:
2       x = 10
```

要理解这段代码，我们必须预示一个稍后的练习，你将学习关于 `while-loop`。代码 `while True:` 简单地表示“在 `True` 为 `True` 时继续运行我的代码 `x = 10`。”由于 `True` 将始终为 `True`，这将永远循环。如果在 Jupyter 中运行，它永远不会结束。

当你 `dis()` 这段代码时会发生什么？你会看到新的指令 `JUMP_ABSOLUTE`：

```py
1   dis("while True: x = 10")
2
3        0 LOAD_CONST             1 (10)
4        2 STORE_NAME             0 (x)
5        4 JUMP_ABSOLUTE          0 (to 0)
```

当我们讨论 `x = 10` 代码时，你看到了前两个指令，但现在在结尾我们有 `JUMP_ABSOLUTE 0`。注意这些指令左边有数字 `0`、`2` 和 `4`？在之前的代码中我把它们剪掉了，这样你就不会被分心，但在这里它们很重要，因为它们代表每个指令所在位置的序列。所有 `JUMP_ABSOLUTE 0` 做的就是告诉 Python “跳转到位置 0 处的指令”，即 `LOAD_CONST 1 (10)`。

通过这个简单的指令，我们现在已经将无聊的直线代码转变成了一个更复杂的循环，不再是直线了。稍后我们将看到跳转如何与测试结合，允许更复杂的移动通过字节序列。

#### 为什么是反向的？

你可能已经注意到 Python 代码读起来像“当 True 为 True 时将 x 设置为 10”，但 `dis()` 输出更像是“将 x 设置为 10，跳转以再次执行”。这是因为规则 #1，它说我们只能生成一个 *字节序列*。不允许有嵌套结构，或任何比 `INSTRUCTION OPTIONS` 更复杂的语法。

为了遵循这个规则，Python 必须找出如何将其代码转换为产生所需输出的字节序列。这意味着将实际的重复部分移动到序列的末尾，以便它在一个序列中。当查看字节码和汇编语言时，你会经常发现这种“反向”的特性。

#### 一个 JUMP 能前进吗？

是的，技术上，JUMP 指令只是告诉计算机在序列中处理不同的指令。它可以是下一个，前一个，或未来的一个。这是计算机跟踪当前指令“索引”的方式，它简单地递增该索引。

当你 JUMP 时，你在告诉计算机将这个索引更改到代码中的一个新位置。在我们的 `while` 循环代码中（下面），`JUMP_ABSOLUTE` 在索引 `4` 处（看左边的 4）。运行后，索引会更改为 `0`，在那里是 `LOAD_CONST` 的位置，所以计算机再次运行该指令。这将永远循环。

```py
1        0 LOAD_CONST           1 (10)
2        2 STORE_NAME           0 (x)
3        4 JUMP_ABSOLUTE        0 (to 0)
```

### 规则 3：测试控制跳转

JUMP 对于循环很有用，但是如何做决策呢？编程中的一个常见问题是提出类似的问题：

“如果 x 大于 0，则将 y 设置为 10。”

如果我们用简单的 Python 代码写出来，可能会像这样：

```py
1   if x > 0:
2       y = 10
```

再次，这是预示你将来会学到的东西，但这足够简单可以理解：

1.  Python 将 *测试* `x` 是否大于 `>` 0

2.  如果是，那么 Python 将运行行 `y = 10`

3.  你看到那行缩进在`if x > 0:`下面了吗？这被称为“块”，Python 使用缩进来表示“这个缩进的代码是上面代码的一部分”

4.  如果`x`*不*大于`0`，那么 Python 将*跳过*`y = 10`行以跳过它

要使用我们的 Python 字节码来实现测试部分，我们需要一个实现测试部分的新指令。我们有 JUMP。我们有变量。我们只需要一种方法来*比较*两个东西，然后根据比较跳转。

让我们拿这段代码并用`dis()`来看看 Python 是如何做到这一点的：

```py
 1   dis('''
 2   x = 1
 3   if x > 0:
 4       y = 10
 5   ''')
 6
 7      0 LOAD_CONST          0 (1)     # load 1
 8      2 STORE_NAME          0 (x)     # x = 1
 9
10      4 LOAD_NAME           0 (x)     # load x
11      6 LOAD_CONST          1 (0)     # load 0
12      8 COMPARE_OP          4 (>)     # compare x > 0
13     10 POP_JUMP_IF_FALSE  10 (to 20) # jump if false
14
15     12 LOAD_CONST          2 (10)    # not false, load 10
16     14 STORE_NAME          1 (y)     # y = 10
17     16 LOAD_CONST          3 (None)  # done, load None
18     18 RETURN_VALUE                  # exit
19
20     # jump here if false
21     20 LOAD_CONST          3 (None)  # load none
22     22 RETURN_VALUE                  # exit
```

这段代码的关键部分是`COMPARE_OP`和`POP_JUMP_IF_FALSE`：

```py
1      4 LOAD_NAME          0 (x)     # load x
2      6 LOAD_CONST         1 (0)     # load 0
3      8 COMPARE_OP         4 (>)     # compare x > 0
4     10 POP_JUMP_IF_FALSE 10 (to 20) # jump if false
```

这段代码的作用是：

1.  使用`LOAD_NAME`加载`x`变量

2.  使用`LOAD_CONST`加载常量`0`

3.  使用`COMPARE_OP`，进行`>`比较并留下`True`或`False`结果供以后使用

4.  最后，`POP_JUMP_IF_FALSE`使`if x > 0`起作用。它“弹出”`True`或`False`值以获取它，如果读取到`False`，它将`JUMP`到指令 20

5.  这将跳过设置`y`的代码，如果比较结果是`False`，*但是*如果比较结果是`True`，那么 Python 将运行下一条指令，从而开始`y = 10`序列

花点时间仔细研究一下这个问题。如果你有打印机，尝试打印出来并手动设置`x`为不同的值，然后跟踪代码的运行过程。当你设置`x = -1`时会发生什么？

#### 你说的“pop”是什么意思？

在前面的代码中，我跳过了 Python 如何“弹出”值来读取它的部分，但它将其存储在一个称为“堆栈”的东西中。现在只需将其视为一个临时存储位置，你可以将值“推入”其中，然后将其“弹出”。在你的学习阶段，你真的不需要深入了解更多。只需了解其效果是获取最后一条指令的结果。

#### 等等，像`*COMPARE_OP*`这样的测试也在循环中使用吗？

是的，基于你现在所知道的，你可能可以立即弄清楚它是如何工作的。尝试编写一个`while-loop`，看看你是否可以根据你现在所知道的知识使其工作。如果你不能，不要担心，因为我们将在后续练习中涵盖这个内容。

### 规则 4：存储控制测试

在代码运行时，你需要一种方式来跟踪数据的变化，这通过“存储”来实现。通常这种存储是在计算机的内存中，你为存储在内存中的数据创建名称。当你编写这样的代码时，你一直在这样做：

```py
1   x = 10
2   y = 20
3   z = x + y
```

在前面的每一行中，我们都在创建一个新的数据片段并将其存储在内存中。我们还为这些内存片段赋予了名称`x`、`y`和`z`。然后我们可以使用这些名称从内存中“召回”这些值，这就是我们在`z = x + y`中所做的。我们只是从内存中召回`x`和`y`的值然后将它们相加。

这就是这个小规则的大部分内容，但这个小规则的重要部分是你几乎总是使用内存来控制测试。

当然，你可以编写这样的代码：

```py
1   if 1 < 2:
2       print("but...why?")
```

不过这是毫无意义的，因为它只是在一个毫无意义的测试之后运行第二行。`1`始终小于`2`，所以这是无用的。

当您使用变量进行测试以使测试基于计算动态化时，像`COMPARE_OP`这样的测试就会发挥作用。这就是为什么我认为这是“代码游戏”的一条规则，因为没有变量的代码实际上并不在玩游戏。

仔细回顾以前的示例，并确定在哪些地方使用`LOAD`指令加载值，以及使用`STORE`指令将值存储到内存中。

### 规则 5：输入/输出控制存储

“代码游戏”的最后一条规则是您的代码如何与外部世界互动。拥有变量很好，但一个只包含您在源文件中键入的数据的程序并不是很有用。您需要的是*输入*和*输出*。

输入是您从文件、键盘或网络等地方将数据输入到代码中的方式。在上一个模块中，您已经使用`open()`和`input()`来做到这一点。每次打开文件、读取内容并对其执行操作时，您都会访问输入。当您使用`input()`向用户提问时，您也使用了输入。

输出是如何保存或传输程序结果的。输出可以是通过`print()`输出到屏幕，通过`file.write()`输出到文件，甚至通过网络传输。

让我们对`input('Yes? ')`的简单使用运行`dis()`，看看它做了什么：

```py
1   from dis import dis
2   dis("input('Yes? ')")
3
4        0 LOAD_NAME            0 (input)
5        2 LOAD_CONST           0 ('Yes? ')
6        4 CALL_FUNCTION        1
7        6 RETURN_VALUE
```

你可以看到现在有一个新的指令`CALL_FUNCTION`，它实现了你在练习 18 中学到的函数调用。当 Python 看到`CALL_FUNCTION`时，它会找到用`LOAD_NAME`加载的函数，然后跳转到该函数以运行该函数的代码。函数如何工作背后有很多东西，但你可以将`CALL_FUNCTION`看作类似于`JUMP_ABSOLUTE`，但是跳转到指令中的一个命名位置。

### 将所有内容整合在一起

根据这五条规则，我们有以下代码游戏：

1.  您将数据作为程序的输入读取（规则＃5）

2.  您将这些数据存储在存储器中（变量）（规则＃4）

3.  您使用这些变量执行测试…（规则＃3）

4.  … 这样您就可以在各处跳转…（规则＃2）

5.  … 指令序列…（规则＃1）

6.  … 将数据转换为新变量（规则＃4）…

7.  … 然后将其写入输出以进行存储或显示（规则＃5）

尽管这看起来很简单，但这些小规则创造了非常复杂的软件。视频游戏是一个很好的例子，*非常*复杂的软件就是这样做的。视频游戏会读取您的控制器或键盘作为输入，更新控制场景中模型的变量，并使用高级指令将场景呈现到屏幕上作为输出。

现在花点时间回顾你已经完成的练习，看看你是否更好地理解它们。在你不理解的代码上使用`dis()`是否有帮助，还是更加困惑？如果有帮助，那就尝试在所有代码上使用它以获得新的见解。如果没有帮助，那就记住它以备以后使用。当你在练习 26 上这样做时，这将会特别有趣。

#### 字节码列表

随着你继续练习，我会让你在一些代码上运行`dis()`来分析它在做什么。你需要完整的 Python 字节码列表来学习，可以在[文档的末尾](https://docs.python.org/3/library/dis.xhtml#python-bytecode-instructions)找到`[dis()](https://docs.python.org/3/library/dis.xhtml#python-bytecode-instructions)`。

#### `dis()`是一个支线任务

后续练习将包含一些短小的部分，要求你在代码上运行`dis()`来研究字节码。这些部分是你教育过程中的“支线任务”。这意味着它们*不*是理解 Python 必不可少的，但如果你完成它们，可能会在以后有所帮助。如果它们太难了，那就跳过它们，继续进行课程的其他部分。

`dis()`最重要的一点是它直接让你了解*Python*认为你的代码在做什么。如果你对代码的工作原理感到困惑，或者只是好奇 Python 实际在做什么，这会对你有所帮助。
