- en: Learn Java
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Java
- en: the Hard Way
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 艰难的方式
- en: Graham Mitchell
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Graham Mitchell
- en: Version 20130720.004
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 版本20130720.004
- en: Copyright 2013 Graham Mitchell. All rights reserved. Version 20130720.004
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有2013年Graham Mitchell。保留所有权利。版本20130720.004
- en: 10 09 08 07 06 05 XYZABC 04 03 02 01
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 10 09 08 07 06 05 XYZABC 04 03 02 01
- en: Preface
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前言
- en: I have been teaching beginners how to code for over fifteen years. More than
    2,000 students have taken my classes and left knowing how to write simple programs
    that work. Some learned how to do only a little and others gained incredible skill
    over the course of just a few years.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经教了超过15年的初学者如何编码。超过2000名学生参加了我的课程，离开时知道如何编写简单的程序。有些人只学会了一点，而其他人在短短几年内获得了令人难以置信的技能。
- en: I believe that nearly anyone can teach a child prodigy how to code. “I taught
    my 9­year­old daughter to code, and she made her first Android app six weeks later!”
    If you are the child prodigy, this book is not written for you.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信几乎任何人都可以教一个天才孩子如何编码。“我教了我9岁的女儿编码，她6周后就做出了她的第一个安卓应用！”如果你是天才孩子，这本书不是为你写的。
- en: I have also come to believe that there is no substitute for writing small programs.
    So that’s what you will do in this book. You will type in small programs and run
    them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我也相信没有什么能替代编写小程序。这就是你在这本书中要做的。你将输入小程序并运行它们。
- en: “The best way to learn is to do.”
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: “学习的最佳方式是实践。”
- en: – P.R. Halmos
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '- P.R. Halmos'
- en: Contents
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录
- en: 'Preface: Learning by Doing'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前言：通过实践学习
- en: 'Introduction: The Challenge of Java as a First Language'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍：Java作为第一语言的挑战
- en: 'Exercise 0: The Setup'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习0：设置
- en: 'Exercise 1: An Important Message'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习1：重要信息
- en: 'Exercise 2: More Printing'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习2：更多打印
- en: 'Exercise 3: Printing Choices'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习3：打印选择
- en: 'Exercise 4: Escape Sequences and Comments'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习4：转义序列和注释
- en: 'Exercise 5: Saving Information in Variables'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习5：在变量中保存信息
- en: 'Exercise 6: Mathematical Operations'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习6：数学运算
- en: 'Exercise 7: Getting Input from a Human'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习7：从人类获取输入
- en: 'Exercise 8: Storing the Human’s Responses'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习8：存储人类的回答
- en: 'Exercise 9: Calculations with User Input'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习9：使用用户输入进行计算
- en: 'Exercise 10: Variables Only Hold Values'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习10：变量只能保存值
- en: 'Exercise 11: Variable Modification Shortcuts'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习11：变量修改快捷方式
- en: 'Exercise 12: Boolean Expressions (True or False)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习12：布尔表达式（真或假）
- en: 'Exercise 13: Comparing Strings'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习13：比较字符串
- en: 'Exercise 14: Compound Boolean Expressions (And, Or, Not)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习14：复合布尔表达式（与、或、非）
- en: 'Exercise 15: Making Decisions with If Statements'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习15：使用if语句做决定
- en: 'Exercise 16: More If Statements'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习16：更多的if语句
- en: 'Exercise 17: Otherwise (If Statements with Else)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习17：否则（带有else的if语句）
- en: 'Exercise 18: If Statements with Strings'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习18：带有字符串的if语句
- en: 'Exercise 19: Mutual Exclusion with Chains of If and Else'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习19：使用if和else进行互斥
- en: 'Exercise 20: More Chains of Ifs and Else'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习20：更多的if和else链
- en: 'Exercise 21: Nested If Statements'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习21：嵌套的if语句
- en: 'Exercise 22: Making Decisions with a Big Switch'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习22：使用大开关做决定
- en: 'Exercise 23: More String Comparisons'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习23：更多字符串比较
- en: 'Exercise 24: Choosing Numbers Randomly'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习24：随机选择数字
- en: 'Exercise 25: More Complex Random Numbers'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习25：更复杂的随机数
- en: 'Exercise 26: Repeating Yourself using a While Loop'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习26：使用while循环重复自己
- en: 'Exercise 27: A Number­Guessing Game'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习27：猜数字游戏
- en: 'Exercise 28: Infinite Loops'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习28：无限循环
- en: 'Exercise 29: Using Loops for Error­Checking'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习29：使用循环进行错误检查
- en: 'Exercise 30: Do­While Loops'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习30：do-while循环
- en: 'Exercise 31: Adding Values One at a Time'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习31：逐个添加值
- en: 'Exercise 32: Adding Values for a Dice Game'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习32：为骰子游戏添加值
- en: 'Exercise 33: The Dice Game Called ‘Pig’'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习33：名为“猪”的骰子游戏
- en: 'Exercise 34: Calling a Function'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习34：调用函数
- en: 'Exercise 35: Calling Functions to Draw a Flag'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习35：调用函数绘制旗帜
- en: 'Exercise 36: Displaying Dice with Functions'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习36：使用函数显示骰子
- en: 'Exercise 37: Returning a Value from a Function'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习37：从函数返回值
- en: 'Exercise 38: Areas of Shapes'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习38：形状的面积
- en: 'Exercise 39: Thirty Days Revisited with Javadoc'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习39：使用Javadoc重新访问30天
- en: 'Exercise 40: Importing Standard Libraries'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习40：导入标准库
- en: 'Exercise 41: Programs that Write to Files'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习41：写入文件的程序
- en: 'Exercise 42: Getting Data from a File'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习42：从文件中获取数据
- en: 'Exercise 43: Saving a High Score'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习43：保存高分
- en: 'Exercise 44: Counting with a For Loop'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习44：使用for循环计数
- en: 'Exercise 45: Caesar Cipher (Looping Through a String)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习45：凯撒密码（循环遍历字符串）
- en: 'Exercise 46: Nested For Loops'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习46：嵌套的for循环
- en: 'Exercise 47: Generating and Filtering Values'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习47：生成和过滤值
- en: 'Exercise 48: Arrays ­ Many Values in a Single Variable'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习48：数组-单个变量中的多个值
- en: 'Exercise 49: Finding Things in an Array'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习49：在数组中查找东西
- en: 'Exercise 50: Saying Something Is NOT in an Array'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习50：说某物不在数组中
- en: 'Exercise 51: Arrays Without Foreach Loops'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习51：没有foreach循环的数组
- en: 'Exercise 52: Lowest Temperature'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习52：最低温度
- en: 'Exercise 53: Mailing Addresses (Records)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习53：邮寄地址（记录）
- en: 'Exercise 54: Records from a File'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习54：来自文件的记录
- en: 'Exercise 55: An Array of Records'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习55：记录数组
- en: 'Exercise 56: Array of Records from a File (Temperatures Revisited)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习56：来自文件的记录数组（温度再访）
- en: 'Exercise 57: A Deck of Playing Cards'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习57：一副扑克牌
- en: 'Exercise 58: Final Project ­ Text Adventure Game'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习58：最终项目-文字冒险游戏
- en: 'Introduction: Java'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍：Java
- en: Java is not a language for beginners. I am convinced that most “beginner” Java
    books only work on people who already know how to code or who are prodigies.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java不是初学者的语言。我相信大多数“初学者”Java书籍只适用于已经懂得如何编码或者是天才的人。
- en: I can teach you Java, even if you have never programmed before and even if you
    are not a genius. But I am going to have to cheat a bit.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我可以教你Java，即使你以前从未编程过，甚至不是天才。但我可能会有点作弊。
- en: What I will teach you *is* Java. But it is not *all* of Java. I have to leave
    parts out because you’re not ready for them. If you think you *are* ready for
    the more complex parts of Java, then 1) you’re wrong, and 2) buy a different book.
    There are a great many books on the market that will throw all the complexity
    Java has to offer, faster than you can handle it.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我将教给您的是Java。但它并不是*所有*的Java。我必须略去一些部分，因为您还没有准备好。如果您认为自己*已经*准备好学习Java的更复杂部分，那么1）您是错误的，2）请购买另一本书。市面上有很多书籍会比您应付得了的复杂性更快地向您展示Java所能提供的一切。
- en: 'In particular, I have one *huge* omission: I am going to avoid the topic of
    Object­Oriented Programming (OOP). I’m pretty sure that uncomfortable beginners
    can’t learn how to code well and also learn object­oriented programming at the
    same time. I have almost never seen it work.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别是，我有一个*巨大*的遗漏：我将避免讨论面向对象编程（OOP）的话题。我相当肯定，不适应的初学者无法同时学会如何编写良好的代码和学习面向对象编程。我几乎从未见过这种方法奏效。
- en: I plan to write a follow­up book that *will* cover Object­Oriented Programming
    and the more complex parts of Java. But you should finish this book first. I have
    been teaching students to program for many many years, and I have never had a
    student come visit me from college and say “I wish you had spent less time on
    the fundamentals.”
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我计划写一本后续书籍，*将*涵盖面向对象编程和Java的更复杂部分。但您应该先完成这本书。我教学生编程已经很多年了，我从来没有一位学生从大学来拜访我，说“我希望您在基础知识上花的时间少一些”。
- en: What You Will Learn
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您将学到什么
- en: How to install the Java compiler and a text editor to write programs with.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装Java编译器和文本编辑器来编写程序。
- en: How to create, compile and run your first Java program.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建、编译和运行您的第一个Java程序。
- en: Variables and getting input from the user and from files.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和从用户和文件中获取输入。
- en: Making decisions with if statements
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用if语句做出决策
- en: Loops
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环
- en: Arrays
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Records
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: In the final chapter you’ll write a not­so­simple text­based adventure game
    with levels loaded from text files. You should also be able to write a text­based
    card game like Hearts or Spades.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在最后一章中，您将编写一个不那么简单的基于文本的冒险游戏，其中的关卡是从文本文件中加载的。您还应该能够编写一个基于文本的纸牌游戏，如红心或黑桃。
- en: What You Will Not Learn
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您将不会学到什么
- en: Graphics
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形
- en: Object­oriented programming
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: How to make an Android app
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何制作Android应用程序
- en: I like graphics, and they’re not hard in Java compared to, say, C++, but I can’t
    cover everything and teach the basics well, so something had to go.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢图形，在Java中与C++相比并不难，但我无法涵盖所有内容并很好地教授基础知识，所以必须有所取舍。
- en: Object­oriented programming has no place in an introductory book, in my opinion.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，面向对象编程在入门书籍中没有立足之地。
- en: Android apps are pretty complex, and if you’re a beginner, an app is way beyond
    your ability. Nothing in this book will *hurt* your chances of making an app,
    though, and the kinder, gentler pace may keep you going when other books would
    frustrate you into quitting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序非常复杂，如果您是初学者，应用程序远远超出了您的能力。然而，本书中的内容不会*伤害*您制作应用程序的机会，而且更温和的学习节奏可能会让您坚持下去，而其他书籍可能会让您沮丧而放弃。
- en: Also, I hope to write two more books after this one. My second book will cover
    graphics and object­oriented programming in Java. My third book will cover making
    a simple Android app, assuming you have finished working through the first two
    books.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我希望在这本书之后再写两本书。我的第二本书将涵盖Java中的图形和面向对象编程。我的第三本书将涵盖制作一个简单的Android应用程序，假设您已经完成了前两本书的学习。
- en: How to Read This Book
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何阅读本书
- en: Although I have provided a zipfile containing the source code for all the exercises
    in the book, you should type them in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我提供了一个包含本书中所有练习源代码的压缩文件，但您应该自己输入代码。
- en: For each exercise, type in the code. Yourself, by hand. How are you going to
    learn otherwise? None of my former students ever became great at programming by
    merely reading others’ code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，都要自己手动输入代码。否则你怎么学呢？我的以前的学生从来没有通过仅仅阅读他人的代码就成为了优秀的程序员。
- en: Work the study drills, if there are any. Do the challenge assignments, if provided.
    And by the end you will be able to code, at least a little.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 完成学习练习，如果有的话。完成挑战任务，如果有的话。到最后，您将能够编写一些代码。
- en: License
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 许可证
- en: Some chapters of this book are made available free to read online but you are
    not allowed to make copies for others. Unless otherwise stated, all content is
    copyright 2013 Graham Mitchell.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的一些章节可以免费在线阅读，但您不得为他人制作副本。除非另有说明，所有内容均受版权法保护，版权归Graham Mitchell所有。
- en: 'Exercise 0: The Setup'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习0：设置
- en: This exercise has no code but **do not skip it**. It will help you to get a
    decent text editor installed and to install the Java Development Kit (JDK). If
    you do not do both of these things, you will not be able to do any of the other
    exercises in the book. You should follow these instructions as exactly as possible.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习没有代码，但**不要跳过它**。这将帮助您安装一个体面的文本编辑器并安装Java开发工具包（JDK）。如果您不做这两件事，您将无法完成本书中的任何其他练习。您应该尽可能准确地遵循这些说明。
- en: Warning!
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 警告！
- en: This exercise requires you to do things in a terminal window (also called a
    “shell”, “console” or “command prompt”. If you have no experience with a terminal
    window, then you might need to go learn that first.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习需要您在终端窗口（也称为“shell”，“控制台”或“命令提示符”）中执行操作。如果您没有终端窗口的经验，那么您可能需要先学习一下。
- en: '[Zed Shaw’s excellent Command Line Crash Course is at](http://cli.learncodethehardway.org/book/)
    http://cli.learncodethehardway.org/book/ and will teach you how to use PowerShell
    on Windows or the Terminal on OS X or “bash” on Linux.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[Zed Shaw的出色的命令行快速入门课程在](http://cli.learncodethehardway.org/book/) http://cli.learncodethehardway.org/book/，将教您如何在Windows上使用PowerShell或在OS
    X上使用终端或在Linux上使用“bash”。'
- en: Mac OS X
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS X
- en: 'To complete this exercise, complete the following tasks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，完成以下任务：
- en: '[Go to](http://www.barebones.com/products/textwrangler/) http://www.barebones.com/products/textwrangler/
    with your web browser. Download the TextWrangler text editor and install it.'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[转到](http://www.barebones.com/products/textwrangler/) http://www.barebones.com/products/textwrangler/，使用您的网络浏览器。下载TextWrangler文本编辑器并安装它。'
- en: Put TextWrangler in your dock so you can reach it easily.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将TextWrangler放在您的Dock中，以便您可以轻松访问它。
- en: Find a program called “Terminal”. (Search for it if you have to.)
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个名为“终端”的程序。（如果需要，进行搜索。）
- en: Put your Terminal in your dock as well.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也将终端放在您的Dock中。
- en: Launch the Terminal.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动终端。
- en: In the Terminal program, type `javac ­version`  and press `RETURN`. You should
    see a response like `javac 1.7.0_04`. It is okay if the number after `javac`  is
    not exactly the same as long as it is 1.6 or greater. If you get an error message,
    however, you may need to install the JDK.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端程序中，键入`javac ­version`并按`RETURN`。您应该会看到一个类似`javac 1.7.0_04`的响应。如果`javac`后面的数字不完全相同，只要是1.6或更高都可以。但如果出现错误消息，您可能需要安装JDK。
- en: After this, you should be back at a prompt.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您应该回到提示符。
- en: Learn how to create a folder (make a directory) from the Terminal. Make a directory
    so that you can put all your code from this book in it.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从终端创建一个文件夹（创建一个目录）。创建一个目录，以便您可以将本书中的所有代码放入其中。
- en: Learn how to change into this new directory from the Terminal. Change into it.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从终端切换到这个新目录。切换到它。
- en: Use your text editor (TextWrangler) to create a file called `test.txt`  and
    save it into the directory you just created.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用文本编辑器（TextWrangler）创建一个名为`test.txt`的文件，并将其保存到您刚刚创建的目录中。
- en: Go back to the Terminal using only the keyboard to switch windows.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用键盘切换窗口返回到终端。
- en: Back in Terminal, see if you can list the contents of the directory to see your
    newly created file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端，查看是否可以列出目录的内容以查看您新创建的文件。
- en: 'OS X: What You Should See'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OS X：您应该看到的内容
- en: I don’t currently have access to a Mac, so here is Zed following the steps above
    on his computer in Terminal. Your computer would be different, so see if you can
    figure out all the differences between what he did and what you should do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我目前无法访问Mac，所以这是Zed在他的计算机终端上按照上述步骤操作的情况。您的计算机可能会有所不同，因此看看您能否找出他所做的事情和您应该做的事情之间的所有差异。
- en: '[PRE0]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Windows
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: '[Go to](http://notepad/) http://notepad­plus­plus.org/ with your web browser,
    get the Notepad++ text editor, and install it. You do not need to be an administrator
    to do this.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[转到](http://notepad/) http://notepad­plus­plus.org/，使用您的网络浏览器，获取Notepad++文本编辑器，并安装它。您不需要是管理员才能这样做。'
- en: Make sure you can get to Notepad++ easily by putting it on your desktop and/or
    in Quick Launch. Both options are available during setup.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您可以轻松访问Notepad++，将其放在桌面和/或快速启动栏上。这两个选项都可以在安装过程中选择。
- en: Run PowerShell from the Start menu. Search for it and you can just hit Enter
    to run it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从开始菜单运行PowerShell。搜索它，然后按Enter运行。
- en: Make a shortcut to PowerShell on your desktop and/or Quick Launch for your convenience.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在桌面和/或快速启动栏上创建PowerShell的快捷方式，以方便使用。
- en: '[Go to](http://www.oracle.com/technetwork/java/javase/downloads/) http://www.oracle.com/technetwork/java/javase/downloads/
    with your web browser.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[转到](http://www.oracle.com/technetwork/java/javase/downloads/) http://www.oracle.com/technetwork/java/javase/downloads/，使用您的网络浏览器。'
- en: Click the big “Java” button on the left near the top to download the Java Platform
    (JDK) 7u25\. Clicking this will take you to a different page.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的“Java”按钮，下载Java平台（JDK）7u25\. 点击后会跳转到另一个页面。
- en: On this page you will have to accept the license agreement and then choose the
    “Windows x86” version near the bottom of the list. Download the file.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，您需要接受许可协议，然后选择列表底部的“Windows x86”版本。下载文件。
- en: 'Once downloaded, run `jdk­7u25­windows­i586.exe`  to install it. After you
    click “Next >” the very first time you will see a screen that says `Install to:
    C:\Program` `Files (x86)\Java\jdk1.7.0_25\`  or something similar. Make a note
    of this location; you will need it soon.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，运行`jdk­7u25­windows­i586.exe`进行安装。点击“下一步>”后，您将首次看到一个屏幕，上面写着`安装到：C:\Program`
    `Files (x86)\Java\jdk1.7.0_25\`或类似的内容。记下这个位置，您很快就会需要它。
- en: Once the JDK is installed you will need to find out the exact name of the folder
    where it was installed. Look on the `C:`  drive inside the `Program Files`  folder
    or the `C:\Program` `Files (x86)`  folder if you have one. You are looking for
    a folder called `Java`. Inside that is a folder called `jdk1.7.0_25`  that has
    a folder called `bin`  inside it. The folder name must have `jdk1.7`  in it; `jre7`  is
    not the same. Make sure there’s a `bin`  folder.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装JDK后，您需要找出安装位置的确切名称。在`C:`驱动器内查看`Program Files`文件夹或`C:\Program` `Files (x86)`文件夹（如果有的话）。您要找的是一个名为`Java`的文件夹。里面有一个名为`jdk1.7.0_25`的文件夹，里面有一个名为`bin`的文件夹。文件夹名称必须包含`jdk1.7`；`jre7`不一样。确保有一个`bin`文件夹。
- en: Once you are in this folder, you can left­click up in the folder location and
    it will change to something that looks like `C:\Program Files (x86)\Java\jdk1.7.0_25\bin`.
    You can write this down or highlight and right­click to copy it to the clipboard.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入此文件夹后，您可以在文件夹位置左键单击，它将变成类似`C:\Program Files (x86)\Java\jdk1.7.0_25\bin`的内容。您可以记下这个内容，或者将其高亮显示并右键单击复制到剪贴板。
- en: 'Once the JDK is installed and you know this location open up your terminal
    window (PowerShell). In PowerShell, type this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装JDK并知道其位置后，打开您的终端窗口（PowerShell）。在PowerShell中，键入以下内容：
- en: '[Environment]::SetEnvironmentVariable("Path",'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Environment]::SetEnvironmentVariable("Path",'
- en: '"$env:Path;C:\Program Files (x86)\Java\jdk1.7.0_25\bin", "User")'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '"$env:Path;C:\Program Files (x86)\Java\jdk1.7.0_25\bin", "User")'
- en: Put it all on one line, though.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一行上。
- en: If you copied the folder location to the clipboard, then you can type everything
    up to the `$env:Path;`  and then right­click in the PowerShell window and it should
    paste the folder name for you. Then you can just finish the line by typing `",
    "User")`  and pressing `ENTER`. If you get an error, you typed something incorrectly.
    You can press the up arrow to get it back and the left and right arrows to find
    and fix your mistake, then press `ENTER`  again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将文件夹位置复制到剪贴板，那么您可以键入`$env:Path;`之前的所有内容，然后在PowerShell窗口中右键单击，它应该会为您粘贴文件夹名称。然后您只需完成这一行，输入`",
    "User")`并按`ENTER`。如果出现错误，您输入了错误的内容。您可以按上箭头将其取回，使用左右箭头找到并纠正错误，然后再次按`ENTER`。
- en: Once the `setEnvironmentVariable`  command completes without giving you an error,
    close the PowerShell window by typing `exit`  at the prompt. If you don’t close
    it the change you just made won’t take effect.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`setEnvironmentVariable`命令完成而没有给出错误，通过在提示符处键入`exit`关闭PowerShell窗口。如果你不关闭它，你刚刚做的更改就不会生效。
- en: Launch PowerShell again.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次启动PowerShell。
- en: Type `javac ­version`  at the prompt. You should see a response like `javac
    1.7.0_25`. Congratulations! If you got that to work, the rest of this book ought
    to be relatively easy.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符处键入`javac ­version`。你应该会看到一个类似`javac 1.7.0_25`的响应。恭喜！如果你成功了，这本书的其余部分应该相对容易。
- en: After this, you should be back at a blinking PowerShell prompt.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，你应该回到一个闪烁的PowerShell提示符。
- en: Learn how to create a folder (make a directory) from the terminal window (PowerShell).
    Make a directory so that you can put all your code from this book in it.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从终端窗口（PowerShell）创建一个文件夹（创建一个目录）。创建一个目录，这样你就可以把这本书中的所有代码放进去。
- en: Learn how to change into this new directory from the prompt. Change into it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从提示符中切换到这个新目录。切换到它。
- en: Use your text editor (Notepad++) to create a file called `test.txt`  and save
    it into the directory
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器（Notepad++）创建一个名为`test.txt`的文件，并将其保存到目录中
- en: you just created.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你刚刚创建的。
- en: Go back to the terminal using only the keyboard to switch windows.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用键盘切换窗口回到终端。
- en: Back in the terminal, see if you can list the contents of the directory to see
    your newly created file.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端，看看你是否可以列出目录的内容，以查看你新创建的文件。
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Windows: What You Should See'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows：你应该看到的内容
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will probably see a different prompt and other slight differences but you
    shouldn’t get any errors and this is the general idea.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到不同的提示和其他细微的差异，但你不应该会得到任何错误，这是一般的想法。
- en: Linux
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: There are a lot of different versions of Linux out there, so I am going to give
    instructions for the latest version of Ubuntu. If you are running something else,
    you probably know what you are doing well enough to figure out how to modify the
    directions for your setup.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有很多不同的版本，所以我将为最新版本的Ubuntu提供说明。如果你使用其他系统，你可能知道如何修改这些说明以适应你的设置。
- en: Use your Linux package manager to install the `gedit`  text editor (Which might
    just be called “Text Editor”.)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的Linux软件包管理器安装`gedit`文本编辑器（可能只是称为“文本编辑器”）。
- en: Make sure you can get to gedit easily by putting it in the Launcher.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你可以通过将其放在启动器中轻松地找到gedit。
- en: 'Run gedit so we can change some of the defaults to be better for programmers:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行gedit，这样我们就可以更改一些默认设置，使其更适合程序员：
- en: Open *Preferences* and select the *Editor* tab.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开*首选项*并选择*编辑器*选项卡。
- en: 'Change Tab width: to 4.'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项卡宽度更改为4。
- en: Put a check mark next to “Automatic indentation”
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“自动缩进”旁边打上勾
- en: Open the *View* tab and turn on “Display line numbers.”
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开*查看*选项卡，打开“显示行号”。
- en: Find your Terminal program. It could be called GNOME Terminal, Konsole, or xterm.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你的终端程序。它可能被称为GNOME终端、Konsole或xterm。
- en: Put your Terminal in the Launcher as well.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也把你的终端放到启动器中。
- en: Use your Linux package manager to install the Java JDK. I use `openjdk­7­jdk`,
    but if you prefer the Oracle one that will work, too.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的Linux软件包管理器安装Java JDK。我使用`openjdk­7­jdk`，但如果你更喜欢Oracle的，也可以。
- en: Launch your Terminal if you haven’t already.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你还没有启动终端，启动你的终端。
- en: Type `javac ­version`  at the prompt. You should see a response like `javac
    1.7.0_25`. If not, make sure the JDK is installed and that the `bin`  folder containing
    the executable `javac`  is in your PATH.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符处键入`javac ­version`。你应该会看到一个类似`javac 1.7.0_25`的响应。如果没有，确保JDK已安装，并且包含可执行文件`javac`的`bin`目录在你的PATH中。
- en: Learn how to create a folder (make a directory) from the terminal. Make a directory
    so that you can put all your code from this book in it.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从终端创建一个文件夹（创建一个目录）。创建一个目录，这样你就可以把这本书中的所有代码放进去。
- en: Learn how to change into this new directory from the prompt. Change into it.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何从提示符中切换到这个新目录。切换到它。
- en: Use your text editor (gedit) to create a file called `test.txt`  and save it
    into the directory you just created.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器（gedit）创建一个名为`test.txt`的文件，并将其保存到你刚刚创建的目录中。
- en: Go back to the terminal using only the keyboard to switch windows. Look it up
    if you don’t know how.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只使用键盘切换窗口回到终端。如果你不知道如何做，查一下。
- en: Back in the terminal, see if you can list the contents of the directory to see
    your newly created file.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端，看看你是否可以列出目录的内容，以查看你新创建的文件。
- en: 'Linux: What You Should See'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux：你应该看到的内容
- en: '[PRE10]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You will probably see a different prompt and other slight differences but you
    shouldn’t get any errors and this is the general idea.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到不同的提示和其他细微的差异，但你不应该会得到任何错误，这是一般的想法。
- en: Warnings for Beginners
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初学者警告
- en: You are done with the first exercise. This exercise might have been quite hard
    for you depending on your familiarity with your computer. If it was difficult
    and you didn't finish it, go back and take the time to read and study and get
    through it. Programming requires careful reading and attention to detail.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了第一个练习。这个练习可能对你来说很难，这取决于你对计算机的熟悉程度。如果很困难，你没有完成，回去花时间阅读和学习，然后再试一次。编程需要仔细阅读和注意细节。
- en: If a programmer tells you to use vim or emacs or Eclipse, just say “no.” These
    editors are for when you are a better programmer. All you need right now is an
    editor that lets you put text into a file. We will use gedit, TextWrangler, or
    Notepad++ (from now on called “the text editor” or “a text editor”) because it
    is simple and the same on all computers. Professional programmers use these text
    editors so it’s good enough for you starting out.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个程序员告诉你使用vim或emacs或Eclipse，只需说“不”。这些编辑器是给你成为更好的程序员时使用的。你现在所需要的只是一个能让你把文本放入文件中的编辑器。我们将使用gedit、TextWrangler或Notepad++（从现在开始称为“文本编辑器”或“一个文本编辑器”），因为它简单，并且在所有计算机上都是一样的。专业程序员使用这些文本编辑器，所以对于你来说已经足够了。
- en: A programmer will eventually tell you to use Mac OS X or Linux. If the programmer
    likes fonts and typography, he’ll tell you to get a Mac OS X computer. If he likes
    control and has a huge beard, they’ll tell you to install Linux. Again, use whatever
    computer you have right now that works. All you need is an editor, a Terminal,
    and Java.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员最终会告诉你使用Mac OS X或Linux。如果程序员喜欢字体和排版，他会告诉你买一个Mac OS X电脑。如果他喜欢控制并且留着大胡子，他们会告诉你安装Linux。再次强调，使用你现在拥有的能工作的计算机。你只需要一个编辑器、一个终端和Java。
- en: 'Finally, the purpose of this setup is so you can do three things very reliably
    while you work on the exercises:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个设置的目的是让你在做练习时可以非常可靠地做三件事：
- en: Write exercises using your text editor (gedit on Linux, TextWrangler on OSX,
    or Notepad++ on Windows).
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你的文本编辑器（Linux上的gedit，OSX上的TextWrangler，或Windows上的Notepad++）编写练习。
- en: Run the exercises you wrote.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你写的练习。
- en: Fix them when they are broken.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们坏了就修好它们。
- en: Repeat.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复。
- en: Anything else will only confuse you, so stick to the plan.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其他任何事情都只会让你困惑，所以坚持计划。
- en: Frequently­Asked Questions
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见问题
- en: Do I have to use this lame text editor? I want to use Eclipse!
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我必须使用这个糟糕的文本编辑器吗？我想用Eclipse！
- en: 'Do not use Eclipse. Although it is a nice program it is not for beginners.
    It is bad for beginners in two ways:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用Eclipse。虽然它是一个不错的程序，但不适合初学者。它对初学者有两个坏处：
- en: It makes you do things that you don’t need to worry about right now.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它让你做一些你现在不需要担心的事情。
- en: It does things for you that you need to learn how to do for yourself first.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它为你做了一些你需要先学会如何做的事情。
- en: So follow my instructions and use a decent text editor and a terminal window.
    Once you have learned how to code you can use other tools if you want, but not
    now.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以按照我的指示使用一个体面的文本编辑器和一个终端窗口。一旦你学会了编码，你可以使用其他工具，但现在不行。
- en: Can I work through this book on my tablet? Or my Chromebook?
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我可以在我的平板电脑上完成这本书吗？还是我的Chromebook？
- en: Unfortunately not. You can’t install the Java development kit (JDK) on either
    of those machines. You must have some sort of traditional computer.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸。你不能在这两台机器上安装Java开发工具包（JDK）。你必须有某种传统的计算机。
- en: 'Exercise 1: An Important Message'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1：一个重要的消息
- en: In this exercise you will write a working program in Java to display an important
    message on the screen.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将编写一个在屏幕上显示重要消息的Java工作程序。
- en: If you are not used to typing detailed instructions for a computer then this
    could be one of the harder exercises in the book. Computers are very stupid and
    if you don’t get *every* detail right, the computer won’t understand your instructions.
    But if you can get this exercise done and working, then there is a good chance
    that you will be able to handle every exercise in the book as long as you work
    on it every day and don’t quit.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不习惯为计算机输入详细的指令，那么这可能是本书中最难的练习之一。计算机非常愚蠢，如果你没有把每一个细节都搞对，计算机就不会理解你的指令。但是如果你能完成并使这个练习工作，那么你很有可能能够处理本书中的每一个练习，只要你每天都继续努力，并且不放弃。
- en: Open the text editor you installed in Exercise 0 and type the following text
    into a single file named `FirstProg.java`. Make sure to match what I have written
    exactly, including spacing, punctuation, and capitalization.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你在练习0中安装的文本编辑器，并将以下文本输入到一个名为`FirstProg.java`的单个文件中。确保与我写的完全匹配，包括间距、标点和大写。
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I have put line numbers in front of each line, but do not type the line numbers.
    They are only there so I can talk about the lines. Also, depending on whether
    or not you have saved the file yet, the different words may not be colored at
    all. Or if they are colored, they might be different colors than mine. These differences
    are fine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我在每一行前面都加了行号，但不要输入行号。它们只是为了我能谈论这些行。另外，取决于你是否已经保存了文件，不同的单词可能根本没有颜色。或者如果它们有颜色，它们可能与我的颜色不同。这些差异都没关系。
- en: I’m going to walk through this line­by­line, just to make sure you typed everything
    correctly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我将逐行走过这个程序，只是为了确保你输入的每一个东西都是正确的。
- en: The first line starts with the word `public`  followed by a single space then
    the word `class`  followed by a single space and then the word `FirstProg`. The
    ‘F’ in “First” is capitalized, the ‘P’ in “Prog” is capitalized. There are only
    two capital letters in the first line. There are only two spaces.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以单词`public`开头，后面跟着一个空格，然后是单词`class`，再后面是一个空格，然后是单词`FirstProg`。 “First”中的‘F’是大写的，“Prog”中的‘P’是大写的。第一行只有两个大写字母。只有两个空格。
- en: 'The second line is just a single character: a “brace”. You get it to show up
    by holding down `SHIFT`  and then pressing the ‘[‘ key which is usually to the
    right of the letter ‘P’.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行只是一个单字符：“大括号”。你可以通过按住`SHIFT`键然后按下通常在字母‘P’右边的‘[’键来显示它。
- en: Before I go on to the third line of the program, I should tell you what programmers
    usually call each funny symbol that appears in this program.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续程序的第三行之前，我应该告诉你程序员通常称呼这个程序中出现的每个有趣的符号。
- en: '`(`  and `)`  are called “parentheses” (that’s plural). Just one of them is
    called “a parenthesis”, but some people just call them parens (“puh­RENZ”). This
    one (“`(`“) is sometimes called a “left paren” and the other (“`)`”) is called
    a “right paren” because parentheses usually come in pairs and one is usually to
    the left of the other. The left parenthesis (“`(`“) is also often called an “open
    paren” and the right one is called a “close paren” for similar reasons.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`（`和`）`被称为“括号”（复数）。其中一个被称为“括号”，但有些人只是称它们为parens（“puh­RENZ”）。这个（“`（`”）有时被称为“左括号”，另一个（“`）`”）被称为“右括号”，因为括号通常成对出现，一个通常在另一个的左边。左括号（“`（`”）也经常被称为“开括号”，右括号被称为“闭括号”，原因类似。'
- en: There’s an open paren on line 3 and a close paren, too, and no other parentheses
    in the whole file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行有一个开括号和一个闭括号，整个文件中没有其他括号。
- en: '`[`  and `]`  are called “brackets”, but many programmers call them “square
    brackets” to make sure there’s no confusion. In Java, parentheses and square brackets
    are not interchangeable. Brackets come in pairs and they are called “left bracket”
    or “open bracket” and “right bracket” or “close bracket”.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 【】和【】被称为“括号”，但许多程序员称它们为“方括号”，以确保不会引起混淆。在Java中，括号和方括号不能互换使用。括号成对出现，它们被称为“左括号”或“开括号”和“右括号”或“闭括号”。
- en: There’s an open and close square bracket right next to each other on line 3.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第3行有一个紧挨着的开括号和闭括号。
- en: '`{`  and `}`  are called “braces”, and some programmers call them “curly braces”.
    These'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`{`和`}`被称为“大括号”，有些程序员称它们为“花括号”。这'
- en: also always come in pairs of left and right curly braces / open and close braces.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 也总是成对出现的左大括号和右大括号/开大括号和闭大括号。
- en: '`"`  is called a “quotation mark”, often just abbreviated “quote”. In Java,
    these always come in pairs. The first one in a pair is usually called an “open
    quote” and the second one is a “close quote” even though it’s the exact same character
    in both places. But the first quote serves to begin something and the second one
    ends that thing.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`"`被称为“引号”，通常简称为“引号”。在Java中，它们总是成对出现。一对中的第一个通常被称为“开引号”，第二个是“闭引号”，尽管在两个位置上它是完全相同的字符。但第一个引号用于开始某事，第二个引号结束了那件事。'
- en: '`''`  is technically an “apostrophe”, but almost all programmers call them
    “single quotes”. For this reason a quotation mark is often called a “double quote”.
    In some programming languages, single quotes and double quotes are interchangeable,
    but not in Java. Java does use single quotes sometimes, but they’re going to be
    pretty rare in this book.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`''`在技术上是“撇号”，但几乎所有程序员都称它们为“单引号”。因此，引号通常被称为“双引号”。在一些编程语言中，单引号和双引号是可以互换的，但在Java中不行。Java有时会使用单引号，但在这本书中它们会相当少见。'
- en: '`.`  is technically a “period”, but almost all programmers just say “dot”.
    They are used a lot in programming languages, and they are usually used as separators
    instead of “enders”, so we don’t call them periods.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`在技术上是“句号”，但几乎所有程序员都说“点”。它们在编程语言中经常被使用，并且通常被用作分隔符而不是“结束符”，所以我们不称它们为句号。'
- en: There are four dots in this program and one period.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中有四个句点和一个句号。
- en: '`;`  is called a “semicolon”. It’s between the letter ‘L’ and the quote on
    the keyboard. Java uses a lot of semicolons although there are only two of them
    in this program: one on the end of line 5 and another at the end of line 6.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`;`被称为“分号”。它位于键盘上字母''L''和引号之间。Java中使用了很多分号，尽管在这个程序中只有两个：一个在第5行的末尾，另一个在第6行的末尾。'
- en: '`:`  is called a “colon”. You get it by holding SHIFT and typing a semicolon.
    Java does use colons, but they’re very rare.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`:`被称为“冒号”。通过按住SHIFT键并输入分号来获得它。Java确实使用冒号，但它们非常少见。'
- en: Finally, `<`  is a “less­than sign” and `>`  is a “greater­than sign”, but sometimes
    they are used sort­of like braces or brackets. When they are used this way, they’re
    usually called “angle brackets”. Java uses angle brackets, but you won’t see them
    used in this book.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`<`是“小于号”，`>`是“大于号”，但有时它们被用作大括号或方括号。当它们以这种方式使用时，它们通常被称为“尖括号”。Java使用尖括号，但你在这本书中看不到它们被使用。
- en: Okay, so back to the line­by­line. You have already typed the first two lines
    correctly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，回到逐行。你已经正确地输入了前两行。
- en: You should start the third line by pressing `TAB`  one time. Your cursor will
    move over several spaces (probably 4 or 8). Then type the word `public`  again,
    one space, the word `static`, one space, the word `void`, one space, the word
    `main`  followed by an open paren (no space between the word “main” and the paren).
    After the paren there’s one space, the word `String`  with a capital ‘S’, an open
    and close square bracket right next to each other, one space, the word `args`,
    one space and finally a close parenthesis.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该按一次`TAB`键开始第三行。你的光标会移动几个空格（可能是4或8）。然后再次输入单词`public`，一个空格，单词`static`，一个空格，单词`void`，一个空格，单词`main`后面跟一个开括号（“main”和括号之间没有空格）。括号后有一个空格，单词`String`（大写'S'），一个紧挨着的开括号和闭括号，一个空格，单词`args`，一个空格，最后是一个闭括号。
- en: So line three starts with a tab, has a total of six spaces, and only the ‘S’
    in “String” is capitalized. Whew.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第三行以一个制表符开始，总共有六个空格，只有“String”中的‘S’是大写的。哇。
- en: On the fourth line, your text editor may have already started your cursor directly
    underneath the ‘p’ in “public”. If it did not do that, then you’ll have to start
    line 4 by pressing TAB yourself. Then just type another open curly brace and that’s
    it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行，你的文本编辑器可能已经将光标直接放在“public”中的‘p’下面。如果没有这样做，那么你将不得不自己按TAB键开始第4行。然后只需输入另一个开大括号，就这样。
- en: The fifth line should start with two tabs. Then type the word `System`  with
    a capital ‘S’, then a dot (period), then the word `out`, another dot, the word
    `println`  (pronounced “PrintLine” even though there’s no ‘i’ or ‘e’ at the end),
    an open paren, a space, a quotation mark (open quote), the sentence `I` `am determined
    to learn how to code.`  (the sentence ends with a period), then a close quote,
    a space, a close paren and a semicolon.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第五行应该以两个制表符开始。然后输入单词`System`（大写'S'），然后是一个句点（句号），然后是单词`out`，另一个句点，单词`println`（发音为“PrintLine”，尽管末尾没有‘i’或‘e’），一个开括号，一个空格，一个引号（开引号），句子`I`
    `am determined to learn how to code.`（句子以句号结束），然后是一个闭引号，一个空格，一个闭括号和一个分号。
- en: So line 5 has two tabs, nine spaces, two dots (and a period), an open and close
    quote, an open and close paren, and only two capital letters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第5行有两个制表符，九个空格，两个句点（和一个句号），一个开引号和闭引号，一个开括号和闭括号，只有两个大写字母。
- en: Line 6 is nearly identical to line 5 except that the sentence says `Today's
    date is`  instead of the determination sentence.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行几乎与第5行相同，只是句子说“今天的日期是”，而不是决定性的句子。
- en: Line 7 starts with only one tab. If your text editor put two tabs in there for
    you, you should be able to get rid of the extra tab by pressing BACKSPACE one
    time. Then after the tab there’s a close curly brace.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行只以一个制表符开始。如果你的文本编辑器为你放了两个制表符，你应该能够通过按一次BACKSPACE键来去掉多余的制表符。然后在制表符之后有一个右花括号。
- en: 'Finally, line 8 has no tabs and one more close curly brace. You can press ENTER
    after line 8 or not: Java doesn’t care.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第8行没有制表符，还有一个右花括号。你可以在第8行按ENTER键，也可以不按：Java不在乎。
- en: Notice that we have two open curly braces and two close curly braces in the
    file. Three open parens and three close parens. Two “open quotes” and two “close
    quotes”. One open square bracket and one close square bracket. This will always
    be true.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，文件中有两个左花括号和两个右花括号。三个左括号和三个右括号。两个“开引号”和两个“闭引号”。一个左方括号和一个右方括号。这总是正确的。
- en: Also notice that every time we did an open curly brace, the line(s) below it
    had more tabs at the beginning, and the lines below close curly braces had fewer
    tabs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，每次我们输入一个左花括号时，下面的行会有更多的制表符，而在右花括号下面的行则会有更少的制表符。
- en: Okay, now save this (if you haven’t already) as `FirstProg.java`  and save it
    in the “code” folder you created in Exercise 0.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在保存这个（如果你还没有）为`FirstProg.java`，并将其保存在你在练习0中创建的“code”文件夹中。
- en: 'Make sure the file name matches mine exactly: the ‘F’ in “First” is capitalized,
    the ‘P’ in “Prog” is capitalized, and everything else is lowercase. And there
    should be no spaces in the file name. Java will refuse to run any program with
    a space in the file name. Also make sure the filename ends in `.java`  and not
    `.txt`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 确保文件名与我的完全匹配： “First”中的‘F’是大写的，“Prog”中的‘P’是大写的，其他所有字母都是小写的。文件名中不应该有空格。Java将拒绝运行任何文件名中带有空格的程序。还要确保文件名以`.java`结尾，而不是`.txt`。
- en: Compiling Your First Program
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译你的第一个程序
- en: Now that the program has been written and hopefully contains no mistakes (we’ll
    see soon enough), launch your Terminal (or PowerShell) and change into the directory
    where the code is saved.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在程序已经编写好了，希望没有错误（我们很快就会看到），启动你的终端（或PowerShell）并切换到保存代码的目录。
- en: 'Do a directory listing to make sure the Java file is there. On my computer,
    it looks like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 进行目录列表以确保Java文件在那里。在我的电脑上，它看起来像这样：
- en: '[PRE15]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the future, since your terminal probably doesn’t look like mine, I am going
    to abbreviate the prompt like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将来，因为你的终端可能看起来不像我的，我会这样缩写提示：
- en: '[PRE16]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That way it will be less confusing, since there is less “wrong” stuff to ignore
    and you only have to look at what you should type and what you should see.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这样会更少混乱，因为要忽略的“错误”会更少，你只需要看看你应该输入什么和你应该看到什么。
- en: Now, we have typed a list of commands in a programming language called Java.
    But the computer cannot execute our commands directly in this form. We have to
    give this file to a “compiler”, which is a program that will translate our instructions
    into something more like ones and zeros that the computer can execute. In Java
    that ones and zeros file is called “bytecode”. So we are going to run the Java
    compiler program to “compile” our Java source code into a bytecode file that we
    will be able to execute.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经在一个叫做Java的编程语言中输入了一系列命令。但是计算机不能直接执行我们的命令。我们必须把这个文件交给一个“编译器”，这是一个将我们的指令翻译成更接近计算机可以执行的一些东西的程序。在Java中，这些东西被称为“字节码”。所以我们要运行Java编译器程序来“编译”我们的Java源代码成一个字节码文件，这样我们就能够执行它了。
- en: 'The Java compiler is named `javac`  (the ‘c’ is for “compiler”), and we run
    it like so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器的名字是`javac`（‘c’代表“编译器”），我们这样运行它：
- en: '[PRE17]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you have extraordinary attention to detail and did everything that I told
    you, this command will take a second to run, and then the prompt will just pop
    back up with no message. If you made some sort of mistake, you will see an error
    like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对细节非常关注，并且做了我告诉你的一切，这个命令将花费一秒钟的时间运行，然后提示符将会弹出，没有消息。如果你犯了某种错误，你会看到这样的错误：
- en: '[PRE18]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Don’t worry too much about the particular error message. When it gets confused,
    the compiler tries to guess about what you might have done wrong. Unfortunately,
    the guesses are designed for expert programmers, so it usually doesn’t guess well
    for beginner­type mistakes.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太担心特定的错误消息。当它感到困惑时，编译器会试图猜测你可能犯了什么错误。不幸的是，这些猜测是为专业程序员设计的，所以它通常对初学者类型的错误猜测不准确。
- en: 'Here is an example of a different error message you might get:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可能会得到的另一种错误消息的例子：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this case, the compiler is actually right: the error is on line 5 and the
    specific error is that a semicolon was expected (`'';'' expected`). (The line
    ends with a colon (`:`) but it ought to be a semicolon (`;`).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，编译器实际上是正确的：错误出现在第5行，具体错误是期望有一个分号（`';' expected`）。（该行以冒号（`:`）结尾，但应该是分号（`;`）。
- en: 'Here’s one more:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time is it a capitalization error. The code says `public class Firstprog`  (note
    the lowercase ‘p’) but the filename is `FirstProg.java`. Because they don’t match
    exactly, capitalization and all, the compiler gets confused and bails out.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这次是一个大小写错误。 代码中写着`public class Firstprog`（注意小写的‘p’），但文件名是`FirstProg.java`。因为它们不完全匹配，包括大小写，编译器会感到困惑并退出。
- en: So if you have any error messages, fix them, then *save* your code, go back
    to the terminal and compile again.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你有任何错误消息，修复它们，然后*保存*你的代码，回到终端再次编译。
- en: Warning!
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 警告！
- en: If you make a change to the code in your text editor, you must save the file
    before attempting to re­compile it. If you don’t save the changes, you will still
    be compiling the old version of the code that was saved previously, even if the
    code in your text editor is correct.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在文本编辑器中对代码进行了更改，你必须在尝试重新编译之前保存文件。如果你不保存更改，你仍然会编译之前保存的旧版本的代码，即使你的文本编辑器中的代码是正确的。
- en: 'Eventually you should get it right and it will compile with no errors and no
    message of any kind. Do a directory listing and you should see the bytecode file
    has appeared in the folder:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您应该做对了，它将编译而不会出现任何错误或任何消息。进行目录列表，您应该看到字节码文件出现在文件夹中：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have a valid bytecode file we can run it (or “execute” it) by running
    it through the Java Virtual Machine (JVM) program called `java`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个有效的字节码文件，我们可以通过Java虚拟机（JVM）程序`java`来运行它（或“执行”它）：
- en: What You Should See
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您应该看到的内容
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the command you type is `java FirstProg`, not `java FirstProg.java`  or
    even `java`  `FirstProg.class`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您输入的命令是`java FirstProg`，而不是`java FirstProg.java`，甚至不是`java` `FirstProg.class`。
- en: Are you stoked? You just wrote your first Java program and ran it! If you made
    it this far, then you almost certainly have what it takes to finish the book as
    long as you work on it every day and don’t quit.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您激动吗？您刚刚编写了您的第一个Java程序并运行它！如果您走到了这一步，那么只要您每天都在上面努力工作并且不放弃，您几乎肯定有能力完成这本书。
- en: Study Drills
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习任务
- en: After most of the exercises, I will list some additional tasks you should try
    after typing up the code and getting it to compile and run. Some study drills
    will be fairly simple and some will be more challenging, but you should always
    give them a shot.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数练习之后，我会列出一些额外的任务，您应该在键入代码并使其编译和运行后尝试。一些学习任务将非常简单，有些将更具挑战性，但您应该始终尝试。
- en: Change what is inside the quotes on line 6 to include today’s date. Save the
    file once you have made your changes, compile the file and run it again.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改第6行引号内的内容以包括今天的日期。在进行更改后保存文件，编译文件并再次运行它。
- en: Change what is inside the quotes on line 5 to have the computer display your
    name.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改第5行引号内的内容，使计算机显示您的姓名。
- en: What You Should See After Completing the Study Drills
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成学习任务后您应该看到的内容
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Exercise 2: More Printing'
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：更多打印
- en: Okay, now that we’ve gotten that first, hard assignment out of the way, we’ll
    do another. The nice thing is that in this one, we still have a lot of the setup
    code (which will be nearly the same every time), but the ratio of set up to “useful”
    code is much better.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经完成了第一个艰难的任务，我们将做另一个。好处是，在这个任务中，我们仍然有很多设置代码（几乎每次都是相同的），但是设置与“有用”代码的比例要好得多。
- en: Type the following text into a single file named `LetterToYourself.java`. Make
    sure to match what I have written exactly, including spacing, punctuation, and
    capitalization.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本键入单个文件中，文件名为`LetterToYourself.java`。确保与我写的内容完全匹配，包括间距、标点和大写。
- en: Notice that the first line is the same as the previous assignment, except that
    the name of the class is now `LetterToYourself`  instead of `FirstProg`. Also
    note that the name of the file you’re putting things into is `LetterToYourself.java`  instead
    of `FirstProg.java`. This is not a coincidence.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一行与上一个任务相同，只是类的名称现在是`LetterToYourself`而不是`FirstProg`。还要注意，您要放置内容的文件名是`LetterToYourself.java`而不是`FirstProg.java`。这不是巧合。
- en: In Java, each file can contain only one public class, and the name of the public
    class must match the file name (capitalization and all) except that the file name
    ends in `.java`  and the public class name does not.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个文件只能包含一个public类，而公共类的名称必须与文件名（包括大小写）匹配，除了文件名以`.java`结尾，而公共类名不是。
- en: So, what does “public class” *mean* in Java? I’ll tell you when you’re older.
    Seriously, trying to go into that kind of detail up front is why most “beginner”
    programming books are bad for actual beginners. So don’t worry about it. Just
    type it for now. (Unfortunately, there’s going to be a lot of that.)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在Java中，“public class” *意味着*什么？等您长大了我会告诉您。说真的，试图一开始就详细介绍这种类型的原因是大多数“初学者”编程书籍对于真正的初学者来说都很糟糕。所以不要担心。现在只需键入它。（不幸的是，这种情况会发生很多。）
- en: You will probably notice that the second, third and fourth lines of this program
    are *exactly* the same as the previous assignment. There are no differences whatsoever.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到此程序的第二行、第三行和第四行与上一个任务*完全*相同。它们没有任何区别。
- en: Then, after the second open brace, there are eleven printing statements. They
    are all identical except for what is between the quotation marks. The little vertical
    bar (“`|`”) is called the “pipe” character, and you can type it using Shift +
    backslash (“`\`”). Assuming you are using a normal US keyboard, the backslash
    key is located between the Backspace and Enter keys.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二个左大括号之后，有十一个打印语句。它们都是完全相同的，除了引号之间的内容。小竖线（“`|`”）称为“管道”字符，您可以使用Shift +反斜杠（“`\`”）键入它。假设您使用的是普通的美国键盘，反斜杠键位于退格键和回车键之间。
- en: 'Once everything is typed in and saved as `LetterToYourself.java`, you can compile
    and run it the same way you did the previous assignment. Switch to your terminal
    window, change the directory into the one where you are saving your code and type
    this to compile it:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都键入并保存为`LetterToYourself.java`后，您可以像之前的任务一样编译和运行它。切换到终端窗口，将目录更改为保存代码的目录，并键入以下内容进行编译：
- en: '[PRE24]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you are extremely good with annoying details and fortunate, you will have
    no errors and the `javac`  command will complete without saying anything at all.
    Probably, you will have errors. If so, go back and compare what you type with
    what I wrote very carefully. Eventually you will discover your error(s). Fix them,
    save the file again, and try compiling again.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你非常擅长烦人的细节并且幸运的话，你将不会有错误，`javac`命令将在不说任何话的情况下完成。可能你会有错误。如果是这样，回去仔细比较你输入的内容和我写的内容。最终你会发现你的错误。修复它们，再次保存文件，然后尝试重新编译。
- en: 'Once it compiles with no errors, you can run it like before:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它编译没有错误，你可以像以前一样运行它：
- en: '[PRE25]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Two programs done. Nice! What you have accomplished so far is *not* easy, and
    anyone that thinks it is has a *lot* of experience and has forgotten what it is
    like to try this stuff for the first time. Don’t quit!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 两个程序完成了。不错！到目前为止你所取得的成就*并不*容易，任何认为它容易的人都有*很多*经验，并且已经忘记了第一次尝试这些东西是什么感觉。不要放弃！
- en: Work a little every day and this *will* get easier.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每天多做一点，这样*会*变得更容易。
- en: Study Drills
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: 1\. This file is called `LetterToYourself.java`  not `LetterToBillGates.java`!
    Go back to your text editor and change the name and address from Bill Gates’ address
    at Microsoft to your own name and address. Then save it, compile it and run it
    again.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 这个文件叫`LetterToYourself.java`而不是`LetterToBillGates.java`！回到你的文本编辑器，把名字和地址从比尔盖茨在微软的地址改成你自己的名字和地址。然后保存，编译，再次运行。
- en: Common Student Questions
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的学生问题
- en: Do I have to use my real address?
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我必须使用我的真实地址吗？
- en: Of course not. But make sure your fake address takes up three lines.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 当然不是。但是确保你的虚假地址占据三行。
- en: Why doesn’t my letter line up when I run the program?!? Everything looks perfect
    in the code!
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么当我运行程序时我的信不对齐？！在代码中一切看起来都很完美！
- en: You probably used a mixture of tabs and spaces between the quotes in your println()
    statements. Many text editors will only move the cursor 4 spaces when you press
    TAB. But when your program runs, any tabs embedded inside the quotes will take
    up 8 spaces, not 4\. If you delete ALL the tabs between the quotes and replace
    them with spaces, things should look the same in your code and when you run the
    program.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在你的println()语句中使用了制表符和空格的混合。许多文本编辑器在你按下TAB键时只会将光标移动4个空格。但当你的程序运行时，引号内嵌的任何制表符将占用8个空格，而不是4个。如果你删除引号之间的所有制表符并用空格替换它们，你的代码和运行程序时的效果应该是一样的。
- en: 'Exercise 3: Printing Choices'
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3：打印选择
- en: Java has two common commands used to display things on the screen. So far we
    have only looked at
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Java有两个常用的命令用于在屏幕上显示东西。到目前为止，我们只看过
- en: '`println()`, but `print()`  is sometimes used, too. This exercise will demonstrate
    the difference.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`println()`，但`print()`有时也会用到。这个练习将展示它们之间的区别。'
- en: '[PRE26]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Type the following code into a single file. By reading the code, could you guess
    that the file must be called `PrintingChoices.java`? In future assignments, I
    may not tell you what to name the Java file.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码输入到一个文件中。通过阅读代码，你能猜到文件必须叫`PrintingChoices.java`吗？在未来的作业中，我可能不会告诉你如何命名Java文件。
- en: When you run it, this is what you should see.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你应该看到这个。
- en: '[PRE31]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Can you figure out the difference?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你能找出区别吗？
- en: 'Both `print()`  and `println()`  display on the screen whatever is between
    the quotation marks. But `println()`  moves to a new line after finishing printing,
    and `print()`  does not: it displays and then leaves the cursor right at the end
    of the line so that the following printing statement picks up from that same position
    on the line.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`和`println()`都会在屏幕上显示引号之间的任何东西。但`println()`在完成打印后会移到新的一行，而`print()`不会：它会显示然后将光标留在行的末尾，以便下一个打印语句从同一位置开始。'
- en: You will also notice (on line 10) that we can have a `println()`  statement
    with nothing between the parentheses. No quotation marks or anything. That statement
    instructs the computer to print nothing, and then move the cursor to the beginning
    of the next line.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到（第10行）我们可以有一个`println()`语句，括号里什么都不写。没有引号或其他任何东西。这个语句指示计算机什么都不打印，然后将光标移动到下一行的开头。
- en: You may also notice that this program has some lines with nothing on them (lines
    7, 11, 14, 19 and 22). On the very first exercise, when I wrote that you must
    “match what I have written exactly, including spacing, punctuation, and capitalization”,
    I wasn’t *quite* being honest. Extra blank lines in your code are
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还会注意到这个程序有一些空行（第7、11、14、19和22行）。在第一个练习中，当我写道你必须“完全匹配我写的内容，包括间距、标点和大写”，我并没有*完全*诚实。你的代码中多余的空行
- en: ignored by the Java compiler. You can put them in or remove them, and the program
    will work exactly the same.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 被Java编译器忽略。你可以把它们放进去或移除它们，程序将完全一样。
- en: My students often accuse me of being “full of lies.” This is true. I have learned
    the hard way that when students are just learning something as hard as programming,
    telling them the truth will confuse them too much. So I often over­simplify what
    I say, even when that makes it technically inaccurate.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我的学生经常指责我“充满谎言”。这是真的。我已经通过艰苦的方式学到，当学生只是在学习编程这样困难的东西时，告诉他们真相会让他们太困惑。所以我经常过分简化我说的话，即使这使得它在技术上不准确。
- en: If you already know how to program, and my “lies” offend you, then this book
    will be difficult to read. But for those that are just learning, I assure you
    that you want me to simplify things at first. I promise I’ll reveal the truth
    eventually.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经知道如何编程，而我的“谎言”冒犯了你，那么这本书将很难阅读。但对于那些刚开始学习的人，我向你保证，你希望我一开始简化事情。我保证最终会揭示真相。
- en: Anyway, on line 21, I did one more new thing. So far you have only been printing
    a single thing inside quotation marks. But it is perfectly fine to print more
    than one thing, as long as you combine those things before printing.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在第21行，我做了一件新的事情。到目前为止，你只在引号内打印了一个东西。但是完全可以打印多个东西，只要在打印之前将这些东西组合起来。
- en: '[So on line 21, I have six Strings](#bookmark25) 1 in quotation marks: the
    word “this”, a space, the word “is”, a space, the word “a”, and finally a space
    followed by “test” followed by a period. There is a plus sign (“`+`[”) between
    each of those six Strings, so there are a total of five plus signs on line 21\.
    When you put a plus sign between Strings, Java adds](#bookmark26) 2 them together
    to make one long thing­in­quotation marks, and then displays that all at once.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[因此，在第21行，我有六个字符串](#bookmark25)用引号括起来：单词“this”，一个空格，单词“is”，一个空格，单词“a”，最后是一个空格，后面跟着“test”和一个句号。在这六个字符串之间有一个加号（“`+`[”），因此在第21行总共有五个加号。当您在字符串之间放置加号时，Java会将它们](#bookmark26)
    2 加在一起，以形成一个长字符串，然后一次性显示所有内容。'
- en: If you have an error in your code, it is probably on line 21\. Remembering to
    start and stop all the quotes correctly and getting all those details right is
    tricky.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码出现错误，那么它可能在第21行。记住正确启动和停止所有引号并正确获取所有这些细节是棘手的。
- en: Today’s lesson was hopefully *relatively* easy. Don’t worry, I’ll make up for
    it on the next one.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的课程希望*相对*容易。别担心，我会在下一个课程中弥补的。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_005.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_005.png)'
- en: What is a “String”? A bunch of characters (letters, numbers, symbols) between
    a pair of quotation marks. I’ll explain more later.‌
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “String”是什么？一对引号之间的一堆字符（字母，数字，符号）。我稍后会解释更多。
- en: Technically combining smaller words to make a larger one is called “concatenation”,
    not “adding”. Java concatenates the Strings together.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从技术上讲，将较小的单词组合成较大的单词称为“连接”，而不是“添加”。 Java将字符串连接在一起。
- en: 'Exercise 4: Escape Sequences and Comments'
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4：转义序列和注释
- en: Have you thought about what might happen if we wanted to display a quotation
    mark on the screen? Since everything we want to display is contained between quotation
    marks in the `println()`  statement, putting a quote inside the quotes would be
    a problem.
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您是否考虑过如果我们想在屏幕上显示引号会发生什么？由于我们想要显示的所有内容都包含在`println()`语句的引号之间，因此在引号内放置引号将是一个问题。
- en: Most programming languages allow for “escape sequences”, where you signal with
    some sort of escape character that the next character you see shouldn’t be handled
    in the normal way.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数编程语言都允许“转义序列”，其中您使用某种转义字符来表示下一个字符不应以正常方式处理。
- en: The following (evil) code demonstrates a number of Java’s escape sequences.
    Call it
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下（邪恶）代码演示了Java的许多转义序列。称之为
- en: '`EscapeSequences.java`.'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EscapeSequences.java`。'
- en: '1'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '1'
- en: public class EscapeSequences
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class EscapeSequences
- en: '2'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '3'
- en: public static void main( String[] args )
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '4'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '4'
- en: '{'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '5'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: // Initial version created using FIGlet, font "Big Money", oriented southwest
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: //使用FIGlet创建的初始版本，字体为“Big Money”，向西南方向
- en: '6'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: System.out.print( "\t  \n\t / |\n\t JJJJJ |" );
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print("\t  \n\t / |\n\t JJJJJ |");
- en: '8'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: System.out.println( "             " );
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("       ");
- en: '9'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: System.out.println( "\t JJ | / \\ / \\ / |/ \\" );
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\t JJ | / \\ / \\ / |/ \\");
- en: '10'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: System.out.println( "\t    JJ | aaaaaa |\"\" \\ /\"\"/ aaaaaa |" );
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\t   JJ | aaaaaa |\"\" \\ /\"\"/ aaaaaa |");
- en: '11'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: System.out.println( "\t/ | JJ | / aa | \"\" /\"\"/ / aa |" );
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\t/ | JJ | / aa | \"\" /\"\"/ / aa |");
- en: '12'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: System.out.println( "\tJJ \\  JJ |/aaaaaaa | \"\" \"\"/ /aaaaaaa |" );
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\tJJ \\  JJ |/aaaaaaa | \"\" \"\"/ /aaaaaaa |");
- en: '13'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: System.out.println( "\tJJ JJ/ aa aa | \"\"\"/ aa aa |" );
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\tJJ JJ/ aa aa | \"\"\"/ aa aa |");
- en: '14'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: System.out.println( "\t JJJJJJ/ aaaaaaa/ \"/ aaaaaaa/" );
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println("\t JJJJJJ/ aaaaaaa/ \"/ aaaaaaa/");
- en: '15'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: '}'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '16'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: '}'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE32]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: JJJJJ |
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JJJJJ |
- en: '[PRE34]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: JJ | aaaaaa |"" \ /""/ aaaaaa |
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JJ | aaaaaa |"" \ /""/ aaaaaa |
- en: '[PRE35]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When you run it, this is what you should see.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您运行它时，您应该看到的是这样的。
- en: Java’s escape character is a backslash (“`\`”), which is the same key you press
    to make a pipe (“`|`”) show up but without holding Shift. All escape sequences
    in Java must be inside a set of quotes.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java的转义字符是反斜杠（“\”），这与您按下以使管道（“|”）显示出来的相同键，但不需要按住Shift。 Java中的所有转义序列都必须在一组引号内。
- en: '`\"`  represents a quotation mark.'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\"`代表引号。'
- en: '`\t`  is a tab; it is the same as if you pressed the Tab key while typing your
    code. It probably seems more complicated now because you’ve never seen it before,
    but when you’re reading someone else’s code a'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\t`是一个制表符；这就像您在键入代码时按Tab键一样。现在它可能看起来更复杂，因为您以前从未见过它，但是当您阅读别人的代码时'
- en: '`\t`  inside the quotes is less ambiguous than a bunch of blank spaces that
    might be spaces or might be a tab.'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 引号内的`\t`不如一堆可能是空格或制表符的空格不明确。
- en: '`\n`  is a newline. When printing it will cause the output to move down to
    the beginning of the next line before continuing printing.'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\n`是一个换行符。在打印时，它将导致输出移到下一行的开头，然后继续打印。'
- en: '`\\`  is how you display a backslash.'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`\\`是显示反斜杠的方法。'
- en: On line 5 you will notice that the line begins with two slashes (or “forward
    slashes”, if you insist). This marks the line as a “comment”, which is in the
    program for the human programmers’ benefit. Comments are totally ignored by the
    computer.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第5行，您会注意到该行以两个斜杠（或“正斜杠”，如果您坚持的话）开头。这标记了该行为“注释”，这是程序员的人为利益。计算机完全忽略注释。
- en: 'In fact, the two slashes to mark a comment don’t have to be at the beginning
    of the line; we could write something like this:'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，用两个斜杠标记注释的行不一定要在行的开头；我们可以写这样的东西：
- en: '[PRE36]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: …and it would totally work. Everything from the two slashes to the end of that
    line is ignored by the compiler.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...它完全有效。从两个斜杠到该行末尾的所有内容都将被编译器忽略。'
- en: (That’s not a very good comment, though; any programmer who knows Java already
    knows what that line of code does. In general you should put comments explaining
    why the code is there, not what the code does. You’ll get better at writing good
    comments as you get better at coding in general.)
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （尽管这不是一个很好的评论；但是，任何了解Java的程序员都已经知道该行代码的作用。通常，您应该放置解释代码存在的原因的注释，而不是代码的作用。随着您在编码方面的技能提高，您将更擅长编写良好的注释。）
- en: Anyway, this one was a tough one, so no Study Drills this time. The next exercise
    will feature something new and return to normal difficulty.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，这个练习很难，所以这次没有学习任务。下一个练习将介绍一些新内容，并恢复正常难度。
- en: 'Exercise 5: Saving Information in Variables'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5：在变量中保存信息
- en: Programs would be pretty boring if the only thing you could do was print things
    on the screen. We would like our programs to be interactive.
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果程序只能在屏幕上打印东西，那就太无聊了。我们希望我们的程序是互动的。
- en: Unfortunately, interactivity requires several different concepts working together,
    and explaining them all at once might be confusing. So I am going to cover them
    one at a time.
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，互动需要几个不同的概念共同工作，一次解释所有这些可能会令人困惑。所以我会一个一个地介绍它们。
- en: 'First up: variables! If you have ever taken an Algebra class, you are familiar
    with the concept of variables in mathematics. Programming languages have variables,
    too, and the basic concept is the same:'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先是：变量！如果你上过代数课，你就会熟悉数学中的变量概念。编程语言也有变量，基本概念是一样的：
- en: '“A variable is a name that refers to a location that holds a value.” Variables
    in Java have four major differences from math variables:'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: “变量是指向保存值的位置的名称。” Java中的变量与数学变量有四个主要区别：
- en: Variable names can be more than one letter long.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名可以超过一个字母长。
- en: Variables can hold more than just numbers; they can hold words.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量不仅可以保存数字，还可以保存单词。
- en: You have to choose what type of values the variable will hold when the variable
    is first created.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当变量首次创建时，你必须选择变量将保存的值的类型。
- en: The value of a variable (but not its type) can change throughout the program.
    The variable `score`  might start out with a value of `0`, but by the end of the
    program, `score`  might hold the value `413500`  instead.
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的值（但不是它的类型）可以在程序中改变。变量`score`可能一开始的值是`0`，但到程序结束时，`score`可能保存的值是`413500`。
- en: Okay, enough discussion. Let’s get to the code! I’m not going to tell you what
    the name of the file is supposed to be. You’ll have to figure it out for yourself.
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，讨论够了。让我们开始写代码吧！我不会告诉你文件的名字应该是什么。你得自己弄清楚。
- en: '1'
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '1'
- en: public class CreatingVariables
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public class CreatingVariables
- en: '2'
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '2'
- en: '{'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '3'
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '3'
- en: public static void main( String[] args )
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main( String[] args )
- en: '4'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '4'
- en: '{'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '5'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: int x, y, age;
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: int x, y, age;
- en: '6'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: double seconds, e, checking;
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: double seconds, e, checking;
- en: '7'
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: String firstName, last_name, title;
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: String firstName, last_name, title;
- en: '8'
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: x = 10;
  id: totrans-449
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: x = 10;
- en: '10'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: y = 400;
  id: totrans-451
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: y = 400;
- en: '11'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: age = 39;
  id: totrans-453
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: age = 39;
- en: '12'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-455
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: seconds = 4.71;
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: seconds = 4.71;
- en: '14'
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: e = 2.71828182845904523536;
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: e = 2.71828182845904523536;
- en: '15'
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: checking = 1.89;
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: checking = 1.89;
- en: '16'
  id: totrans-461
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: firstName = "Graham";
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: firstName = "Graham";
- en: '18'
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: last_name = "Mitchell";
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: last_name = "Mitchell";
- en: '19'
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: title = "Mr.";
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: title = "Mr.";
- en: '20'
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: System.out.println( "The variable x contains " + x );
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "变量x包含" + x );
- en: '22'
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '22'
- en: System.out.println( "The value " + y + " is stored in the variable y." );
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "变量y中存储的值为" + y );
- en: '23'
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '23'
- en: System.out.println( "The experiment completed in " + seconds + " seconds." );
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "实验在" + seconds + "秒内完成。" );
- en: '24'
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '24'
- en: 'System.out.println( "My favorite irrational number is Euler''s constant: "
    + e );'
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "我最喜欢的无理数是欧拉常数：" + e );
- en: '25'
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '25'
- en: System.out.println( "Hopefully your balance is more than $" + checking + "!"
    );
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "希望你的余额超过$" + checking + "！" );
- en: '26'
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '26'
- en: System.out.println( "My full name is " + title + " " + firstName + last_name
    );
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "我的全名是" + title + " " + firstName + last_name );
- en: '27'
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '27'
- en: '}'
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '28'
  id: totrans-483
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '28'
- en: '}'
  id: totrans-484
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: What You Should See
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE37]'
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[On lines 5 through 7 we declare](#bookmark30)3 nine variables. The first three
    are named *x*, *y*, and *age*. All three of these variables are “integers”, which
    is the type of variable that can hold a value between ± two billion.'
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[在第5到7行，我们声明](#bookmark30)了九个变量。前三个分别命名为*x*，*y*和*age*。这三个变量都是“整数”，这是一种可以保存±两十亿之间的值的变量类型。'
- en: A variable which is an integer could hold the value `10`. It could hold the
    value `­8192`. An integer variable can hold `123456789`. It could not hold the
    value `3.14`  because that has a fractional part. An integer variable could not
    hold the value `10000000000`  because ten billion is too big.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个整数变量可以保存值`10`。它可以保存值`­8192`。一个整数变量可以保存`123456789`。它不能保存值`3.14`，因为这有小数部分。一个整数变量也不能保存值`10000000000`，因为一百亿太大了。
- en: On line 6 we declare variables named *seconds*, *e*, and *checking*. These three
    variables are “doubles”, which is the type of variable that can hold a number
    that might have a fractional part.
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第6行，我们声明了变量*seconds*，*e*和*checking*。这三个变量都是“double”，这是一种可以保存可能有小数部分的数字的变量类型。
- en: A variable which is a double could hold the value `4.71`. It could hold the
    value `­8192`. (It may have a fractional part but doesn’t have to.) It can pretty
    much hold any value between ± 1.79769 × 10308 and 4.94065 × 10­324.
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个双精度变量可以保存值`4.71`。它可以保存值`­8192`。（它可能有小数部分，但不一定有。）它几乎可以保存± 1.79769 × 10308和4.94065
    × 10­324之间的任何值。
- en: However, doubles have limited precision. Notice that on line 14 I store the
    value `2.71828182845904523536`  into the variable named e, but when I print out
    that value on line 24, only `2.718281828459045`  comes out. Doubles do not have
    enough significant figures to hold the value `2.71828182845904523536`  precisely.
    Integers have perfect precision, but can only hold whole numbers and can’t hold
    huge huge values.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，双精度有限的精度。请注意，在第14行，我将值`2.71828182845904523536`存储到名为e的变量中，但当我在第24行打印出该值时，只有`2.718281828459045`出现。双精度没有足够的有效数字来精确保存值`2.71828182845904523536`。整数具有完美的精度，但只能保存整数，不能保存巨大的值。
- en: 'The last type of variable we are going to look at in this exercise is the `String`.
    On line 7 we declare three String variables: firstName, last_name and title. String
    variables can hold words and phrases; the name is short for “string of characters”.'
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这个练习中要看的最后一种变量类型是`String`。在第7行，我们声明了三个String变量：firstName，last_name和title。String变量可以保存单词和短语；名称缩写为“字符串”。
- en: '[On lines 9 through 11 we initialize](#bookmark31)4 the three integer values.
    The value `10`  is stored into x. Before this point, the variable x exists, but
    its value is undefined. `400`  is stored into y and `39`  is stored into the variable
    age.'
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[在第9到11行，我们初始化](#bookmark31)4三个整数值。值`10`被存储到x中。在此之前，变量x存在，但其值未定义。`400`被存储到y中，`39`被存储到变量age中。'
- en: Lines 13 through 15 give initial values to the three double variables, and lines
    17 through 19 initialize the three String variables. Then lines 21 through 26
    display the values of those variables on the screen. Notice that the variable
    names are not surrounded by quotes.
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第13到15行给三个双精度变量赋初始值，第17到19行初始化了三个字符串变量。然后第21到26行在屏幕上显示了这些变量的值。请注意，变量名没有用引号括起来。
- en: I know that it doesn’t make sense to use variables for a program like this,
    but soon everything will become clear.
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我知道对于这样的程序使用变量是没有意义的，但很快一切都会变得清晰起来。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_008.png)'
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_008.png)'
- en: declare ­ to tell the program the name (or “identifier”) and type of a variable.‌
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明-告诉程序变量的名称（或“标识符”）和类型。‌
- en: initialize ­ to give a variable its first (or “initial”) value.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化-给变量赋予其第一个（或“初始”）值。
- en: 'Exercise 6: Mathematical Operations'
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6：数学运算
- en: '[PRE38]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that we know how to declare and initialize variables in Java, we can do
    some mathematics with those variables.
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们知道如何在Java中声明和初始化变量，我们可以用这些变量进行一些数学运算。
- en: '[PRE39]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What You Should See
  id: totrans-503
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE40]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The plus sign (`+`[) will add two integers or two doubles together, or one integer
    and one double (in either order). With two Strings (like on line 34) it will concatenate](#bookmark35)5
    the two Strings together.
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加号（`+`[）将两个整数或两个双精度数相加，或一个整数和一个双精度数（顺序不限）。对于两个字符串（就像在第34行），它将把这两个字符串连接在一起。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_010.png)'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_010.png)'
- en: “concatenate” ­ to join character Strings end­to­end.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “连接”-将字符字符串端对端连接。
- en: The minus sign (`­`) will subtract one number from another. Just like addition,
    it works with two integers, two doubles, or one integer and one double (in either
    order).
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 减号（`-`）将一个数字减去另一个数字。就像加法一样，它适用于两个整数、两个双精度数，或一个整数和一个双精度数（顺序不限）。
- en: An asterisk (`*`) is used to represent multiplication. You can also see on line
    17 that Java knows about the correct order of operations. b is multiplied by 3
    giving `81`  and then a is added.
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 星号（`*`）用于表示乘法。您还可以在第17行看到Java知道正确的运算顺序。b乘以3得到`81`，然后加上a。
- en: A slash (`/`) is used for division. Notice that when an integer is divided by
    another integer (like on line 19) the result is also an integer and not a double.
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 斜杠（`/`）用于除法。请注意，当一个整数被另一个整数除（就像在第19行），结果也是一个整数而不是一个双精度数。
- en: The percent sign (`%`) is used to mean ‘modulus’, which is essentially the remainder
    left over after dividing. On line 21, b is divided by `10`  and the remainder
    (`7`) is stored into the variable g.
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 百分号（`%`）用于表示“模数”，本质上是除法后剩下的余数。在第21行，b被`10`除，余数（`7`）被存储到变量g中。
- en: Common Student Questions
  id: totrans-512
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见学生问题
- en: Why is `1.1`  times `1.1`  equal to `1.2100000000000002`  instead of just `1.21`?
    Why is 0.333333 + 0.666666 equal to 0.999999 instead of 1.0? Sometimes with math
    we get repeating decimals, and most computers convert numbers into binary before
    working with them. It turns out that `1.1`  is a repeating decimal in binary.
  id: totrans-513
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么`1.1`乘以`1.1`等于`1.2100000000000002`而不是`1.21`？为什么0.333333 + 0.666666等于0.999999而不是1.0？有时候在数学中我们会得到重复的小数，大多数计算机在处理它们之前会将数字转换为二进制。结果是`1.1`在二进制中是一个重复的小数。
- en: 'Remember what I said in the last exercise: the problem with doubles is limited
    precision. You will mostly be able to ignore that fact in this book, but I would
    like you to keep in the back of your mind that double variables sometimes give
    you values that are *slightly* different than you’d expect.'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住我在上一个练习中说的：双精度的问题在于有限的精度。在本书中，你大多数时候可以忽略这个事实，但我希望你能记住双精度变量有时会给出*略微*不同于你期望的值。
- en: 'Exercise 7: Getting Input from a Human'
  id: totrans-515
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7：从人类那里获取输入
- en: 'Now that we have practiced creating variables for a bit, we are going to look
    at the other part of interactive programs: letting the human who is running our
    program have a chance to type something.'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经练习了一段时间创建变量，我们将看看交互式程序的另一部分：让运行我们程序的人有机会输入一些内容。
- en: Go ahead and type this up, but notice that the first line in the program is
    not the `public class`  line. This time we start with an “import” statement.
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续输入这个，但请注意程序中的第一行不是`public class`行。这次我们从一个“导入”语句开始。
- en: '[Not every program needs to get interactive input from a human using the keyboard,
    so this is not part of the core of the Java language. Just like a Formula 1 race
    car does not include an air conditioner, programming languages usually have a
    small core and then lots of optional libraries](#bookmark38)6 that can be included
    if desired.'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[并非每个程序都需要从键盘获取人类的交互输入，因此这不是Java语言核心的一部分。就像一辆F1赛车不包括空调一样，编程语言通常有一个小的核心，然后有很多可选的库](#bookmark38)6，如果需要可以包含进来。'
- en: 1 import java.util.Scanner; 2
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 import java.util.Scanner; 2
- en: 3 public class ForgetfulMachine
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 public class ForgetfulMachine
- en: 4 {
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4 {
- en: '5'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: public static void main( String[] args )
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main( String[] args )
- en: '6'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '{'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '7'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scanner keyboard = new Scanner(System.in);
- en: '8'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: System.out.println( "What city is the capital of France?" );
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "法国的首都是哪个城市？" );
- en: '10'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: keyboard.next();
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: keyboard.next();
- en: '11'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: System.out.println( "What is 6 multiplied by 7?" );
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "6乘以7等于多少？" );
- en: '13'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: keyboard.nextInt();
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: keyboard.nextInt();
- en: '14'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: System.out.println( "What is your favorite number between 0.0 and 1.0?" );
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "你最喜欢的数字是多少？在0.0和1.0之间" );
- en: '16'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: keyboard.nextDouble();
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: keyboard.nextDouble();
- en: '17'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: '18'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: System.out.println( "Is there anything else you would like to tell me?" );
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "还有什么你想告诉我的吗？" );
- en: '19'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: keyboard.next();
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: keyboard.next();
- en: '20'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '}'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '21'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: '}'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'When you first run this program, it will only print the first line:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你第一次运行这个程序时，它只会打印第一行：
- en: '[PRE41]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: …and then it will blink the cursor at you, waiting for you to type in a word.
    When I ran the program, I typed the word “Paris”, but the program will work the
    same even if you type a different word.
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后它会在屏幕上闪烁光标，等待你输入一个单词。当我运行程序时，我输入了单词“巴黎”，但即使你输入一个不同的单词，程序也会正常工作。
- en: 'Then after you type a word and press Enter, the program will continue, printing:'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在你输入一个单词并按回车后，程序将继续打印：
- en: '[PRE42]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '…and so on. Assuming you type in reasonable answers to each question, it will
    end up looking like this:'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ……等等。假设你对每个问题都输入了合理的答案，最终看起来会像这样：
- en: What You Should See
  id: totrans-558
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE43]'
  id: totrans-559
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_011.png)'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image]（Learn%20Java%20the%20Hard%20Way_files/Image_011.png）'
- en: library or “module” ­ a chunk of code that adds extra functionality to a program
    and which may or may not be included.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库或“模块”——添加额外功能到程序中的一段代码，可能包含或不包含。
- en: So let us talk about the code. On line 1 we have an `import`  statement. The
    library we import is the scanner library `java.util.Scanner`  (“java dot util
    dot Scanner”). This library contains functionality that allows us to read in information
    from the keyboard or other places like files or the Internet.
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来谈谈代码。在第1行，我们有一个`import`语句。我们导入的库是scanner库`java.util.Scanner`（“java点util点Scanner”）。这个库包含的功能允许我们从键盘或其他地方（如文件或互联网）读取信息。
- en: 'Lines 2 through 7 are hopefully boring. On line 8 we see something else new:
    we create a “Scanner object” named “keyboard”. (It doesn’t have to be named “keyboard”;
    you could use a different word there as long as you use it everywhere in your
    code.) This Scanner object named keyboard contains abilities we’ll call functions
    or “methods”. You must create and name a Scanner object before you can use one.'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第2行到第7行希望是无聊的。在第8行，我们看到了另一件新事物：我们创建了一个名为“keyboard”的“Scanner对象”。（它不一定要被命名为“keyboard”；你可以在这里使用一个不同的词，只要你在你的代码中到处使用它。）这个名为keyboard的Scanner对象包含我们将称之为函数或“方法”的能力。在你使用之前，你必须创建并命名一个Scanner对象。
- en: On line 10 we ask the Scanner object named keyboard to do something for us.
    We say “Keyboard, run your `next()`  function.” The Scanner object will pause
    the program and wait for the human to type something. Once the human types something
    and presses Enter, the Scanner object will package it into a String and allow
    your code to continue.
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第10行，我们要求名为keyboard的Scanner对象为我们做一些事情。我们说“键盘，运行你的`next（）`函数。”Scanner对象将暂停程序，等待人类输入。一旦人类输入内容并按回车，Scanner对象将把它打包成一个字符串，并允许你的代码继续。
- en: On line 13 we ask the Scanner object to execute its `nextInt()`  function. This
    pauses the program, waits for the human to type something and press Enter, then
    packages it into an integer value (if possible) and continues.
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第13行，我们要求Scanner对象执行其`nextInt（）`函数。这会暂停程序，等待人类输入并按回车，然后将其打包成整数值（如果可能的话）并继续。
- en: What if the human doesn’t type an integer here? Try running the program again
    and type `41.9`  as the answer to the second question.
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果人类在这里没有输入整数会怎么样？再次运行程序，然后在第二个问题的答案中输入`41.9`。
- en: 'The program blows up and doesn’t run any other statements because `41.9`  can
    not be packaged into an integer value: `41.9`  is a `double`. Eventually we will
    look at ways to handle error­checking for issues like this, but in the meantime,
    if the human types in something incorrectly which blows up our program, we will
    blame the human for not following directions and not worry about it.'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该程序会因为`41.9`无法被打包成整数值而爆炸：`41.9`是一个`double`。最终，我们将研究如何处理类似问题的错误检查，但与此同时，如果人类输入了错误的内容导致程序崩溃，我们会责怪人类没有遵循指示，而不会担心这个问题。
- en: Line 16 lets the human type in something which the Scanner object will attempt
    to convert into a double value, and line 19 lets the human type in a String. (Anything
    can be packaged as a String, including numbers, so this isn’t likely to fail.)
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第16行让人类输入一个Scanner对象将尝试转换为double值的内容，第19行让人类输入一个字符串。（任何东西都可以被打包为字符串，包括数字，所以这不太可能失败。）
- en: Try running the program several more times, noticing when it blows up and when
    it doesn’t.
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尝试多次运行程序，注意何时会崩溃，何时不会。
- en: 'Exercise 8: Storing the Human’s Responses'
  id: totrans-570
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8：存储人类的回答
- en: 1 import java.util.Scanner; 2
  id: totrans-571
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 import java.util.Scanner; 2
- en: 3 public class RudeQuestions 4 {
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 public class RudeQuestions 4 {
- en: '5'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: '14'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: '18'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: '19'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '22'
- en: '23'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '23'
- en: public static void main( String[] args )
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main（String[] args）
- en: '{'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: String name; int age;
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: String name; int age;
- en: double weight, income;
  id: totrans-595
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: double weight, income;
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scanner keyboard = new Scanner（System.in）;
- en: System.out.print( "Hello. What is your name? " ); name = keyboard.next();
  id: totrans-597
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print（“你好。你叫什么名字？“）；name = keyboard.next（）；
- en: System.out.print( "Hi, " + name + "! How old are you? " ); age = keyboard.nextInt();
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print（“你好，”+姓名+“！你多大了？”）；年龄=keyboard.nextInt（）；
- en: System.out.println( "So you're " + age + ", eh? That's not old at all." ); System.out.print(
    "How much do you weigh, " + name + "? " );
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println（“所以你”+年龄+“岁了？一点都不老。”）；System.out.print（“你的体重是多少，”+姓名+“？”）；
- en: weight = keyboard.nextDouble();
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 体重=keyboard.nextDouble（）；
- en: System.out.print( weight + "! Better keep that quiet. Finally, what's your income,
    " +
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print（体重+“！最好保持安静。最后，你的收入是多少，”+
- en: name + "? " );
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name +“？”）；
- en: '24'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '24'
- en: '25'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '25'
- en: '26'
  id: totrans-605
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '26'
- en: '27'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '27'
- en: '28'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '28'
- en: 29 }
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 29 }
- en: income = keyboard.nextDouble();
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 收入=keyboard.nextDouble（）；
- en: System.out.println( "Hopefully that is " + income + " per hour and not per year!"
    ); System.out.println( "Well, thanks for answering my rude questions, " + name
    + "." );
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println（“希望这是每小时的收入，而不是每年的收入！”）；System.out.println（“好吧，谢谢你回答我的粗鲁问题，”+姓名+“。”）；
- en: '}'
  id: totrans-611
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: In the last exercise, you learned how to pause the program and allow the human
    to type in something. But what happened to what was typed? When you typed in the
    answer “Paris” for the first question, where did that answer go? Well, it was
    thrown away right after it was typed because we didn’t put any instructions to
    tell the Scanner object where to store it. So that is the topic of today’s lesson.
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个练习中，你学会了如何暂停程序并允许人类输入一些东西。但是输入的内容发生了什么？当你为第一个问题输入“巴黎”时，答案去哪了？嗯，它在输入后立即被丢弃了，因为我们没有放置任何指令告诉Scanner对象在哪里存储它。所以这就是今天课程的主题。
- en: (Sorry that line 23 wraps like that. I didn't want to make the font tiny just
    on account of that one line. Just type it all on one line like usual.)
  id: totrans-613
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （抱歉，第23行像那样换行了。我不想因为那一行而使字体变得微小。就像平常一样，把它都写在一行上。）
- en: 'Just like the last exercise, when you first run this your program will only
    display the first question and then pause, waiting for a response:'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像上一个练习一样，当你第一次运行这个程序时，它只会显示第一个问题，然后暂停，等待回答。
- en: '[PRE44]'
  id: totrans-615
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that because that first printing statement on line 13 is `print()`  rather
    than `println()`, the cursor is left blinking at the end of the line the question
    is on. If you had used `println()`, the cursor would blink on the beginning of
    the next line instead.
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，因为第13行的第一个打印语句是`print()`而不是`println()`，光标会留在问题所在行的末尾闪烁。如果你使用了`println()`，光标会在下一行的开头闪烁。
- en: What You Should See
  id: totrans-617
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE45]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At the top of the program we declared four variables: one String variable named
    *name*, one integer variable named *age*, and two double variables named *weight*
    and *income*.'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在程序的顶部，我们声明了四个变量：一个名为*name*的字符串变量，一个名为*age*的整数变量，以及两个名为*weight*和*income*的双精度变量。
- en: On line 14 we see the `keyboard.next()`  that we know from the previous exercise
    will pause the program and let the human type in something it will package up
    in a String. So now where does the String they type go? In this case, we are storing
    that value into the String variable named “name”. The String value gets stored
    into a String variable. Nice.
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第14行，我们看到了`keyboard.next()`，我们知道它来自上一个练习，它会暂停程序并让人类输入一些东西，然后将其打包成一个字符串。那么他们输入的字符串去哪了呢？在这种情况下，我们将该值存储到名为“name”的字符串变量中。字符串值被存储到了一个字符串变量中。不错。
- en: So, assuming you type `Brick`  for your name, the String value `"Brick"`  gets
    stored into the variable name on line 14\. This means that on line 16, we can
    display that value on the screen! That’s pretty cool, if you ask me.
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以，假设你在第14行为你的名字输入了`Brick`，字符串值`"Brick"`就会被存储到第14行的变量名中。这意味着在第16行，我们可以在屏幕上显示该值！如果你问我，这相当酷。
- en: On line 17 we ask the Scanner object to let the human type in something which
    it will try to format as an integer, and then that value will be stored into the
    integer variable named *age*. We display that value on the screen on line 19.
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第17行，我们要求Scanner对象让人类输入一些东西，它将尝试将其格式化为整数，然后该值将被存储到名为*age*的整数变量中。我们在第19行将该值显示在屏幕上。
- en: Line 21 reads in a double value and stores it into *weight*, and line 24 reads
    in another double value and stores it into *income*.
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第21行读取一个双精度值并将其存储到*weight*中，第24行读取另一个双精度值并将其存储到*income*中。
- en: This is a really powerful thing. With some variables and with the help of the
    Scanner object, we can now let the human type in information, and we can remember
    it in a variable to use later in the program!
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一件非常强大的事情。有了一些变量和Scanner对象的帮助，我们现在可以让人类输入信息，并且可以在程序中稍后使用变量来记住它！
- en: Before I wrap up, notice for example that the variable *income* is declared
    all the way up on line 9 (we choose its name and type), but it is undefined (it
    doesn’t have a value) until line 24\. On line 24 *income* is finally initialized
    (given its first value of the program). If you had attempted to print the value
    of *income* on the screen prior to line 24, the program would not have compiled.
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我结束之前，注意例如变量*income*在第9行上被声明（我们选择了它的名称和类型），但直到第24行之前它都是未定义的（它没有值）。在第24行*income*最终被初始化（给出了程序的第一个值）。如果你在第24行之前尝试打印*income*的值，程序将无法编译。
- en: Anyway, play with typing in different answers to the questions and see if you
    can get the program to blow up after each question.
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，尝试输入不同的答案来回答问题，并看看你是否能在每个问题后让程序崩溃。
- en: 'Exercise 9: Calculations with User Input'
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习9：使用用户输入进行计算
- en: Now that we know how to get input from the user and store it into variables
    and since we know how to do some basic math, we can now write our first *useful*
    program!
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 既然我们知道如何从用户那里获取输入并将其存储到变量中，而且我们也知道如何进行一些基本的数学运算，我们现在可以编写我们的第一个*有用*的程序了！
- en: '[PRE46]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What You Should See
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE47]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This exercise is (hopefully) pretty straightforward. We have three variables
    (all doubles): *m* (meters), *kg* (kilograms) and *bmi* (body mass index). We
    read in values for *m* and *kg*, but *bmi*’s value comes not from the human but
    as the result of a calculation. On line 16 we compute the mass divided by the
    square of the height and store the result into *bmi*. And then we print it out.'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习（希望）相当简单。我们有三个变量（都是双精度）：*m*（米）、*kg*（千克）和*bmi*（身体质量指数）。我们读取*m*和*kg*的值，但*bmi*的值不是来自人类，而是计算的结果。在第16行，我们计算质量除以身高的平方，并将结果存储到*bmi*中。然后我们将其打印出来。
- en: The body mass index (BMI) is commonly used by health and nutrition professionals
    to estimate human body fat in populations. So this result would be informative
    for a health professional. For now that’s all we can do with it.
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 身体质量指数（BMI）通常被健康和营养专业人员用来估计人群的体脂肪。因此，这个结果对健康专业人员来说是有信息价值的。目前我们只能做到这些。
- en: Eventually we will learn how to display a different message on the screen *depending*
    on what the BMI equals, but for now this will have to do.
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终，我们将学会如何根据BMI的值在屏幕上显示不同的消息，但目前这就够了。
- en: A pretty easy assignment for today, but I have some challenges for you in the
    Study Drills that should make things a bit tougher.
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 今天是一个相当简单的任务，但我在学习挑战中为你准备了一些挑战，应该会让事情变得更加困难。
- en: Study Drills
  id: totrans-636
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习挑战
- en: Add some variables and change the program so that the human can input their
    weight and height using pounds and inches, and then convert those values to kilograms
    and meters to figure the BMI.
  id: totrans-637
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些变量并更改程序，以便人类可以使用磅和英寸输入他们的体重和身高，然后将这些值转换为千克和米，以计算BMI。
- en: '[PRE48]'
  id: totrans-638
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Make it so the human can input their height in feet and inches separately.
  id: totrans-639
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使人类可以分别输入他们的身高，一个是英尺，一个是英寸。
- en: '[PRE49]'
  id: totrans-640
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Exercise 10: Variables Only Hold Values'
  id: totrans-641
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10：变量只能保存值
- en: Okay, now that we can get input from the human and do calculations with it,
    I want to call attention to something that many of my students get confused about.
    The following code should compile, but it probably will not work the way you expect.
  id: totrans-642
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，现在我们可以从人类那里获取输入并进行计算，我想要引起一些我的学生经常感到困惑的事情的注意。以下代码应该可以编译，但它可能不会按照你的期望工作。
- en: I have intentionally made a *logical* error in the code. It is not a problem
    with the syntax (the part of the code the compiler cares about), and it is not
    a runtime error like you get when the human types a double when the Scanner object
    is expecting an integer. This logical error is a flaw with how I have designed
    the flow of instructions, so that the output is not what I was trying to accomplish.
  id: totrans-643
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我故意在代码中制造了一个*逻辑*错误。这不是语法问题（编译器关心的代码部分），也不是运行时错误，比如当人类在期望整数时，Scanner对象接收到了一个双精度数。这个逻辑错误是我设计指令流程的缺陷，导致输出不是我想要实现的。
- en: '[PRE50]'
  id: totrans-644
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: What You Should See
  id: totrans-645
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: Are you surprised by the output? Did you expect the sales tax on $7.99 to show
    something like $0.66 instead of a big fat zero? And the total cost should have
    been something like $8.65, right? What happened?
  id: totrans-646
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你对输出感到惊讶吗？你是否期望$7.99的销售税显示为$0.66而不是一个大大的零？总成本应该是$8.65，对吧？发生了什么？
- en: What happened is that in Java (and most programming languages), *variables can
    not hold formulas*. Variables can only hold values.
  id: totrans-647
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生的是，在Java（以及大多数编程语言中），*变量不能保存公式*。变量只能保存值。
- en: Look at line 12\. My students sometimes think that line stores the formula `price
    * 0.0825`  into the variable salesTax and then later the human stores the value
    `7.99`  into the variable price. They think that on line 19 when we print out
    salesTax that the computer then “runs” the formula somehow.
  id: totrans-648
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看第12行。我的学生有时会认为该行将公式`price * 0.0825`存储到变量salesTax中，然后稍后人类将值`7.99`存储到变量price中。他们认为在第19行打印salesTax时，计算机会以某种方式“运行”该公式。
- en: This is not what happens. In fact, this program shouldn’t have even compiled.
    The variable *price* doesn’t even have a proper value on line 12\. The only reason
    it does have a value is because I did something sneaky on line 10.
  id: totrans-649
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上并不是这样的。事实上，这个程序甚至不应该编译。变量*price*在第12行甚至没有一个合适的值。它之所以有一个值，只是因为我在第10行做了一些狡猾的事情。
- en: Normally we have been declaring variables up at the top of our programs and
    then initializing them later. But on line 10 I declared price and initialized
    it with a value of `0`. When you declare and initialize a variable at the same
    time, that is called “defining” the variable. salesTax and total are not defined
    on
  id: totrans-650
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常我们一直在程序的顶部声明变量，然后稍后初始化它们。但是在第10行，我声明了price并将其初始化为`0`。当你同时声明和初始化一个变量时，这被称为“定义”变量。salesTax和total在这里没有定义
- en: line 10, just declared.
  id: totrans-651
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第10行，只是声明。
- en: So then on line 16 the value the human types in doesn’t initialize price; price
    already has an initial value (`0`). But the value the human types in (`7.99`  or
    whatever) does get stored into the variable price here.
  id: totrans-652
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以在第16行，人类输入的值并没有初始化price；price已经有了一个初始值（`0`）。但是人类输入的值（`7.99`或其他值）确实被存储到变量price中。
- en: The `0`  is replaced with `7.99`.
  id: totrans-653
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`0`被替换为`7.99`。'
- en: From line 10 until 15 the variable price contains the value `0`. When line 16
    begins executing and while we are waiting for the human to type something, price
    still contains `0`. But by the time line 16 has completed, whatever the human
    typed has been stored into price, replacing the zero. Then from line 17 until
    the end of the program, the variable price contains the value `7.99`  (or whatever).
  id: totrans-654
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从第10行到第15行，变量price包含值`0`。当第16行开始执行并且我们在等待人类输入时，price仍然包含`0`。但是当第16行完成时，无论人类输入了什么，都已经存储到price中，替换了零。然后从第17行到程序结束，变量price包含值`7.99`（或其他值）。
- en: So with this in mind, we can figure out what really happens on line 12\. Line
    12 does not store a formula into salesTax but it does store a value. What value?
    It takes the value of the variable price at this point in the code (which is `0`),
    multiplies it by `0.0825`  (which is still zero), and then stores that zero into
    salesTax.
  id: totrans-655
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，考虑到这一点，我们可以弄清楚第12行实际发生了什么。第12行并没有将一个公式存储到salesTax中，但它确实存储了一个值。是什么值？它获取代码中此时变量price的值（即`0`），将其乘以`0.0825`（仍然是零），然后将这个零存储到salesTax中。
- en: As line 12 is beginning, the value of salesTax is undefined. (salesTax is declared
    but not defined.) By the end of line 12, salesTax holds the value `0`. There is
    no line of code that changes salesTax (there is no line of code that begins with
    `salesTax =`), so that value never changes and salesTax is still zero when it
    is displayed on line 19.
  id: totrans-656
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当第12行开始时，salesTax的值是未定义的（salesTax被声明但未定义）。到第12行结束时，salesTax的值为`0`。没有一行代码改变了salesTax（没有一行代码以`salesTax
    =`开头），因此该值永远不会改变，当它在第19行显示时，salesTax仍然是零。
- en: Line 13 is similar. It takes the value of *price* **right then** (zero) and
    adds it to the value of *salesTax* **right then** (also zero) and stores the sum
    (zero) into the variable *total*. And *total*’s value is never changed, and *total*
    does not somehow “remember” that its value came from a formula involving some
    variables.
  id: totrans-657
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第13行也是类似的。它获取*price*的值**此时**（零），并将其加到*salesTax*的值**此时**（也是零）中，并将总和（零）存储到变量*total*中。*total*的值没有改变，*total*也不会以某种方式“记住”它的值来自涉及一些变量的公式。
- en: So there you have it. Variables hold values, not formulas. Computer programs
    are not a set of rules, they are a *sequence* of instructions that the computer
    executes *in order*, and things later in your code depend on what happened before.
  id: totrans-658
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是全部内容。变量保存值，而不是公式。计算机程序不是一组规则，它们是计算机按顺序执行的一系列指令，你代码中的后续操作取决于之前发生的事情。
- en: Study Drills
  id: totrans-659
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: Remove the “ = 0“ on line 10, so that *price* no longer gets defined on line
    10, only declared. What happens when you try to compile the code? Does the error
    message make sense? (Now put the “ = 0“ back so that the program compiles again.)
  id: totrans-660
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除第10行的“= 0”，这样*price*就不再在第10行定义，只是声明。当你尝试编译代码时会发生什么？错误消息是否合理？（现在将“= 0”放回，以便程序再次编译。）
- en: Move the two lines of code that give values to *salesTax* and *total* so they
    occur after *price* has been given a proper value. Confirm that the program now
    works as expected.
  id: totrans-661
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将给*salesTax*和*total*赋值的两行代码移到*price*获得适当值之后。确认程序现在按预期工作。
- en: Now that these lines occur *after* the variable *price* has been properly given
    a real value, try removing the “ = 0“ on line 10 again. Does the program still
    give an error? Are you surprised?
  id: totrans-662
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在这些行发生在*price*变量被正确赋予真实值之后，再次尝试删除第10行的“= 0”。程序是否仍然报错？你感到惊讶吗？
- en: 'Exercise 11: Variable Modification Shortcuts'
  id: totrans-663
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11：变量修改快捷方式
- en: The value of a variable can change over time as your program runs. (It won’t
    change unless you write code to change it, but it *can* change is what I’m saying.)
  id: totrans-664
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量的值可以随着程序运行的时间而改变。（除非你编写代码来改变它，但我是说它*可以*改变。）
- en: In fact, this is pretty common. Something we do pretty often is take a variable
    and add something to it. For example, let’s say the variable x contains the value
    `10`. We want to add `2`  to it so that x now contains `12`.
  id: totrans-665
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，这是相当常见的。我们经常做的事情是取一个变量并对其进行加法。例如，假设变量x包含值`10`。我们想要加上`2`，这样x现在包含`12`。
- en: 'We can do this:'
  id: totrans-666
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以这样做：
- en: '[PRE51]'
  id: totrans-667
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will work, but it is annoying. If we want, we can take advantage of the
    fact that a variable can have one value at the beginning of a line of code and
    have a different value stored in it by the end. So we can write something like
    this:'
  id: totrans-668
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样做是可以的，但很烦人。如果我们愿意，我们可以利用一个变量可以在代码行的开头有一个值，并在结束时存储另一个值的事实。因此，我们可以写出这样的东西：
- en: '[PRE52]'
  id: totrans-669
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This also works. That second line says “take the current value of x (`10`),
    add `2`  to it, and store the sum
  id: totrans-670
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也可以。第二行表示“取x的当前值（`10`），加上`2`，并存储总和
- en: 'into the variable x. So when the second line of code begins executing x is
    `10`, and when it is done executing, x is 12\. The order of adding doesn’t matter,
    so we can even do something like this:'
  id: totrans-671
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到变量x。因此，当第二行代码开始执行时，x为`10`，执行完毕后，x为12。加法的顺序无关紧要，所以我们甚至可以这样做：
- en: '[PRE53]'
  id: totrans-672
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-673
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: …which is identical to the previous example. Okay, now to the code!
  id: totrans-674
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …这与前一个例子相同。好的，现在来看代码！
- en: '[PRE55]'
  id: totrans-675
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-676
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-677
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What You Should See
  id: totrans-678
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE58]'
  id: totrans-679
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Hopefully lines 1­21 are nice and boring. We create three variables, give them
    values, display them, change their values and print them again. Then starting
    on line 17 we give the variables the same values they started with and print them.
  id: totrans-680
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 希望第1-21行很好很无聊。我们创建三个变量，给它们赋值，显示它们，改变它们的值，然后再次打印它们。然后从第17行开始，我们给变量相同的值，并打印它们。
- en: 'On line 22 we see something new: a shortcut called a “compound assignment operator.”
    The `i += 3`  means the same as `i = i + 3`: “take the current value of i, add
    `3`  to it, and store the result as the new value of i. When we say it out loud,
    we would say “i plus equals 3.”'
  id: totrans-681
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第22行，我们看到了一些新东西：一种称为“复合赋值运算符”的快捷方式。`i += 3`的意思与`i = i + 3`相同：“取i的当前值，加上`3`，并将结果存储为i的新值。当我们大声说出来时，我们会说“i加3”。
- en: On line 23 we see `­=`  (“minus equals”), which subtracts 3 from k, and line
    24 demonstrates `*=`, which multiplies. There is also `/=`, which divides whatever
    variable is on the left­hand side by whatever value the right­hand side ends up
    equaling. (“Modulus equals” (`%=`) also exists, which sets the variable on the
    left­hand side equal to whatever the remainder is when its previous value is divided
    by whatever is on the right. Whew.)
  id: totrans-682
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第23行，我们看到`­=`（“减等于”），从k中减去3，第24行演示了`*=`，表示乘法。还有`/=`，它将左边的变量除以右边的值。还有“模等于”（`%=`），它将左边的变量设置为其先前值除以右边的值时余数。呼。
- en: Then on line 27 I do something else weird. Instead of taking three lines of
    code to set i, j and k all to `5`, I do it in one line. (Some people don’t approve
    of this trick, but I think it’s fine in cases like this.) Line 27 means “Put the
    value `5`  into the variable k. Then take a copy of whatever value is now in k
    (`5`) and store it into j. Then take a copy of whatever is now in j and store
    it into i.” So when this line of code is done, all three variables have been changed
    to equal `5`.
  id: totrans-683
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在第27行，我做了一些奇怪的事情。我不是用三行代码来将i、j和k都设置为`5`，而是用一行代码。有些人不赞成这种技巧，但我认为在这种情况下是可以的。第27行的意思是“将值`5`放入变量k。然后取当前k中的值（`5`）的副本，并将其存储到j中。然后取当前j中的值的副本，并将其存储到i中。”因此，当这行代码执行完毕时，所有三个变量都已更改为等于`5`。
- en: Lines 30 through 32 are basically the same as lines 22 through 24 except that
    we are no longer using `3`
  id: totrans-684
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第30至32行基本上与第22至24行相同，只是我们不再使用`3`
- en: as the number to add, subtract or multiply.
  id: totrans-685
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为要添加、减去或相乘的数字。
- en: Line 38 might look like a typo, and if you wrote this in your own code it probably
    would be. Notice that instead of `+=`  I wrote `=+`. This will compile, but it
    is not interpreted the way you’d expect. The compiler
  id: totrans-686
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第38行可能看起来像是一个打字错误，如果你在自己的代码中写了这个，它可能会是一个打字错误。请注意，我写的不是`+=`，而是`=+`。这将编译，但它的解释方式与你期望的不同。编译器
- en: sees `i = +1;`, that is, “Set i equal to positive 1.” And line 39 is similar
    “Set j equal to negative 2.” So watch for that.
  id: totrans-687
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看到`i = +1;`，也就是“将i设置为正1。”第39行类似“将j设置为负2。”所以要注意这一点。
- en: 'On line 45 we see one more shortcut: the “post­increment operator.” `i++`  just
    means “add 1 to whatever is in i.” It’s the same as writing `i = i + 1`  or `i
    += 1`. Adding `1`  to a variable is super common. (You’ll see.) That’s why there’s
    a special shortcut for it.'
  id: totrans-688
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第45行，我们看到了另一个快捷方式：“后增量运算符”。`i++`就意味着“在i中加1”。这与写`i = i + 1`或`i += 1`是一样的。将`1`加到变量中是非常常见的。（你会看到的。）这就是为什么有一个特殊的快捷方式。
- en: 'On line 46 we see the “post­decrement operator”: `j­­`. It subtracts 1 from
    the value in j.'
  id: totrans-689
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第46行，我们看到“后减量运算符”：`j--`。它从j的值中减去1。
- en: Today’s lesson is unusual because these shortcuts are optional. You could write
    code your whole life and never use them. But most programmers are lazy and don’t
    want to type any more than they have to, so if you ever read other people’s code
    you will see these pretty often.
  id: totrans-690
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 今天的课程很特别，因为这些快捷方式是可选的。你可以一辈子编写代码而不使用它们。但大多数程序员都很懒，不想多打字，所以如果你阅读别人的代码，你会经常看到这些。
- en: 'Exercise 12: Boolean Expressions'
  id: totrans-691
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12：布尔表达式
- en: 'So far we have only seen three types of variables:'
  id: totrans-692
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了三种类型的变量：
- en: int
  id: totrans-693
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整数
- en: integers, hold numbers (positive or negative) with no fractional parts
  id: totrans-694
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整数，不带小数部分的数字（正数或负数）
- en: double
  id: totrans-695
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 双精度
- en: “double­precision floating­point” numbers (positive or negative) that could
    have a fractional part
  id: totrans-696
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: “双精度浮点”数字（正数或负数），可能有小数部分
- en: String
  id: totrans-697
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: a string a characters, hold words, phrases, symbols, sentences, whatever
  id: totrans-698
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个字符串是字符，保存单词、短语、符号、句子，无论什么
- en: 'But in the words of Yoda: “There is another.” A “Boolean” variable (named after
    the mathematician George Boole) cannot hold numbers or words. It can only store
    one of two values: `true`  or `false`. That’s it. We can use them to perform logic.
    To the code!'
  id: totrans-699
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但用Yoda的话来说：“还有另一个。”“布尔”变量（以数学家乔治·布尔命名）不能保存数字或单词。它只能存储两个值中的一个：`true`或`false`。就是这样。我们可以用它们来执行逻辑。来看代码吧！
- en: '[PRE59]'
  id: totrans-700
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: What You Should See
  id: totrans-701
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE60]'
  id: totrans-702
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'On line 17 the Boolean variable a is set equal to something strange: the result
    of a comparison. The current value in the variable x is compared to the value
    of the variable y. If x is less than y, then the comparison is true and the Boolean
    value `true`  is stored into a. If x is not less than y, then the comparison is
    false and the boolean value `false`  is stored into a. (I think that is easier
    to understand than it is to write.)'
  id: totrans-703
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第17行，布尔变量a被设置为一些奇怪的东西：比较的结果。变量x中的当前值与变量y的值进行比较。如果x小于y，则比较为真，并且布尔值`true`存储在a中。如果x不小于y，则比较为假，并且布尔值`false`存储在a中。（我认为这比写起来更容易理解。）
- en: Line 18 is similar, except that the comparison is “less than or equal to”, and
    the Boolean result is stored into *b*.
  id: totrans-704
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第18行类似，只是比较是“小于或等于”，布尔结果存储在*b*中。
- en: 'Line 19 is “equal to”: c will be set to the value `true`  if x holds the same
    value as y. The comparison in line 20 is “not equal to”. Lines 21 and 22 are “greater
    than” and “greater than or equal to”, respectively.'
  id: totrans-705
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第19行是“等于”：如果x持有与y相同的值，c将被设置为值`true`。第20行的比较是“不等于”。第21行和第22行分别是“大于”和“大于或等于”。
- en: On lines 24 through 29, we display the values of all those Boolean variables
    on the screen.
  id: totrans-706
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第24行到第29行，我们在屏幕上显示了所有这些布尔变量的值。
- en: Line 32 through line 37 introduce the “not” operator, which is an exclamation
    point (`!`). It takes the logical opposite. So on line 32 we display the logical
    negation of “x is less than y?”, and we also print out the truth value of “x is
    greater than or equal to y?”, which are equivalent. (The opposite of “less than”
    is “greater than or equal to”.) Lines 33 through 37 show the opposites of the
    remaining relational operators.
  id: totrans-707
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第32行到第37行介绍了“非”运算符，即感叹号（`!`）。它取逻辑相反。因此，在第32行，我们显示“x是否小于y”的逻辑否定，并打印出“x是否大于或等于y”的真值，它们是等价的。（“小于”的相反是“大于或等于”。）第33行到第37行显示了其余关系运算符的相反情况。
- en: 'Exercise 13: Comparing Strings'
  id: totrans-708
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13：比较字符串
- en: 'In this exercise we will see something that causes trouble for beginners trying
    to learn Java: the regular relational operators do not work with Strings, only
    numbers.'
  id: totrans-709
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到一些让初学者学习Java时困扰的东西：常规的关系运算符不适用于字符串，只适用于数字。
- en: '[PRE61]'
  id: totrans-710
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The second line doesn’t even compile! You can’t use `<`  to see if a word comes
    before another word in Java. And in the third line, b does get set to the value
    `true`  here, but not if you read the value into a variable like so:'
  id: totrans-711
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二行甚至无法编译！你不能在Java中使用`<`来查看一个单词是否在另一个单词之前。在第三行中，b确实在这里设置为值`true`，但如果你将值读入变量，就不会这样：
- en: '[PRE62]'
  id: totrans-712
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: b will always get set to the value `false`, no matter if the human types `"horse"`  or
    not!
  id: totrans-713
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论人类是否输入`"horse"`，b都将始终被设置为值`false`！
- en: I don’t want to try to explain why this is. The creators of Java do have a good
    reason for this apparently weird behavior, but it’s not friendly for beginners
    and explaining it would probably only confuse you more at this point in your learning.
  id: totrans-714
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我不想试图解释为什么会这样。Java的创建者对此显然有充分的理由，但对初学者来说并不友好，解释可能只会让你更加困惑。
- en: Do you remember when I warned you that Java is not a language for beginners?
    So there *is* a way to compare Strings for equality, so let’s look at it.
  id: totrans-715
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还记得我警告过你Java不是初学者的语言吗？所以*有*一种比较字符串是否相等的方法，让我们来看看。
- en: '[PRE63]'
  id: totrans-716
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: What You Should See
  id: totrans-717
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE64]'
  id: totrans-718
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: So Strings have a built­in method named `.equals()`  (“dot equals”) that compares
    itself to another String, simplifying to the value `true`  if they are equal and
    to the value `false`  if they are not. And you must use the not operator (`!`)
    together with the `.equals()`  method to find out if two Strings are different.
  id: totrans-719
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，字符串有一个名为`.equals()`的内置方法（“点等于”），它将自己与另一个字符串进行比较，如果它们相等，则简化为值`true`，如果它们不相等，则简化为值`false`。你必须使用非运算符（`!`）与`.equals()`方法一起来判断两个字符串是否不同。
- en: Study Drills
  id: totrans-720
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习技巧
- en: Try changing around the comparison on line 15 so that `"weasel"`  is in front
    of the dot and the variable word is inside the parentheses. Make sure that `"weasel"`  is
    still surrounded by quotes and that word is not. Does it work?
  id: totrans-721
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在第15行改变比较，使得`"weasel"`在点的前面，变量word在括号内。确保`"weasel"`仍然被引号括起来，而word则没有。它有效吗？
- en: 'Exercise 14: Compound Boolean Expressions'
  id: totrans-722
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14：复合布尔表达式
- en: 1 import java.util.Scanner; 2
  id: totrans-723
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 导入java.util.Scanner; 2
- en: 3 public class ShallowGrandmother 4 {
  id: totrans-724
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 public class ShallowGrandmother 4 {
- en: '5'
  id: totrans-725
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-726
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-727
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-729
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-730
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-731
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-732
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-733
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: '14'
  id: totrans-734
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-735
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-736
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-737
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: '18'
  id: totrans-738
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: '19'
  id: totrans-739
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-740
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-741
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-742
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '22'
- en: '23'
  id: totrans-743
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '23'
- en: '24'
  id: totrans-744
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '24'
- en: '25'
  id: totrans-745
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '25'
- en: 26 }
  id: totrans-746
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 26 }
- en: public static void main( String[] args )
  id: totrans-747
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main( String[] args )
- en: '{'
  id: totrans-748
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-749
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键盘扫描器=新的扫描器（系统。在）;
- en: int age;
  id: totrans-750
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 年龄；
- en: double income, attractiveness; boolean allowed;
  id: totrans-751
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 双收入，吸引力；布尔允许；
- en: 'System.out.print( "Enter your age: " ); age = keyboard.nextInt();'
  id: totrans-752
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print( "输入你的年龄：" ); age = keyboard.nextInt();
- en: 'System.out.print( "Enter your yearly income: " ); income = keyboard.nextDouble();'
  id: totrans-753
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print( "输入你的年收入：" );收入=键盘。nextDouble();
- en: System.out.print( "How attractive are you, on a scale from 0.0 to 10.0? " );
    attractiveness = keyboard.nextDouble();
  id: totrans-754
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print( "你有多吸引人，从0.0到10.0的范围？" );吸引力=键盘。nextDouble();
- en: 'allowed = ( age > 25 && age < 40 && ( income > 50000 || attractiveness >= 8.5
    )); System.out.println( "You are allowed to date my grandchild: " + allowed );'
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 允许=（年龄>25 && 年龄<40 &&（收入>50000 || 吸引力>=8.5））; System.out.println( "你被允许约会我的孙子："
    + 允许);
- en: '}'
  id: totrans-756
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'Sometimes we want to use logic more complicated than just “less than” or “equal
    to”. Imagine a grandmother who will only approve you dating her grandchild if
    you are older than 25 *and* younger than 40 *and* either rich or really good looking.
    If that grandmother was a programmer and could convince applicants to answer honestly,
    her program might look a bit like this:'
  id: totrans-757
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时我们想使用比“小于”或“等于”更复杂的逻辑。想象一下，只有在25岁以上*并且*40岁以下*并且*要么富有要么长得很好看时，祖母才会同意你约会她的孙子。如果那位祖母是一名程序员，并且能说服申请者诚实回答，她的程序可能会像这样：
- en: What You Should See
  id: totrans-758
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE65]'
  id: totrans-759
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: So we can see that for complicated Boolean expressions you can use parentheses
    to group things, and you use the symbols `&&`  to mean “AND” and the symbols `||`  to
    mean “OR”.
  id: totrans-760
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以我们可以看到，对于复杂的布尔表达式，您可以使用括号来分组，使用符号`&&`表示“AND”，使用符号`||`表示“OR”。
- en: 'I know what you are thinking: using `&`  (an “ampersand” or “and sign”) to
    mean “AND” makes a little sense, but why two of them? And whose idea was it to
    use `||`  (“pipe pipe”) to mean “OR”?!?'
  id: totrans-761
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我知道你在想什么：使用`&`（“和符号”）表示“AND”有点说得通，但为什么要两个？谁想到使用`||`（“管道管道”）表示“OR”？！？
- en: Well, Ken Thompson’s idea, probably. Java syntax is modeled after C++’s syntax,
    which was basically copied from C’s syntax, and that was modified from B’s syntax,
    which was invented by Dennis Ritchie and Ken Thompson.
  id: totrans-762
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，肯·汤普森的想法，可能是。Java语法是模仿C++的语法，而C++的语法基本上是从C的语法复制过来的，而C的语法是从B的语法修改而来的，而B的语法是由丹尼斯·里奇和肯·汤普森发明的。
- en: 'The programming language B used `&`  to mean “AND” and `|`  for “OR”, but they
    were “bitwise”: they only worked on two integers and they would walk one bit at
    a time down the integers doing a bitwise AND or OR on each pair of bits, putting
    a `1`  or `0`  in the output for each comparison. (`|`  was probably used because
    it was mathematical­looking and was a key on the keyboards of the PDP­7 computer
    that B was originally developed for.)'
  id: totrans-763
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 编程语言B使用`&`表示“AND”，`|`表示“OR”，但它们是“按位的”：它们只对两个整数起作用，并且它们会逐位地遍历整数，对每一对比特进行按位AND或OR运算，在每次比较中放置`1`或`0`在输出中。（`|`可能被使用是因为它看起来像数学符号，并且是PDP-7计算机键盘上的一个关键，B最初是为其开发的。）
- en: When Ken and Dennis started developing the programming language *C* to replace
    *B*, they decided there was a need for a *logical* “AND” and “OR”, and the one­symbol­long
    things were already taken, so they used two ampersands to represent logical “AND”
    and two vertical bars or “pipes” to represent logical “OR”. Whew.
  id: totrans-764
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当肯恩和丹尼斯开始开发编程语言*C*来取代*B*时，他们决定需要一个*逻辑*的“AND”和“OR”，而单个符号已经被使用了，所以他们使用两个和符号来表示逻辑“AND”，两个竖线或“管道”来表示逻辑“OR”。哇。
- en: Fortunately for you, you don’t need to know any of that. You just need to remember
    what to type and get it right.
  id: totrans-765
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要知道任何这些。你只需要记住要输入什么并且输入正确。
- en: This next little bit is going to be a little bit weird, because I’m going to
    show you the “truth tables” for AND and OR, and you’ll have to think of “AND”
    as an *operation* that is being performed on two values instead of a conjunction.
  id: totrans-766
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来的一点有点奇怪，因为我将向您展示AND和OR的“真值表”，您将不得不将“AND”视为对两个值执行的*操作*，而不是一个连接词。
- en: 'Here is the truth table for AND:'
  id: totrans-767
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是AND的真值表：
- en: Inputs
  id: totrans-768
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入
- en: Output(s)
  id: totrans-769
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出
- en: A
  id: totrans-770
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-771
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: B
- en: A && B
  id: totrans-772
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: A && B
- en: 'true'
  id: totrans-773
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-774
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-775
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-776
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'false'
  id: totrans-777
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'false'
  id: totrans-778
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'false'
  id: totrans-779
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'true'
  id: totrans-780
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'false'
  id: totrans-781
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'false'
  id: totrans-782
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'false'
  id: totrans-783
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'false'
  id: totrans-784
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'You read the tables this way: let’s pretend that our shallow grandmother has
    decided that she will only go on a cruise if it is cheap AND the alcohol is included
    in the price. So we will pretend that statement A is “the cruise is cheap” and
    statement B is “the alcohol is included”. Each row in the table is a possible
    cruise line.'
  id: totrans-785
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以这样读表：假设我们的肤浅的祖母已经决定，只有在巡航便宜并且酒精包含在价格中时，她才会去乘船。所以我们假设陈述A是“巡航很便宜”，陈述B是“酒精包括在内”。表中的每一行都是一个可能的巡航航线。
- en: 'Row 1 is a cruise where both statements are true. Will grandmother be excited
    about cruise #1? Yes! “Cruise is cheap” is true and “alcohol is included” is true,
    so “grandmother will go” (A && B) is also true.'
  id: totrans-786
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第1行是两个语句都为真的情况。祖母会对第1条巡航感到兴奋吗？是的！“巡航很便宜”是真的，“酒精包括在内”也是真的，所以“祖母会去”（A && B）也是真的。
- en: 'Cruise #2 is cheap, but the alcohol is *not* included (statement B is false).
    So grandmother isn’t interested: (A && B) is false when A is true and B is false.'
  id: totrans-787
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 巡航#2很便宜，但酒精*不*包括在内（陈述B是假的）。所以祖母不感兴趣：（A && B）是假的，当A为真时，B为假。
- en: 'Clear? Now here is the truth table for OR:'
  id: totrans-788
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 清楚吗？现在这是OR的真值表：
- en: Inputs
  id: totrans-789
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入
- en: Output(s)
  id: totrans-790
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出
- en: A
  id: totrans-791
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-792
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: B
- en: A || B
  id: totrans-793
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: A || B
- en: 'true'
  id: totrans-794
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-795
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-796
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-797
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'false'
  id: totrans-798
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'true'
  id: totrans-799
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'false'
  id: totrans-800
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: 'true'
  id: totrans-801
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正确
- en: 'true'
  id: totrans-802
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 真
- en: 'false'
  id: totrans-803
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假
- en: 'false'
  id: totrans-804
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假
- en: 'false'
  id: totrans-805
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假
- en: Let’s say that grandmother will buy a certain used car if it is really cool­looking
    OR if it gets great gas mileage. Statement A is “car is cool looking”, B is “good
    miles per gallon” and the result, A OR B, determines if it is a car grandmother
    would want.
  id: totrans-806
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设祖母会购买某辆二手车，如果它看起来真的很酷，或者它的油耗很好。陈述A是“车看起来很酷”，B是“每加仑好里程”，结果A或B决定了祖母是否想要这辆车。
- en: 'Car #1 is awesome­looking and it also goes a long way on a tank of gas. Is
    grandmother interested? Heck, yes! We can say that the value `true`  ORed with
    the value `true`  gives a result of `true`.'
  id: totrans-807
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 汽车＃1看起来很棒，而且一箱油可以走很远。祖母感兴趣吗？当然！我们可以说值`true`与值`true`进行OR运算的结果是`true`。
- en: In fact, the only car grandmother won’t like is when both are false. An expression
    involving OR is only false if BOTH of its components are false.
  id: totrans-808
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，祖母不喜欢的唯一一辆车是两者都是假的时候。涉及OR的表达式只有在其两个组成部分都为假时才为假。
- en: Study Drills
  id: totrans-809
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Did you know that Java has bitwise operators, too? Investigate how numbers are
    represented in binary and see if you can figure out why the following code sets
    x to the value `7`  and sets y to the value `1`.
  id: totrans-810
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道Java也有位运算符吗？调查一下数字是如何用二进制表示的，看看你能否弄清楚为什么以下代码将x设置为值`7`，将y设置为值`1`。
- en: '[PRE66]'
  id: totrans-811
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Exercise 15: Making Decisions with If Statements'
  id: totrans-812
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15：使用if语句做决定
- en: Hey! I really like this exercise. You suffered through some pretty boring ones
    there, so it’s time to learn something that is useful and not super difficult.
  id: totrans-813
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嘿！我真的很喜欢这个练习。你在那里经历了一些相当无聊的练习，所以现在是时候学习一些有用而不是超级困难的东西了。
- en: '[PRE67]'
  id: totrans-814
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-815
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-816
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-817
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-818
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-819
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-820
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-821
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-822
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-823
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-824
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-825
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-826
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We are going to learn how to write code that has decisions in it, so that the
    output isn’t always the same. The code that gets executed changes depending on
    what the human enters.
  id: totrans-827
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将学习如何编写具有决策的代码，以便输出不总是相同的。执行的代码会根据人输入的内容而改变。
- en: What You Should See
  id: totrans-828
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE80]'
  id: totrans-829
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Okay, this is called an “if statement”. An if statement starts with the keyword
    `if`, followed by a “condition” in parentheses. The condition must be a Boolean
    expression that evaluates to either `true`  or `false`. Underneath that starts
    a block of code surrounded by curly braces, and the stuff inside the curly braces
    is indented one more level. That block of code is called the “body” of the if
    statement.
  id: totrans-830
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，这就是所谓的“if语句”。if语句以关键字`if`开头，后面跟着括号中的“条件”。条件必须是一个布尔表达式，其值为`true`或`false`。在下面开始了由大括号包围的一块代码，大括号里面的东西缩进了一层。这段代码被称为if语句的“主体”。
- en: When the condition of the if statement is true, all the code in the body of
    the if statement is executed.
  id: totrans-831
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当if语句的条件为真时，if语句的主体中的所有代码都会被执行。
- en: When the condition of the if statement is false, all the code in the body is
    skipped. You can have as many lines of code as you want inside the body of an
    if statement; they will all be executed or skipped as a group.
  id: totrans-832
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当if语句的条件为假时，主体中的所有代码都会被跳过。你可以在if语句的主体中有任意多行代码；它们将作为一组被执行或跳过。
- en: Notice that when I ran the code, I put in `17`  for my age. Because 17 is not
    less than 13, the condition on line 14 is false, and so the code in the body of
    the first if statement (lines 15 through 17) was skipped.
  id: totrans-833
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当我运行代码时，我输入了`17`作为我的年龄。因为17不小于13，所以第14行的条件是假的，所以第一个if语句的主体中的代码（第15到17行）被跳过了。
- en: The second if statement was also false because 17 is not less than 16, so the
    code in its body (lines 19 through 21) was skipped, too.
  id: totrans-834
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个if语句也是假的，因为17不小于16，所以它的主体中的代码（第19到21行）也被跳过了。
- en: 'The condition of the third if statement was true: 17 *is* less than 18, so
    the body of the third if statement was not skipped; it was executed and the phrase
    “You are too young to get a tattoo” *was* printed on the screen. The remaining
    if statements in the exercise are all true.'
  id: totrans-835
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三个if语句的条件是真的：17确实小于18，所以第三个if语句的主体不会被跳过；它被执行了，屏幕上打印出了“你太年轻了，不能纹身”的短语。练习中剩下的if语句都是真的。
- en: The final if statement contains two lines of code in its body, just to show
    you what it would look like.
  id: totrans-836
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后的if语句包含两行代码在它的主体中，只是为了向你展示它会是什么样子。
- en: Study Drills
  id: totrans-837
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: If you type in an age greater than 35 what gets printed? Why?
  id: totrans-838
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你输入一个大于35的年龄，会打印出什么？为什么？
- en: Add one more if statement comparing their age to 65\. If their age is greater
    than or equal to 65, say “You are old enough to retire!”.
  id: totrans-839
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再添加一个if语句，将他们的年龄与65进行比较。如果他们的年龄大于或等于65岁，就说“你已经足够老了，可以退休了！”。
- en: For each if statement, add another if statement that says the opposite. For
    example, if their age is greater than or equal to 13, say “You are old enough
    to create a Facebook account.” When you are done, your program should show six
    messages every time no matter what age you enter.
  id: totrans-840
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个if语句，添加另一个说相反的if语句。例如，如果他们的年龄大于或等于13岁，就说“你已经足够大了，可以创建一个Facebook账户。”完成后，无论输入什么年龄，你的程序每次都应该显示六条消息。
- en: 'Exercise 16: More If Statements'
  id: totrans-841
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16：更多的if语句
- en: '[PRE81]'
  id: totrans-842
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There is almost nothing new in this exercise. It is just more practice with
    if statements, because they’re pretty important. It will also help you to remember
    the relational operators.
  id: totrans-843
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习几乎没有什么新东西。这只是对if语句的更多练习，因为它们非常重要。这也会帮助你记住关系运算符。
- en: '[PRE82]'
  id: totrans-844
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: What You Should See
  id: totrans-845
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE83]'
  id: totrans-846
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'On line 37 you will see that I did something questionable: the body of the
    last if statement does not have any curly braces around it. Is this okay?'
  id: totrans-847
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第37行，你会看到我做了一些有问题的事情：最后一个if语句的主体没有任何大括号围绕它。这样可以吗？
- en: Actually, it is. When the body of an if statement does not have curly braces,
    then only the first line of code after the condition is included in the body.
    So, since all the if statements in this whole exercise have only one line of code
    in their bodies, all the if statement curly braces in this exercise are optional.
    You could remove and the program would work the same. It is never wrong to include
    them, though, and some programmers always put curly braces no matter what.
  id: totrans-848
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上是。当 `if` 语句的主体没有花括号时，那么在条件之后的代码的第一行将被包括在主体中。因此，由于这整个练习中的所有 `if` 语句的主体只有一行代码，所以这个练习中的所有
    `if` 语句的花括号都是可选的。你可以删除并且程序会正常工作。不过，包括它们永远不会错，有些程序员总是无论如何都会加上花括号。
- en: Study Drills
  id: totrans-849
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习技巧
- en: '1\. Add another line of code after line 37 that says `System.out.println( "Hey."
    );`. Indent it so that it lines up with the `println()`  statement above it, like
    so:'
  id: totrans-850
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 在第37行之后添加另一行代码，写上 `System.out.println( "Hey." );`。缩进它，使其与上面的 `println()`
    语句对齐，就像这样：
- en: '[PRE84]'
  id: totrans-851
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Run the program, and see what happens. Is the “Hey” part of the if statement
    body? That is, when the if statement is skipped, is the “Hey” skipped, too, or
    does it run no matter what? What do you think?
  id: totrans-852
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行程序，看看会发生什么。 “嘿” 部分是否属于if语句主体？也就是说，当if语句被跳过时，“嘿”也被跳过了，还是无论如何都会运行？你觉得呢？
- en: 1\. Add curly braces around the body of the final if statement so that the “Hey”
    line is part of the body. Then remove all the *other* if statement body curly
    braces so that only the last if statement in the program has them. Confirm that
    everything works as expected.
  id: totrans-853
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 在最后一个if语句的主体周围添加花括号，以便“嘿”行是主体的一部分。然后删除所有*其他* if 语句主体的花括号，以便程序中只有最后一个if语句有它们。确认一切都按预期工作。
- en: 'Exercise 17: Otherwise (If Statements with Else)'
  id: totrans-854
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习17：否则（带else的if语句）
- en: So, `if`  statements are pretty great. Almost every programming language has
    them, and you use them ALL the time. In fact, `if`  statements alone are functional
    enough that you could do a lot just using `if`  statements.
  id: totrans-855
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以，`if` 语句非常棒。几乎每种编程语言都有它们，你一直都在使用它们。事实上，`if` 语句本身就足够功能强大，你可以只使用 `if` 语句做很多事情。
- en: 'But sometimes, having something else could make things a little more convenient.
    Like this example: quick! What is the logical opposite of the following expression?'
  id: totrans-856
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但有时，有其他东西可能会使事情变得更加方便。比如这个例子：快！以下表达式的逻辑相反是什么？
- en: '[PRE85]'
  id: totrans-857
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Eh? Got it yet? Well, if you said
  id: totrans-858
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯？懂了吗？如果是的话
- en: if ( ! ( onGuestList || age >= 21 || ( gender.equals("F") && attractiveness
    >= 8 ) ) )
  id: totrans-859
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if ( ! ( onGuestList || age >= 21 || ( gender.equals("F") && attractiveness
    >= 8 ) ) )
- en: …then you’re right and you’re my kind of person. Clever and knows when to let
    the machine do the work for you. If you said
  id: totrans-860
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …然后你是对的，你是我的菜。聪明并且知道什么时候让机器为你工作。如果你说
- en: if ( ! onGuestList && age < 21 && ( ! gender.equals("F") || attractiveness <
    8 ) )
  id: totrans-861
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if ( ! onGuestList && age < 21 && ( ! gender.equals("F") || attractiveness <
    8 ) )
- en: '…then you’re right and… nice job. That’s actually pretty tough to do correctly.
    But what about the logical opposite of this:'
  id: totrans-862
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …然后你是对的，干得好。这实际上是相当难以正确做到的。但是这个的逻辑相反又是什么呢：
- en: '[PRE86]'
  id: totrans-863
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Do we really want to write
  id: totrans-864
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们真的想要写
- en: '[PRE87]'
  id: totrans-865
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-866
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-867
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-868
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-869
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-870
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-871
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-872
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-873
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-874
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-875
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-876
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: …because now we’re having to wait 90 seconds to do two `if`  statements instead
    of 45 seconds. So fortunately, programming languages give us something `else`.
    (Yeah, sorry. Couldn’t resist.)
  id: totrans-877
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …因为现在我们不得不等待90秒来执行两个 `if` 语句，而不是45秒。所以幸运的是，编程语言给了我们一些 `else`。（是的，抱歉。忍不住。）
- en: What You Should See
  id: totrans-878
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE99]'
  id: totrans-879
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So what the keyword `else`  means is this: look at the preceding `if`  statement.
    Was the condition of that'
  id: totrans-880
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以 `else` 关键字的意思是：看看前面的 `if` 语句。那个条件是
- en: '`if`  statement true? If so, skip. If that previous `if`  statement did not
    run, however, then the body of the'
  id: totrans-881
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if` 语句为真吗？如果是，跳过。如果之前的 `if` 语句没有运行，那么'
- en: else statement will be executed. “If blah blah blah is true, then run this block
    of code. Otherwise (else), run this different block of code instead.”
  id: totrans-882
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则语句将被执行。“如果blah blah blah为真，则运行这个代码块。否则（else），运行这个不同的代码块。”
- en: Else is super convenient because then we don’t have to figure out the logical
    opposite of some complex Boolean expression. We can just say `else`  and let the
    computer deal with it.
  id: totrans-883
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则非常方便，因为我们不必去计算一些复杂布尔表达式的逻辑相反。我们只需要说 `else`，让计算机处理它。
- en: An `else`  is only legal immediately after an `if`  statement ends. (Technically
    it is only allowed after the closing of the block of code that is the body of
    an `if`  statement.)
  id: totrans-884
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`else` 只有在 `if` 语句结束后立即合法。（严格来说，它只允许在 `if` 语句的主体代码块结束后。）'
- en: Study Drills
  id: totrans-885
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习技巧
- en: 1\. Between line 17 and 18, add a `println()`  statement to print something
    on the screen (it doesn’t matter what, but I put `"C­C­C­COMBO BREAKER"`  because
    I’m weird.) Try to compile the program. Does it compile? Why not?
  id: totrans-886
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1\. 在第17行和第18行之间，添加一个 `println()` 语句来在屏幕上打印一些东西（不重要，但我放了 `"C­C­C­COMBO BREAKER"`
    因为我很奇怪）。尝试编译程序。为什么不能编译？
- en: 'Exercise 18: If Statements with Strings'
  id: totrans-887
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18：带字符串的if语句
- en: '[PRE100]'
  id: totrans-888
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-889
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-890
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-891
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-892
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: A few exercises back you learned how comparing Strings is not as easy as comparing
    numbers. So let’s review with an example you can actually test out.
  id: totrans-893
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几个练习之前，你学会了比较字符串不像比较数字那么容易。所以让我们用一个你可以实际测试的例子来复习一下。
- en: What You Should See
  id: totrans-894
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE105]'
  id: totrans-895
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Notice that as usual I’m sneaking something in. On line 9 instead of just declaring
    *secret* I also gave it a value. That is, I “defined” it (declared and initialized
    all at once).
  id: totrans-896
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，和往常一样，我在偷偷加入一些东西。在第9行，我不仅仅是声明 *secret*，我还给它赋了一个值。也就是说，我“定义”了它（一次性声明和初始化）。
- en: Anyway, the `if`  statement on line 14 will never be true. Never ever. No matter
    what you type in, it will never be the case that guess `==`  secret.
  id: totrans-897
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，第14行的 `if` 语句永远不会为真。无论你输入什么，猜测 `==` 秘密永远不会成立。
- en: (I can’t really explain why without going into way too much detail, but it has
    to do with the fact that `==`  only compares the shallow values of the variables,
    and the shallow values of two Strings are only equal when they refer to the same
    memory location.)
  id: totrans-898
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （我无法解释为什么，因为那样会涉及太多细节，但这与`==`只比较变量的浅层值有关，两个字符串的浅层值只有在它们引用相同的内存位置时才相等。）
- en: What does work is using the `.equals()`  method (which compares the deep values
    of the variables instead of their shallow values). This will be true if they type
    the correct secret word.
  id: totrans-899
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有效的方法是使用`.equals()`方法（它比较变量的深层值而不是它们的浅层值）。如果他们输入了正确的秘密词，这将为真。
- en: 'Exercise 19: Mutual Exclusion with Chains of If and Else'
  id: totrans-900
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19：使用if和else链进行互斥
- en: In the previous exercise, we saw how using `else`  can make it easier to include
    a chunk of alternative code that you want to run when an `if`  statement did not
    happen.
  id: totrans-901
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到使用`else`可以更容易地包含一块备用代码，当`if`语句没有发生时，你想要运行的。
- en: '[PRE106]'
  id: totrans-902
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-903
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-904
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-905
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-906
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: But what if the alternative code is… another `if`  statement?
  id: totrans-907
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，如果替代代码是……另一个`if`语句呢？
- en: What You Should See
  id: totrans-908
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE111]'
  id: totrans-909
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '(*Note*: Although BMI is a very good estimate of human body fat, the formula
    doesn’t work well for athletes with a lot of muscle, or people who are extremely
    short or very tall. If you are concerned about'
  id: totrans-910
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （*注意*：尽管BMI是人体脂肪的一个很好的估计值，但这个公式对于肌肉量很大的运动员，或者身材极矮或极高的人来说效果不佳。如果你担心
- en: your BMI, check with your doctor.)
  id: totrans-911
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的BMI，请咨询医生。）
- en: 'Notice that even though several of the `if`  statements might have all been
    true, only the first true `if`  statement printed its message on the screen. No
    other messages were printed: only one. That’s the power of using `else`  with
    `if`.'
  id: totrans-912
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，即使几个`if`语句可能都为真，只有第一个为真的`if`语句才会在屏幕上打印它的消息。没有其他消息被打印：只有一个。这就是使用`else`与`if`的威力。
- en: On line 15 there is an `if`  statement that checks if your BMI is less than
    `15.0`, and if so, displays the proper category for that body mass index.
  id: totrans-913
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第15行有一个`if`语句，检查你的BMI是否小于`15.0`，如果是，则显示该体重指数的适当类别。
- en: Line 19 begins with an `else`. That else pays attention to the preceding `if`  statement
    – the one on line 15 – to determine if it should run its body of code or skip
    it automatically. Assuming you typed in a BMI of `22.5`, then the preceding `if`  statement
    was not true and did not run. Because that `if`  statement failed, the else will
    automatically execute its body of code.
  id: totrans-914
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第19行以`else`开头。这个else关注前面的`if`语句——第15行的那个——以确定它是否应该运行它的代码块或自动跳过它。假设你输入了BMI为`22.5`，那么前面的`if`语句不成立，也没有运行。因为那个`if`语句失败了，else将自动执行它的代码块。
- en: However, that body of code starts right after the word `else`  with a new `if`  statement!
    This means that the statement `if ( bmi <= 16.0 )`  will only be considered when
    the previous `if`  statement was false.
  id: totrans-915
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这段代码块紧跟在`else`后面，后面是一个新的`if`语句！这意味着当前面的`if`语句为假时，语句`if ( bmi <= 16.0 )`才会被考虑。
- en: Whenever my students are confused about this, I have an analogy I give them.
    (It’s a little crude, but it seems to help.)
  id: totrans-916
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我的学生对此感到困惑时，我都会给他们一个类比。（有点粗糙，但似乎有所帮助。）
- en: 'Imagine that you are single (romantically, I mean) and that you and some of
    your friends are out in a bar or the mall or whatever. Across the way, you see
    a really attractive single person and under your breath you tell the others: “Okay,
    dibs. I get the first shot.”'
  id: totrans-917
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象一下你是单身（浪漫方面的意思），你和一些朋友在酒吧或商场或其他地方。在对面，你看到一个真的很有吸引力的单身，你悄声告诉其他人：“好的，我先来。”
- en: Your group travels over to this person but no one else starts flirting until
    they see how you fare. If you seem to be making progress, your friends will back
    off and let you chat away. If however, you get rejected then one of your other
    companions feels cleared to try and make a play.
  id: totrans-918
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的团队走向这个人，但除非他们看到你的表现如何，否则没有人会开始调情。如果你似乎正在取得进展，你的朋友们会退后，让你畅所欲言。然而，如果你被拒绝，那么你的其他伙伴之一就会感到有机会尝试并发起进攻。
- en: This is basically exactly what happens with `else if`. An `else if`  statement
    (an `if`  statement with an `else`  in front of the `if`) contains a condition
    that might be true or might be false. But the `else`  means that the `if`  statement
    will only check to see if it is true or false assuming the preceding `if`  statement
    (and only the immediately preceding one) was false.
  id: totrans-919
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这基本上就是`else if`的作用。一个`else if`语句（一个在`if`语句前面有`else`的`if`语句）包含一个可能为真或可能为假的条件。但是`else`意味着`if`语句只会检查它是否为真或假，假设前面的`if`语句（只有紧接着的那个）为假。
- en: 'The `else`  on line 23 makes that `if`  statement defer to the `if`  statement
    that starts on line 19: if it’s true, the line­23 `if`  statement will skip even
    if it would have been true on its own. The `else`  on line 27 makes its `if`  statement
    defer to the previous `if`  statement, and so on. And the `else`  at the very
    end on line 43 is like the smallest dog in a pack: it only gets a shot if all
    the previous `if`  statements in the chain were false.'
  id: totrans-920
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第23行的`else`使得第19行开始的`if`语句推迟到第19行的`if`语句：如果为真，第23行的`if`语句将跳过，即使它本来是真的。第27行的`else`使得它的`if`语句推迟到前面的`if`语句，依此类推。最后一行43的`else`就像一群中最小的狗：只有在链中所有前面的`if`语句都为假时才会执行。
- en: We’ll talk a little bit more about this in the next exercise, so that’s enough
    for now.
  id: totrans-921
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在下一个练习中再多谈一些这个问题，现在就到此为止。
- en: Study Drills
  id: totrans-922
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Remove the `else`  from in front of the `if`  statement on line 27\. Run the
    program, and enter
  id: totrans-923
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第27行`if`语句前面删除`else`。运行程序，然后输入
- en: '`15.5`  for the BMI. Do you see how that makes the `if`  statement on line
    27 “break rank” and no longer care about the `if`  statements before it?'
  id: totrans-924
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`15.5`作为BMI。你看到了吗，这使得第27行的`if`语句“打破了规矩”，不再关心它之前的`if`语句？'
- en: Instead of making the human enter their BMI directly, allow them to type in
    their height and weight and compute the BMI for them.
  id: totrans-925
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要让人直接输入他们的BMI，让他们输入身高和体重，然后为他们计算BMI。
- en: 'Exercise 20: More Chains of Ifs and Else'
  id: totrans-926
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习20：更多的`else`和`if`链。
- en: Okay, let’s look a little more at making chains of conditions using `else`  and
    `if`.
  id: totrans-927
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，让我们更仔细地看一下使用`else`和`if`构建条件链。
- en: '[PRE112]'
  id: totrans-928
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-929
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-930
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-931
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-932
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-933
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-934
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-935
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-936
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-937
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A confession: although I did attend UT Austin I don’t think this is their real
    admissions criteria. Don’t rely on the output of this program when deciding whether
    or not to apply to a back­up school.'
  id: totrans-938
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 坦白说：尽管我确实参加了德克萨斯大学奥斯汀分校，但我认为这不是他们真正的录取标准。在决定是否申请备用学校时，不要依赖这个程序的输出。
- en: What You Should See
  id: totrans-939
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE122]'
  id: totrans-940
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Now, before I go into the new thing for this exercise, I should explain a shortcut
    I took in this program. Did you notice there was a second `import`  statement
    at the top? If not, then your code didn’t compile or you thought I made a mistake
    by putting `out.println`  instead of `System.out.println`  everywhere.
  id: totrans-941
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在我进入这个练习的新内容之前，我应该解释一下我在这个程序中采取的一个快捷方式。你有没有注意到顶部有第二个`import`语句？如果没有，那么你的代码没有编译，或者你认为我在所有地方都写错了，应该是`out.println`而不是`System.out.println`。
- en: Well, I don’t want to talk much about object­oriented code in this book, since
    that’s severely not beginner friendly, but think of it like this. There is a built­in
    object in Java called `System`. Inside that object there is another object named
    `out`. That object named `out`  contains a method called `print()`  and one called
    `println()`.
  id: totrans-942
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，我不想在这本书中过多地谈论面向对象的代码，因为那对初学者来说太复杂了，但是可以这样想。在Java中有一个内置对象叫做`System`。在该对象内部还有另一个名为`out`的对象。名为`out`的对象包含一个名为`print()`和一个名为`println()`的方法。
- en: So when you write `System.out.println`  you are asking the computer to run the
    method called `println`  inside the object named `out`  which is inside the object
    named `System`  (which is itself part of the built­in import library `java.lang.System`).
  id: totrans-943
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以当你写`System.out.println`时，你是在要求计算机运行名为`out`的对象内部的名为`println`的方法（它本身是内置导入库`java.lang.System`的一部分）。
- en: 'Because of this, I can create a variable named `out`, and it won’t be a problem:'
  id: totrans-944
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我可以创建一个名为`out`的变量，这不会有问题：
- en: '[PRE123]'
  id: totrans-945
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Even though there’s an object named `out`  in existence somewhere, it’s inside
    the `System`  object so the names don’t conflict.
  id: totrans-946
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管有一个名为`out`的对象存在，但它在`System`对象内部，所以名称不会冲突。
- en: 'If I am lazy and don’t have any desire to have my own variable named `out`,
    then I can ask the computer to “import all static items which are inside the class
    `java.lang.System`  into the current namespace”:'
  id: totrans-947
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我懒惰并且没有任何愿望拥有自己命名为`out`的变量，那么我可以要求计算机“将类`java.lang.System`中的所有静态项目导入当前命名空间”：
- en: '[PRE124]'
  id: totrans-948
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: So now I can type just `out.println`  instead of `System.out.println`. Woo!
  id: totrans-949
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以现在我可以只输入`out.println`而不是`System.out.println`。哇！
- en: In this exercise I also omitted all the curly braces that delimit the blocks
    of code that are in the bodies of each `if`  statement. Because I only want there
    to be a single statement inside the body of each `if`  statement, this is okay.
    If I wanted there to be more than one line of code then I would have to put the
    curly braces back.
  id: totrans-950
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，我还省略了界定每个`if`语句主体中代码块的所有花括号。因为我只想在每个`if`语句的主体中有一个语句，所以这是可以的。如果我想要有多于一行的代码，那么我就必须把花括号放回去。
- en: 'Anyway, in the previous exercise I wrote about how putting `else`  in front
    of an `if`  statement makes it defer to the previous `if`  statement. When the
    previous one is true and executes the code in its body, the current one skips
    automatically (and all the rest of the `else if`  statements in the chain will
    skip, too). This has the effect of making it so that only the first true value
    triggers the `if`  statement and all the rest don’t run. We sometimes say that
    the `if`  statements are “mutually exclusive”: exactly one of them will execute.
    Never fewer than one, never more than one.'
  id: totrans-951
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，在之前的练习中，我写了如何将`else`放在`if`语句前面使其延迟到前一个`if`语句。当前一个为真并执行其主体中的代码时，当前一个会自动跳过（链中的所有其他`else
    if`语句也会跳过）。这会使得只有第一个为真的值会触发`if`语句，其他所有的都不会运行。我们有时会说`if`语句是“互斥的”：只有一个会执行。不会少于一个，也不会多于一个。
- en: Today’s exercise is another example of that. But this time I want to point out
    that the mutual exclusion only works properly because I put the `if`  statements
    in the correct order.
  id: totrans-952
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 今天的练习是另一个例子。但是这次我想指出，互斥只能正常工作是因为我按正确的顺序放置了`if`语句。
- en: Since the first one that is true will go and the others will not, you need to
    make sure that the very first `if`  statement in the chain is the one which is
    hardest to achieve. Then the next hardest, and so on, with the easiest at the
    end. In the study drills I will have you change the order of the `if`  statements,
    and you will see how this can mess things up.
  id: totrans-953
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为第一个为真的将会执行，而其他的不会，所以你需要确保链中的第一个`if`语句是最难实现的。然后是下一个最难的，以此类推，最容易的放在最后。在学习演习中，我会让你改变`if`语句的顺序，你会看到这样会搞乱事情。
- en: Also, technically, `else`  statements should have curly braces, just like `if`  statements
    do, and by putting `else if`  with nothing in between we are taking advantage
    of the fact that the braces are optional. This makes the code a lot more compact.
    Here is what the previous code would look like if it were arranged the way the
    computer is interpreting it. Maybe it will help you to understand the “defer”
    behavior of the `else`  in front of an `if`; maybe it will just confuse you. Hopefully
    it will help.
  id: totrans-954
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，从技术上讲，`else`语句应该有花括号，就像`if`语句一样，通过将`else if`之间什么都不放置来利用花括号是可选的事实。这使得代码更加紧凑。如果按计算机解释的方式排列，先前的代码将是这样的。也许这会帮助你理解`else`在`if`前面的“延迟”行为；也许这只会让你困惑。希望它会有所帮助。
- en: '[PRE125]'
  id: totrans-955
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-956
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-957
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-958
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-959
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-960
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-961
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-962
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-963
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Yeah. So you can see why we usually just put `else if`.
  id: totrans-964
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 是的。所以你可以看到为什么我们通常只是使用`else if`。
- en: Study Drills
  id: totrans-965
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: In the original code file (`CollegeAdmission.java`), remove all the `else`s
    except for the
  id: totrans-966
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原始的代码文件（`CollegeAdmission.java`）中，除了最后一个之外，删除所有的`else`。
- en: last one. Run it and notice how it prints all the messages. Then put the `else`s
    back.
  id: totrans-967
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后一个。运行它并注意它如何打印所有的消息。然后把`else`放回去。
- en: Move lines 25 and 26 so they appear between lines 18 and 19\. Compile it and
    run it and notice how the program almost always just says `"UNLIKELY"`  because
    most SAT scores are more than `390`  and the `if`  statement is so high in the
    list that it steals the show most of the time.
  id: totrans-968
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将第25行和第26行移动到第18行和第19行之间。编译并运行它，注意程序几乎总是只说“UNLIKELY”，因为大多数SAT分数都超过390，而且`if`语句在列表中的位置很高，大部分时间都会占据主导地位。
- en: If you want, type in the code for `CollegeAdmissionExpanded.java`  and confirm
    that it works the same as the non­expanded version.
  id: totrans-969
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果愿意，可以输入`CollegeAdmissionExpanded.java`的代码，并确认它与非扩展版本的功能相同。
- en: 'Exercise 21: Nested If Statements'
  id: totrans-970
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习21：嵌套if语句
- en: You saw a glimpse of this in the previous exercise, but you can put just about
    anything you like inside the body of an `if`  statement including other `if`  statements.
    This is called “nesting”, and an `if`  statement which is inside another is called
    a “nested if”.
  id: totrans-971
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你在上一个练习中已经看到了这一点，但你可以在`if`语句的主体中放入任何你喜欢的东西，包括其他`if`语句。这被称为“嵌套”，在另一个`if`语句内部的`if`语句称为“嵌套if”。
- en: '[PRE134]'
  id: totrans-972
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-973
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-974
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-975
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-976
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Here’s an example of using that to do something useful.
  id: totrans-977
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是使用它做一些有用的事情的一个例子。
- en: What You Should See
  id: totrans-978
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE139]'
  id: totrans-979
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-980
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: You have probably figured out that I like to mix things up a little bit to keep
    you on your toes. Did you notice what I did differently this time?
  id: totrans-981
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能已经发现我喜欢稍微混合一下，让你保持警惕。你注意到我这次做了什么不同吗？
- en: Normally I declare all my variables at the top of the program and give them
    values (or “initialize” them) later. But you don’t actually have to declare a
    variable until you’re ready to use it. So this time, I declared all my variables
    (except *title*) on the same line I put a value into them for the first time.
  id: totrans-982
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常我会在程序的顶部声明所有变量，并在稍后给它们赋值（或“初始化”）。但实际上，你不必在准备使用变量之前声明它。所以这一次，我声明了所有变量（除了*title*）在我第一次为它们赋值的同一行。
- en: Why didn’t I declare *title* on line 22, then? Because then it wouldn’t be in
    “scope” later. *Scope* refers to the places in your program where a variable is
    visible. The general rule is that a variable is in scope once it is declared and
    from that point forward in the code until the block ends that it was declared
    in. Then the variable goes out of scope and can’t be used any more.
  id: totrans-983
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么为什么我不在第22行声明*title*呢？因为那样它以后就不在“范围”内了。*范围*指的是程序中变量可见的位置。一般规则是，一旦声明变量，从那时起在代码中的后续部分直到声明的块结束，变量就在范围内。然后变量就超出范围，不能再使用了。
- en: 'Let us look at an example: on line 29 I defined (declared and initialized)
    a String variable called married. It is declared inside the body of the female­gender
    `if`  statement. This variable exists from line 29 down through line 38 at the
    close curly brace of that `if`  statement’s body block. The variable married is
    not in scope anywhere else in the program; referring to it on lines 1 through
    28 or on lines 39 through 48 would give a compiler error.'
  id: totrans-984
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看一个例子：在第29行，我定义（声明和初始化）了一个名为married的字符串变量。它是在女性性别`if`语句的主体内声明的。这个变量存在于第29行到第38行，在该`if`语句的主体块的右花括号处。married变量在程序的其他任何地方都不在范围内；在第1到第28行或第39到第48行引用它会导致编译错误。
- en: This is why I had to declare *title* towards the beginning of the program. If
    I had declared it on line 22, then the variable would have gone out of scope one
    line later, when the close curly brace of the younger­than­20 block occurred.
    Because I need *title* to be visible all the way down through line 45, I need
    to make sure I declare it inside the block of code that ends on line 47.
  id: totrans-985
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是为什么我必须在程序的开始处声明*title*。如果我在第22行声明它，那么当年龄小于20的代码块的右花括号出现时，变量将会超出范围。因为我需要*title*一直可见，直到第45行，所以我需要确保我在代码块内声明它，该代码块在第47行结束。
- en: I could have waited until line 19 to declare it, though.
  id: totrans-986
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不过，我本来可以等到第19行再声明它。
- en: Anyway, there’s not much else interesting to say about this exercise except
    that it demonstrates nesting
  id: totrans-987
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，关于这个练习没有太多有趣的事情要说，除了它演示了嵌套。
- en: '`if`  statements and `else`s inside of others. I do have a little surprise
    in the study drills, though.'
  id: totrans-988
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if`语句和其他`else`语句。不过，我在学习演习中有一个小惊喜。'
- en: Study Drills
  id: totrans-989
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: '1\. Change the `else`  on line 39 to a suitable `if`  statement instead, like:'
  id: totrans-990
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 将第39行的`else`更改为合适的`if`语句，例如：
- en: '[PRE141]'
  id: totrans-991
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Notice that the program doesn’t compile anymore. Can you figure out why?
  id: totrans-992
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，程序不再编译。你能想出原因吗？
- en: 'It is because the variable *title* is declared on line 9 but is not given a
    value right away. Then on line 45, the value of *title* is printed on the screen.
    The variable *must* have a value at this point, or we will be trying to display
    the value of a variable that is undefined: it *has* no value. The compiler wants
    to prevent this.'
  id: totrans-993
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是因为变量*title*在第9行声明，但没有立即赋值。然后在第45行，*title*的值被打印在屏幕上。此时变量*必须*有一个值，否则我们将尝试显示一个未定义的变量的值：它*没有*值。编译器希望防止这种情况发生。
- en: When line 39 was an `else`, the compiler could guarantee that no matter what
    path through the nested `if`  statements was taken, title would always get a value.
    Once we changed it to a regular `if`  statement, there is now a way the human
    could type something to get it to sneak through all the nested `if`  statements
    without giving title a value. Can you think of one?
  id: totrans-994
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当第39行是`else`时，编译器可以保证无论通过嵌套的`if`语句的哪条路径，*title*总是会得到一个值。一旦我们将其更改为常规的`if`语句，现在有一种方法，人类可以输入一些内容，使其通过所有嵌套的`if`语句，而不给*title*一个值。你能想到一个吗？
- en: (They could type an age `20`  or greater and a letter different than `"M"`  or
    `"F"`  when prompted for gender.
  id: totrans-995
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （当提示输入性别时，他们可以输入年龄20或更大，以及不同于“M”或“F”的字母。
- en: Then neither gender `if`  statement would be true.)
  id: totrans-996
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，没有一个性别的`if`语句会为真。）
- en: We can fix this by changing the `if`  statement back to `else`  (probably a
    good idea) or by initializing
  id: totrans-997
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过将第39行的`else`语句更改为合适的`if`语句来解决这个问题（可能是个好主意），或者通过初始化
- en: 'title right when we declare it (probably a good idea anyway):'
  id: totrans-998
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们声明*title*的时候（可能是个好主意）：
- en: '[PRE142]'
  id: totrans-999
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: …or something like that. Now *title* has a value no matter what, and the compiler
    is happy.
  id: totrans-1000
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ……或者类似的东西。现在*title*有一个值，无论如何，编译器都很高兴。
- en: 'Exercise 22: Making Decisions with a Big Switch'
  id: totrans-1001
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习22：使用大开关做决定
- en: '`if`  statements aren’t the only way to compare variables with value in Java.
    There is also something called a `switch`. I don’t use them very often, but you
    should be familiar with them anyway in case you read someone else’s code that
    uses one.'
  id: totrans-1002
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if`语句并不是在Java中比较变量值的唯一方法。还有一种叫做`switch`的东西。我并不经常使用它们，但无论如何你都应该熟悉它们，以防你读到别人使用它的代码。'
- en: '[PRE143]'
  id: totrans-1003
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-1004
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-1005
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-1006
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-1007
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-1008
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-1009
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-1010
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-1011
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-1012
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: What You Should See
  id: totrans-1013
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE153]'
  id: totrans-1014
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: A `switch`  statement starts with the keyword `switch`  and then some parentheses.
    Inside the parentheses is a single variable (or an expression that simplifies
    to a single value). Then there’s an open curly brace.
  id: totrans-1015
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`switch`语句以关键字`switch`开始，然后是一些括号。括号内是一个单一的变量（或者简化为单一值的表达式）。然后是一个开放的大括号。'
- en: Inside the body of the `switch`  statement are several `case`  statements that
    begin with the keyword `case`  and then a value that the variable up in the parentheses
    might equal. Then there’s a colon (`:`). You don’t see colons very often in Java.
  id: totrans-1016
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`switch`语句的主体内部有几个以关键字`case`开头的`case`语句，然后是括号中的变量可能相等的值。然后是一个冒号（`:`）。在Java中很少看到冒号。
- en: After the `case`, the value and then colon is some code. It can be as many lines
    of code as you like except that you’re not allowed to declare any variables inside
    the `switch`  statement. Then after all the code is the keyword `break`. The `break`  marks
    the end of the case.
  id: totrans-1017
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`case`之后，是值和冒号，然后是一些代码。它可以是任意行的代码，除了你不允许在`switch`语句内部声明任何变量。然后在所有代码之后是关键字`break`。`break`标志着`case`的结束。
- en: When a `switch`  statement runs, the computer figures out the current value
    of the variable inside the parentheses. Then it looks through the list of `case`s,
    one at a time, looking for a match. When it finds a match it moves from the left
    side where the `case`s are to the right side and starts running code until it
    is stopped by a `break`.
  id: totrans-1018
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`switch`语句运行时，计算机会找出括号内变量的当前值。然后它逐个查看`case`列表，寻找匹配项。当它找到匹配项时，它会从`case`所在的左侧移动到右侧，并开始运行代码，直到被`break`停止。
- en: If none of the `case`s match and there is a `default`  case (it’s optional),
    then the code in the `default`
  id: totrans-1019
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有`case`匹配，且有一个`default`情况（可选），那么`default`中的代码将被运行。
- en: case will be run instead.
  id: totrans-1020
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 情况将被运行。
- en: The second example starts on line 50 and demonstrates that once the `switch`  statement
    finds a case that matches, it really does run code on the right side until it
    hits a `break`  statement. It will even fall through from one `case`  to another.
  id: totrans-1021
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二个例子从第50行开始，演示了一旦`switch`语句找到与之匹配的情况，它确实会运行右侧的代码，直到遇到`break`语句。它甚至会从一个`case`穿过到另一个。
- en: We can take advantage of this fall­through behavior to do clever things sometimes,
    like the code to figure out the number of days in a month. Since September, April,
    June and November all have 30 days, we can just put all their cases in a row and
    let it fall through for any of those to run the same thing.
  id: totrans-1022
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以利用这种穿透行为，有时做一些聪明的事情，比如计算一个月中的天数的代码。由于9月、4月、6月和11月都有30天，我们可以将它们的所有情况放在一起，让它们穿过任何一个运行相同的事情。
- en: Anyway, I won’t use `switch`  statements again in this book because I just virtually
    never find a good use for them, but it does exist and at least I can say that
    you saw it.
  id: totrans-1023
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，我不会在这本书中再使用`switch`语句，因为我几乎从来没有找到过它的好用处，但它确实存在，至少我可以说你看到了它。
- en: Study Drills
  id: totrans-1024
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Remove some of the `break`  statements in the first `switch`  and add some `println()`  statements
    to confirm that it will set monthName to one value then another then another until
    it finally gets stopped by a `break`.
  id: totrans-1025
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个`switch`中删除一些`break`语句，并添加一些`println()`语句来确认它会将monthName设置为一个值，然后又一个值，直到最后被`break`停止。
- en: 'Exercise 23: More String Comparisons'
  id: totrans-1026
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习23：更多字符串比较
- en: Well, you have learned that you can’t compare Strings with `==`; you have to
    use the `.equals()`
  id: totrans-1027
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，你已经学会了不能用`==`比较字符串；你必须使用`.equals()`
- en: method. But I think you’re finally ready to see how we can compare Strings for
    alphabetical ordering.
  id: totrans-1028
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 方法。但我认为你终于准备好看看我们如何比较字符串的字母顺序了。
- en: '[PRE154]'
  id: totrans-1029
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-1030
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-1031
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-1032
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-1033
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-1034
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-1035
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-1036
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-1037
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-1038
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-1039
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-1040
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-1041
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-1042
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-1043
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-1044
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-1045
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-1046
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-1047
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-1048
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-1049
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-1050
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-1051
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-1052
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-1053
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-1054
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-1055
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-1056
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-1057
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-1058
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-1059
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-1060
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-1061
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-1062
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-1063
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-1064
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-1065
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-1066
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-1067
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-1068
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-1069
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-1070
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-1071
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-1072
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-1073
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: What You Should See
  id: totrans-1074
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE199]'
  id: totrans-1075
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: (Of course I couldn’t resist slipping in something. On line 12 instead of using
    the Scanner object’s
  id: totrans-1076
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （当然，我忍不住在第12行插入了一些东西。而不是使用Scanner对象的
- en: '`.next()`  method to read in a String, I used the Scanner object’s `.nextLine()`  method
    to read in a String. The difference is that `.next()`  will stop reading if you
    type a space, so if you typed `"visual`  `basic"`  it would only read in `"visual"`  and
    leave the rest behind. When you use `.nextLine()`  it reads in everything you
    type including spaces and tabs – up until you press Enter – and puts it all into
    one long String and stores it into the variable name.)'
  id: totrans-1077
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.next()`方法读取一个字符串，我使用Scanner对象的`.nextLine()`方法读取一个字符串。不同之处在于`.next()`会在你输入空格时停止读取，所以如果你输入`"visual`
    `basic"`，它只会读取`"visual"`，并留下其余的部分。当你使用`.nextLine()`时，它会读取你输入的所有内容，包括空格和制表符，直到你按下回车键，然后将所有内容放入一个长字符串中并将其存储到变量中。'
- en: You compare Strings to each other using the String object’s `.compareTo()`  method.
    The
  id: totrans-1078
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以使用String对象的`.compareTo()`方法将字符串相互比较。这个
- en: '`.compareTo()`  method doesn’t work the way you probably expect, but there
    is genius in how it works.'
  id: totrans-1079
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`.compareTo()`方法的工作方式并不是你可能期望的，但它的工作方式是有巧妙之处的。'
- en: 'The comparison involves two Strings. The first String is the one to the left
    of the `.compareTo()`. The second String is the one in the parentheses. And the
    comparison simplifies to an integer! If we call the first one self and the second
    one other it would look like this:'
  id: totrans-1080
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 比较涉及两个字符串。第一个字符串是`.compareTo()`左侧的字符串。第二个字符串是括号内的字符串。比较简化为一个整数！如果我们称第一个为self，第二个为other，它会是这样的：
- en: '[PRE200]'
  id: totrans-1081
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: So self compares itself to other. If self is identical to other (the same length
    and every character the same), then n would be set to `0`. If self comes before
    other alphabetically, then n would be set to a negative number (a number less
    than 0). And if self comes after other alphabetically, then n would be set to
    a positive number (a number greater than 0).
  id: totrans-1082
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以self将自己与other进行比较。如果self与other相同（长度相同，每个字符都相同），那么n将被设置为`0`。如果self在字母表中出现在other之前，那么n将被设置为负数（小于0的数）。如果self在字母表中出现在other之后，那么n将被设置为正数（大于0的数）。
- en: 'The genius part is this: because `.compareTo()`  gives us an integer instead
    of just a Boolean true or false, we only need this one method to do all the comparisons:
    less than, greater than, less than or equal to, whatever.'
  id: totrans-1083
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 天才的部分在于：因为`.compareTo()`给我们的是一个整数，而不仅仅是一个布尔值true或false，我们只需要这一个方法来进行所有的比较：小于、大于、小于或等于，等等。
- en: 'Since if *self* is equal to *other* we would get zero and since if *self* is
    less than *other* we would get a number less than zero, we can write:'
  id: totrans-1084
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为如果*self*等于*other*，我们会得到零，如果*self*小于*other*，我们会得到一个小于零的数字，所以我们可以写：
- en: '[PRE201]'
  id: totrans-1085
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: If the result is less than zero the `if`  statement would be true and if the
    result is equal to zero the `if`
  id: totrans-1086
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果结果小于零，`if`语句将为真，如果结果等于零，`if`语句将为真。
- en: statement would be true. So this is kind­of like writing
  id: totrans-1087
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 语句将为真。这有点像写
- en: '[PRE202]'
  id: totrans-1088
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: …except that what I just wrote won’t actually compile and the `.compareTo()`  trick
    will. Pretty cool, if you ask me.
  id: totrans-1089
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...除了我刚刚写的那个实际上不会编译，而`.compareTo()`的技巧会。如果你问我，这很酷。'
- en: '[PRE203]'
  id: totrans-1090
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-1091
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: So that’s the idea. Pretty confusing for beginners, and slightly harder to use
    but not bad at all once you get used to it.
  id: totrans-1092
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是这个想法。对于初学者来说可能会有些困惑，使用起来稍微有些困难，但一旦你习惯了，就一点也不坏。
- en: 'The other difficulty here (and this is not just a `.compareTo()`  thing, it
    happens everywhere in code unless you write code to fix it) is that capitalization
    matters. `"Bob"`  is not the same value as `"bob"`[. And what’s worse is that
    because of the Unicode values](#bookmark83)7 of the letters, `"Bob"`  comes before
    `"bob"`  alphabetically. If you want to avoid this issue, there are a lot of ways,
    but I like one of these two:'
  id: totrans-1093
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的另一个困难（这不仅仅是一个`.compareTo()`的问题，在代码的任何地方都会发生，除非你写代码来解决它）是大小写的问题。`"Bob"`和`"bob"`不是相同的值。更糟糕的是，由于字母的Unicode值，`"Bob"`在字母表中出现在`"bob"`之前。如果你想避免这个问题，有很多方法，但我喜欢这两种方法中的一种：
- en: '[PRE205]'
  id: totrans-1094
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Or you can let the human type in whatever they want and convert it to lower­case
    right away and then only compare it to lower­case things in your code.
  id: totrans-1095
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者你可以让人类输入任何他们想要的东西，并立即将其转换为小写，然后只与你代码中的小写进行比较。
- en: Study Drills
  id: totrans-1096
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: 1\. Using the method of your choice, make this program work correctly even if
    the human types in words with the “wrong” capitalization.
  id: totrans-1097
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 使用你选择的方法，使这个程序即使在人类输入了“错误”的大写字母的单词时也能正确工作。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_029.png)'
  id: totrans-1098
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_029.png)'
- en: Computers only work with numbers internally. Letters are not numbers, but there
    is a big giant table that maps every character in every language ever to one of
    1,112,063 numbers that uniquely identifies that character. The UTF­8 Unicode value
    of the letter "B"  is 66; the value of the letter "b"  is 98.
  id: totrans-1099
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算机只能在内部处理数字。字母不是数字，但有一个巨大的表，将每种语言中的每个字符映射到1,112,063个数字中的一个，唯一标识该字符。字母“B”的UTF-8
    Unicode值是66；字母“b”的值是98。
- en: 'Exercise 24: Choosing Numbers Randomly'
  id: totrans-1100
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习24：随机选择数字
- en: '[PRE206]'
  id: totrans-1101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-1102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-1103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-1104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-1105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'We’re going to spend a few exercises on something you don’t always see in programming
    books: how to have the computer choose a “random” number within a certain range.
    This is because you can write a *lot* of software without needing the computer
    to randomly pick a number. However, having random numbers will let us make some
    simple interactive games, and that is easily worth the pain of this slightly weird
    concept.'
  id: totrans-1106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在一些练习中花一些时间来学习编程书中并不总是看到的东西：如何让计算机在某个范围内选择一个“随机”数。这是因为你可以写*很多*的软件而不需要计算机随机选择一个数字。然而，有随机数将让我们制作一些简单的互动游戏，这很容易就能弥补这个略微奇怪的概念的痛苦。
- en: What You Should See
  id: totrans-1107
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是什么
- en: '[PRE211]'
  id: totrans-1108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-1109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Note: Your output won’t look the same as mine. The numbers are random, remember?'
  id: totrans-1110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：你的输出不会和我的一样。记住，这些数字是随机的。
- en: 'Java has a built­in function called `Math.random()`. Every time you call the
    function, it will produce a new random `double`  in the range [0,1) (that is,
    it might be exactly `0`  but will never be exactly `1`  and will most likely be
    something in between. So if I write:'
  id: totrans-1111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Java有一个内置的函数叫做`Math.random()`。每次调用这个函数，它都会产生一个新的随机`double`，范围在[0,1)之间（也就是说，它可能正好是`0`，但永远不会正好是`1`，而且很可能是介于两者之间的某个值）。所以如果我写：
- en: '[PRE213]'
  id: totrans-1112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: …then x could have a value of `0`, or `0.123544`, or `0.3`, or `0.999999999`  but
    never `1.0`  and never greater than 1\. So on lines 8 through 10 the function
    `Math.random()`  is called three times, and the result is stored into three different
    variables. These three values are printed so you can see what they are.
  id: totrans-1113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...然后x可能有一个值为`0`，或`0.123544`，或`0.3`，或`0.999999999`，但永远不会是`1.0`，也永远不会大于1。所以在第8到10行，函数`Math.random()`被调用了三次，并且结果被存储到三个不同的变量中。这三个值被打印出来，这样你就可以看到它们是什么。'
- en: 'Unfortunately, I don’t often want a double from [0,1). Imagine a number­guessing
    game where you say “I am thinking of a number with decimals between zero and one:
    try to guess it!” No fun. And we can’t control the range of the value that `Math.random()`  gives
    us, so we have to mush it into a range ourselves.'
  id: totrans-1114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，我经常不想要一个来自[0,1)的double。想象一下一个猜数字的游戏，你说“我在想一个小数在零和一之间的数字：试着猜猜看！”这不好玩。而且我们无法控制`Math.random()`给我们的值的范围，所以我们必须自己将其压缩到一个范围内。
- en: On lines 16 through 18 we pick a new random number, but we multiply it by 100
    before storing it into a variable. (This has the effect of moving the decimal
    two place values to the right.) So we can tell that the original random number
    printed out on line 20 was `0.5733269918363617`  because it is `57.33269918363617`  after
    being multiplied by 100.
  id: totrans-1115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第16到18行，我们选择一个新的随机数，但在存储到变量中之前将其乘以100。（这会使小数点向右移动两位。）因此，我们可以知道在第20行打印出的原始随机数是`0.5733269918363617`，因为乘以100后变成了`57.33269918363617`。
- en: Note that multiplying by 100 still gives us a slight chance of getting exactly
    `0`. If the original random number is 0 then multiplying it doesn’t change that.
    The numbers we store into the variables could be something like `12.3544`, or
    `30.0`, or `99.9999999`  but never `100.0`  and never anything greater than 100.
  id: totrans-1116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，乘以100仍然有可能得到恰好为`0`的情况。如果原始随机数是0，那么乘以它不会改变。我们存储到变量中的数字可能是`12.3544`，或`30.0`，或`99.9999999`，但永远不会是`100.0`，也永远不会大于100。
- en: 'On lines 24 through 26 we perform what is called a “typecast” or just “a cast”.
    The variable x is a double: it can hold numbers with decimals. The variable a
    is an integer: it can hold whole numbers only. Normally you’re not allowed to
    store the value from a `double`  into an `int`. A cast tells the compiler “I know
    that x is a double and that I’m trying to store its value into an `int`  which
    can’t hold decimals. But I don’t care. Why don’t you just pretend that the value
    in x is an integer? It is okay if you have to throw away everything after the
    decimal point. Just do it.”'
  id: totrans-1117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第24到26行，我们执行了所谓的“类型转换”或者“转换”。变量x是一个双精度浮点数：它可以保存带有小数的数字。变量a是一个整数：它只能保存整数。通常情况下，你不允许将`double`的值存储到`int`中。转换告诉编译器“我知道x是一个double，我试图将它的值存储到一个不能保存小数的`int`中。但我不在乎。你为什么不假装x的值是一个整数呢？如果你不得不舍弃小数点后的所有内容，也没关系。”
- en: So on line 24 the computer makes a copy of the value from *x* but everything
    after the decimal point is chopped off and thrown away (“truncated”) and that
    new integer value is stored into the variable *a*. (The value of *x* is unchanged.)
    The value is *not* rounded; it’s truncated.
  id: totrans-1118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在第24行，计算机复制了*x*的值，但小数点后的所有内容被截断并丢弃（“截断”），新的整数值存储到变量*a*中。（*x*的值不变。）这个值*不*是四舍五入的；它是被截断的。
- en: Theoretically what does this give us? If x was originally `0`  or `12.3544`  or
    `30.0`, or `99.9999999`, then a will be `0`  or `12`  or `30`  or `99`  but never
    `100`  or anything bigger than 100\. So a, b and c will always have integer values
    from 0 to 99.
  id: totrans-1119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 理论上，这给了我们什么？如果x最初是`0`或`12.3544`或`30.0`，或`99.9999999`，那么a将是`0`或`12`或`30`或`99`，但永远不会是`100`或任何大于100的数字。因此，a、b和c的值始终为0到99的整数值。
- en: On lines 32 and 33 I have attempted to show that casting from a double to an
    integer does *not* round; the numbers after the decimal point are truncated.
  id: totrans-1120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第32和33行，我尝试表明从双精度浮点数到整数的转换*不*四舍五入；小数点后的数字被截断。
- en: Finally, on lines 38 through 41 a single random number is chosen. In all three
    cases it is multiplied by 10 and then cast to an integer. This means that after
    the cast we always have a number from 0 to 9.
  id: totrans-1121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在第38到41行，选择一个随机数。在所有三种情况下，它都被乘以10，然后转换为整数。这意味着转换后我们总是得到一个从0到9的数字。
- en: But on line 39 that random number from 0 to 9 gets `0`  added to it before storing
    it into a. (Adding `0`
  id: totrans-1122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是在第39行，从0到9的随机数加上`0`后存储到a中。（加`0`不改变数字。）
- en: doesn’t change the number.) So *a* will always have a value from 0­9.
  id: totrans-1123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不改变数字。）因此*a*将始终是0到9的值。
- en: On line 40 the random number from 0 to 9 gets `1`  added to it before storing
    it into b. This makes whatever it is bigger by 1\. If it had been a `0`, it will
    now be a `1`. If it had been a `6`, it will now be a `7`. If it had been a `9`  (the
    maximum), it will now be a `10`. So b will always have a value from 1­10.
  id: totrans-1124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第40行，从0到9的随机数加上`1`后存储到b中。这使得它比原来大1。如果原来是`0`，现在是`1`。如果原来是`6`，现在是`7`。如果原来是`9`（最大值），现在是`10`。因此，b的值始终为1到10。
- en: On line 41 the random number from 0­9 gets `5`  added to it before storing it
    into c. So c will always have a value from 5 to 14\. (This is still ten values.)
  id: totrans-1125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第41行，从0到9的随机数加上`5`后存储到c中。因此，c将始终具有5到14的值。（这仍然是十个值。）
- en: Okay, that’s enough for today.
  id: totrans-1126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，今天就到这里吧。
- en: Study Drills
  id: totrans-1127
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: Remove the cast from line 24\. Try to compile the program. What error message
    do you get? (Then put it back.)
  id: totrans-1128
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除第24行的转换。尝试编译程序。你得到什么错误消息？（然后把它放回去。）
- en: Run the program several times and confirm that *a*, *b* and *c* as printed out
    on lines 28 through 30 always have values from 0 to 99.
  id: totrans-1129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序多次，并确认在第28到30行打印出的*a*、*b*和*c*始终具有0到99的值。
- en: Use your fingers to count and confirm that if I have a number from 0 to 9, there
    are ten possible numbers I could have. Multiplying a random number by ten and
    truncating gives you ten possible results (0­9). Multiplying a random number by
    five and truncating gives you five possible results (0­4).
  id: totrans-1130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用手指数一数，确认如果我有一个从0到9的数字，那么我可能有十个可能的数字。将随机数乘以十并截断会得到十种可能的结果（0­9）。将随机数乘以五并截断会得到五种可能的结果（0­4）。
- en: Run the program several times and confirm that *a* as printed out on line 43
    always has a value from 0­9, that *b* always has a value from 1­10, and *c* always
    has a value from 5­14.
  id: totrans-1131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序多次，并确认在第43行打印出的*a*始终具有0到9的值，*b*始终具有1到10的值，*c*始终具有5到14的值。
- en: 'Exercise 25: More Complex Random Numbers'
  id: totrans-1132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习25：更复杂的随机数
- en: '[PRE214]'
  id: totrans-1133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-1134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-1135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-1136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-1137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: The previous exercise had some tough thinking in it, so instead of teaching
    something new, this exercise will just spend more time with the same concepts.
  id: totrans-1138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一个练习中有一些复杂的思考，所以这个练习不会教授新的东西，而是会花更多时间来学习相同的概念。
- en: What You Should See
  id: totrans-1139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE219]'
  id: totrans-1140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: (Again, you won’t see this. The numbers will be random.)
  id: totrans-1141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （再次强调，你看不到这一点。这些数字将是随机的。）
- en: 'On lines 7 through 11 we choose five random numbers. Each number is multiplied
    by ten and cast to an integer to truncate it (so each random number is one of
    ten numbers: 0 through 9). Then `1`  is added to each, so the variables a through
    e each get a random number from 1 to 10.'
  id: totrans-1142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第7到11行，我们选择了五个随机数。每个数字都乘以10并转换为整数以截断它（因此每个随机数是10个数字之一：0到9）。然后对每个数字加1，所以变量a到e每个都得到1到10的随机数。
- en: On lines 15 through 19 we choose five random numbers again. Each number is multiplied
    by one
  id: totrans-1143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第15到19行，我们再次选择了五个随机数。每个数字都乘以一
- en: 'hundred and cast to an integer to truncate it (so each random number is one
    of 100 numbers: 0 through 99). Then `1`  is added to each, so the variables a
    through e each get a random number from 1 to 100.'
  id: totrans-1144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 百分之一并转换为整数以截断它（因此每个随机数是100个数字之一：0到99）。然后对每个数字加1，所以变量a到e每个都得到1到100的随机数。
- en: 'On lines 23 through 27 we choose five more random numbers. Each number is multiplied
    by 31 and cast to an integer to truncate it (so each random number is one of 31
    numbers: 0 through 30). Then `70`  is added to each. `0`  plus `70`  gives 70\.
    `1`  plus `70`  gives 71\. `23`  plus `70`  gives 93\. `30`  (the maximum) plus
    `70`  gives 100\. So the variables a through e each get a random number from 70
    to 100.'
  id: totrans-1145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第23到27行，我们选择了另外五个随机数。每个数字都乘以31并转换为整数以截断它（因此每个随机数是31个数字之一：0到30）。然后每个数字都加上70。`0`加上`70`得到70。`1`加上`70`得到71。`23`加上`70`得到93。`30`（最大值）加上`70`得到100。因此，变量a到e每个都得到70到100的随机数。
- en: 'So the general formula is this:'
  id: totrans-1146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，一般公式是这样的：
- en: '[PRE220]'
  id: totrans-1147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '*low* is the smallest possible number we want. *range* is **how many** random
    numbers should be in the range. If you know your lowest possible number and your
    highest possible number but not how many numbers that is, the formula is:'
  id: totrans-1148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*low*是我们想要的最小可能数字。*range*是**范围内**应该有多少个随机数。如果你知道你的最小可能数字和最大可能数字，但不知道有多少数字，那么公式是：'
- en: '[PRE221]'
  id: totrans-1149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: If the lowest random number I want is `1`  and the highest random number is
    `5`, then the range [is five. 5 minus 1 is 4, then add one to account for the
    fact that subtracting gives you the distance between two numbers, not the count
    of stopping points along the way.](#bookmark90) [8](#bookmark90)
  id: totrans-1150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我想要的最小随机数是`1`，最大随机数是`5`，那么范围[是五。5减1是4，然后加1来解决减法给出的两个数字之间的距离，而不是沿途停止点的计数。](#bookmark90)
    [8](#bookmark90)
- en: 'You could even write the formula like this:'
  id: totrans-1151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你甚至可以这样写公式：
- en: '[PRE222]'
  id: totrans-1152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: This will have the computer pick a random number from *low* to *high*. And this
    is exactly what we do on lines 34 through 38.
  id: totrans-1153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使计算机从*low*到*high*中选择一个随机数。这正是我们在第34到38行所做的。
- en: Study Drills
  id: totrans-1154
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Change the values of *low* and *high* on lines 31 and 32 to something else.
    Compile it and run the program many times to confirm that you always get random
    numbers in that range.
  id: totrans-1155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改第31行和第32行的*low*和*high*的值为其他值。编译并运行程序多次，以确认您总是在该范围内获得随机数。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_032.png)'
  id: totrans-1156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_032.png)'
- en: 'There is a common logical error in programming that can occur if you accidentally
    count distance instead of stops; it is called the “fencepost problem.” The name
    comes from the following brain­teaser: if I need to build a fence five meters
    long using a bunch of wooden boards that are slightly longer than one meter each,
    how many fence posts will I need? You need five boards but six fence *posts*.'
  id: totrans-1157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编程中常见的逻辑错误是，如果您意外地计算距离而不是停止，就会发生“栅栏问题”。这个名字来自以下脑筋急转弯：如果我需要用一堆略长于一米的木板建造五米长的栅栏，我需要多少栅栏柱？你需要五块木板，但需要六根栅栏*柱*。
- en: 'Exercise 26: Repeating Yourself with the While Loop'
  id: totrans-1158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习26：使用while循环重复自己
- en: This is one of my favorite exercises, because you are going to learn how to
    make chunks of code *repeat*. And if you can do that, you will be able to write
    all *sorts* of interesting things.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我最喜欢的练习之一，因为你将学会如何使代码块*重复*。如果你能做到这一点，你就能写出各种有趣的东西。
- en: '[PRE223]'
  id: totrans-1160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: What You Should See
  id: totrans-1161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE224]'
  id: totrans-1162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: On line 16 you get your first look at the `while`  loop. A `while`  loop is
    similar to an `if`  statement. They both have a condition in parentheses that
    is checked to see if it true or false. If the condition is false, both `while`  loops
    and `if`  statements will skip all the code in the body. And when the condition
    is true, both `while`  loops and `if`  statement will execute all of the code
    inside their body one time.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 在第16行，您首次看到`while`循环。`while`循环类似于`if`语句。它们都有括号中的条件，用于检查其真假。如果条件为假，则`while`循环和`if`语句都将跳过主体中的所有代码。当条件为真时，`while`循环和`if`语句都将执行其主体中的所有代码一次。
- en: The only difference is that `if`  statements that are true will execute all
    of the code in the curly braces exactly once. `while`  loops that are true will
    execute all of the code in the curly braces once and then go back up and check
    the condition again. If the condition is still true, the code in the body will
    all be executed again. Then it checks the condition again and runs the body again
    if the condition is still true.
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，`if`语句为真时将执行大括号中的所有代码一次。`while`循环为真时将执行大括号中的所有代码一次，然后返回并再次检查条件。如果条件仍然为真，则再次执行主体中的所有代码。然后再次检查条件，如果条件仍然为真，则再次运行主体。
- en: In fact, you could say that the `while`  loop executes all of the code in its
    body over and over again as long as its condition is true when checked.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以说`while`循环会执行其主体中的所有代码，只要在检查时条件为真。
- en: Eventually, the condition will be false when it is checked. Then the `while`  loop
    will skip over all the code in its body and the rest of the program will continue.
    Once the condition of a `while`  loop is false, it doesn’t get checked again.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当检查条件时，条件将为假。然后`while`循环将跳过其主体中的所有代码，程序的其余部分将继续。一旦`while`循环的条件为假，它就不会再次被检查。
- en: 'Looping is *so* great because we can finally do something more than once without
    having to type the code for it more than once! In fact, programmers sometimes
    say “Keep your code D.R.Y: Don’t Repeat Yourself.” Once you know how to program
    pretty well and finish all of the exercises in this book, you will start to get
    suspicious if you find yourself typing (or copying­and­pasting) the exact same
    code more than once in a program.'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是如此伟大，因为我们终于可以做一些事情不止一次，而不必多次输入代码！事实上，程序员有时会说“保持你的代码DRY：不要重复自己。”一旦你学会了编程并完成了本书中的所有练习，如果你发现自己在程序中多次输入（或复制粘贴）完全相同的代码，你会开始怀疑。
- en: 'Exercise 27: A Number­Guessing Game'
  id: totrans-1168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习27：一个猜数字游戏
- en: Now that you know how to repeat something using a `while`  loop we are going
    to write a program that another human might actually enjoy running? Are you as
    excited as I am about this?
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用`while`循环重复某些内容，我们将编写一个实际上另一个人可能会喜欢运行的程序？你对此和我一样兴奋吗？
- en: '[PRE225]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-1171
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-1172
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-1173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-1174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-1175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-1176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-1177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-1178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-1179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: What You Should See
  id: totrans-1180
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE235]'
  id: totrans-1181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: So on line 10 the computer chooses a random number from 1 to 100 and stores
    it into the variable *secret*. We let the human make a guess.
  id: totrans-1182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以在第10行，计算机从1到100中选择一个随机数，并将其存储到变量*secret*中。我们让人类猜测。
- en: Line 16 has a `while`  loop. It says “As long as the value of the variable secret
    is not the same as the value of the variable guess… run the following chunk of
    code.” Lines 17 through 28 are the body of the loop. Every time the condition
    is true, all twelve of these lines of code get executed.
  id: totrans-1183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第16行有一个`while`循环。它说“只要变量secret的值与变量guess的值不同...运行以下代码块。”第17行到第28行是循环的主体。每当条件为真时，这十二行代码都会被执行。
- en: Inside the body of the loop we have a couple of `if`  statements. We already
    know that the human’s guess is different from the secret number or we wouldn’t
    be inside the `while`  loop to begin with! But we don’t know if the guess is wrong
    because it is too low or because it is too high, so these `if`  statements figure
    that out and display the appropriate error message.
  id: totrans-1184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在循环体内，我们有几个`if`语句。我们已经知道人类的猜测与秘密数字不同，否则我们就不会一开始就进入`while`循环！但我们不知道猜测是错误是因为它太低还是因为它太高，所以这些`if`语句找出来并显示适当的错误消息。
- en: Then after the error message is displayed, on line 27 we allow them to guess
    again. The human (hopefully) types in a number which is then stored into the variable
    *guess*, overwriting their previous guess in that variable.
  id: totrans-1185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在显示错误消息后，第27行我们允许他们再次猜测。人类（希望）输入一个数字，然后存储到变量*guess*中，覆盖该变量中的先前猜测。
- en: Then the program loops back up to line 16 and checks the condition again. If
    the condition is *still* true (their guess is still not equal to the secret number)
    then the whole loop body will execute again. If the condition is now false (they
    guessed it) then the whole loop body will be skipped and the program will skip
    down to line 29.
  id: totrans-1186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后程序循环回到第16行并再次检查条件。如果条件仍然为真（他们的猜测仍然不等于秘密数字），则整个循环体将再次执行。如果条件现在为假（他们猜中了），则整个循环体将被跳过，程序将跳到第29行。
- en: If the loop is over, we know the condition is false. So we don’t need a new
    `if`  statement down here; it is safe to print “you guessed it.”
  id: totrans-1187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果循环结束，我们知道条件为假。所以我们不需要在这里加一个新的`if`语句；安全地打印“你猜对了”。
- en: 'Exercise 28: Infinite Loops'
  id: totrans-1188
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习28：无限循环
- en: '[PRE236]'
  id: totrans-1189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-1190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-1191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-1192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-1193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-1194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-1195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'One thing which sometimes surprises students is how easy it is to make a loop
    that repeats *forever*[. These are called “infinite loops” and we sometimes make
    them on purpose](#bookmark98)9 but usually they are the result of a logical error.
    Here’s an example:'
  id: totrans-1196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时让学生感到惊讶的是，制作一个重复“永远”的循环是多么容易。这些被称为“无限循环”，有时我们故意制造它们，但通常它们是逻辑错误的结果。这里有一个例子：
- en: What You Should See
  id: totrans-1197
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE243]'
  id: totrans-1198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_036.png)'
  id: totrans-1199
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_036.png)'
- en: For example, in college one of my assignments in my Network Protocols class
    was to write a web server. Web servers listen to the network for a page request.
    Then they find the requested page and send it over the network to the requesting
    web browser. And then they wait for another request. I used an infinite loop on
    purpose in that assignment because the web server software was intended to start
    automatically when the machine booted, run the whole time, and only shut down
    when the machine did.
  id: totrans-1200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，在大学时，我在网络协议课上的一个作业是写一个网络服务器。网络服务器监听网络以获取页面请求。然后它找到请求的页面并将其发送到请求的网络浏览器。然后它等待另一个请求。我在那个作业中故意使用了一个无限循环，因为网络服务器软件旨在在机器启动时自动启动，全天候运行，并且只在机器关闭时关闭。
- en: '[PRE244]'
  id: totrans-1201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The program actually didn’t stop on it’s own; I had to stop it by pressing CTRL­C
    while the program was repeating and repeating.
  id: totrans-1202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序实际上没有自行停止；在程序一遍又一遍地重复时，我不得不按下CTRL-C来停止它。
- en: This code has an infinite loop in it. Line 16 checks to see if the value of
    the variable *secret* is different than the value of the variable *guess*. If
    so, it executes the body of the loop and if not it skips over the loop body down
    to line 21.
  id: totrans-1203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码中有一个无限循环。第16行检查变量*secret*的值是否与变量*guess*的值不同。如果是，它执行循环体，如果不是，它跳过循环体到第21行。
- en: The problem is that once *secret* and *guess* are different the program can
    never reach another line of code that changes either variable, so the loop repeats
    lines 16 through 20 forever.
  id: totrans-1204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题是一旦*secret*和*guess*不同，程序就永远无法到达另一行代码来改变任一变量，所以循环将永远重复第16行到第20行。
- en: 'So when you are writing the condition of a while loop, try to keep in the back
    of your mind: “I need to make sure there’s a way for this condition to eventually
    become false.”'
  id: totrans-1205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以当你写一个while循环的条件时，试着记住：“我需要确保这个条件最终会变成假”。
- en: Study Drills
  id: totrans-1206
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: Fix the code so that it no longer makes an infinite loop.
  id: totrans-1207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复代码，使其不再产生无限循环。
- en: 'Exercise 29: Using Loops for Error­Checking'
  id: totrans-1208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习29：使用循环进行错误检查
- en: So far in this book we have mostly been ignoring error­checking. We have assumed
    that the human will follow directions, and if their lack of direction­following
    breaks our program, we just blame the user and don’t worry about it.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，我们大多数时间都在忽略错误检查。我们假设人类会遵循指示，如果他们的缺乏方向性导致我们的程序出错，我们只是责怪用户，不予理会。
- en: This is totally fine when you are just learning. Error­checking is hard, which
    is why most big programs have bugs and it takes a whole army of people working
    really hard to make sure that software has as few bugs as possible.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只是在学习时，这是完全可以的。错误检查很难，这就是为什么大多数大型程序都有错误，并且需要一整群人非常努力地工作，以确保软件尽可能少地出现错误。
- en: '[PRE245]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-1215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-1217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-1219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: But you are finally to the point where you *can* code a little bit of error­checking.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你终于到了能够编写一点错误检查的程度。
- en: What You Should See
  id: totrans-1224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE257]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Starting on line 14 is an example of what I call an “input protection loop.”
    On line 20 we are going to take the square root of whatever value is in the variable
    x and we would like to make sure it contains a positive number before we do that.
    (Java does not have built­in support for imaginary numbers.) We could just use
    the built­in absolute value function `Math.abs()`, but I’m trying to demonstrate
    error­checking, okay?
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 从第14行开始是我所说的“输入保护循环”的一个例子。在第20行，我们将对变量x中的任何值取平方根，并且在这样做之前，我们希望确保它包含一个正数。（Java没有内置支持虚数。）我们可以使用内置的绝对值函数`Math.abs()`，但我想演示错误检查，好吗？
- en: On line 12 we let the human type in a number. We have asked them nicely to only
    type in a positive number, but they can type whatever they like. (They could even
    type “Mister Mxyzptlk”, but our error­checking skill aren’t advanced enough to
    survive that, yet.)
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 在第12行，我们让人类输入一个数字。我们已经很客气地要求他们只输入一个正数，但他们可以输入任何他们喜欢的东西。（他们甚至可以输入“Mister Mxyzptlk”，但我们的错误检查技能还不够先进，无法幸存下来。）
- en: So on line 14 we check to see if they followed directions. If the value in *x*
    is negative (less than zero) we print out an error message and let them try again.
    THEN, after they have typed their new number we *go back up* to line 14 and check
    if the condition is still true. Are they still failing to follow directions? If
    so, display the error message again and give them another chance.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在第14行，我们检查他们是否遵守了指示。如果*x*中的值为负数（小于零），我们会打印出一个错误消息，让他们再试一次。然后，在他们输入新数字之后，我们*回到*第14行，检查条件是否仍然为真。他们是否仍然没有遵循指示？如果是，再次显示错误消息并给他们另一个机会。
- en: Computers don’t get impatient or bored, so the human is **trapped** in this
    loop until they comply. They could type negative numbers two billion times and
    each time the computer would politely complain and make them type something again.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不会不耐烦或无聊，所以人类**被困**在这个循环中，直到他们遵守。他们可以输入负数两十亿次，每次计算机都会礼貌地抱怨并让他们重新输入。
- en: Eventually, the human will wise up and type a non­negative number. Then the
    condition of the `while`  loop will be false (finally) and the body of the loop
    will be skipped (finally) and execution will pick up on line 20 where we can safely
    take the square root of a number that we know is positive.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，人类会变得聪明，输入一个非负数。然后`while`循环的条件将为假（终于），循环的主体将被跳过（终于），执行将在第20行继续，我们可以安全地计算一个我们知道是正数的数的平方根。
- en: Real programs have stuff like this *all over*. You have to do it because humans
    are unreliable and often do unexpected things. What happens when your toddler
    pulls himself up to your laptop and starts mashing keys while a program is running?
    We would like the program to not crash.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的程序到处都有这样的东西。你必须这样做，因为人类不可靠，经常做出意想不到的事情。当你的孩子在程序运行时拉起笔记本电脑并开始乱按键时会发生什么？我们希望程序不会崩溃。
- en: 'Oh, and did you notice? I changed up something in this program. So far every
    time in this book I have printed something on the screen, I have put a blank space
    between the parentheses and the quotation marks, like so:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，你有没有注意到？我在这个程序中改变了一些东西。到目前为止，我在这本书中每次在屏幕上打印东西时，我都在括号和引号之间放了一个空格，就像这样：
- en: '[PRE258]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'I did that because I wanted to make it clear that the thing inside the quotes
    (technically a “String literal”) was one thing, and the parentheses were another.
    But Java doesn’t actually care about those spaces. (Remember that I am full of
    lies.) Your program will still compile and work exactly the same if you leave
    the spaces out:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样做是因为我想要清楚地表明引号内的东西（技术上称为“字符串文字”）是一回事，而括号是另一回事。但是Java实际上并不在乎这些空格。（记住我充满了谎言。）如果你去掉空格，你的程序仍然会编译并且工作得和原来一样：
- en: '[PRE259]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: You might have noticed that on line 22 I even left out the spaces between the
    String literals and the plus signs. Spacing like this doesn’t affect the syntax
    of a Java program, although many companies and other software­writing groups have
    “style guidelines” that tell you what the Right Way to format your code is if
    you want to make other members of the group happy.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在第22行，我甚至省略了字符串文字和加号之间的空格。这样的间距不会影响Java程序的语法，尽管许多公司和其他软件编写团体都有“样式指南”，告诉你如果你想让团体的其他成员满意，应该以什么样的方式格式化你的代码。
- en: 'Some people get very worked up about this. They think you should always use
    spaces to indent your code, or always put the open brace of a code block at the
    end of the previous line:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对此非常激动。他们认为你应该始终使用空格来缩进你的代码，或者始终将代码块的开放大括号放在上一行的末尾：
- en: '[PRE260]'
  id: totrans-1238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: …like that. I think for your own code, you should give other styles a try and
    do what makes you happy. And when you’re working with others, you should format
    the code in a way that makes them happy.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: …就像那样。我认为对于你自己的代码，你应该尝试其他风格，并做让你快乐的事情。当你和其他人一起工作时，你应该以让他们满意的方式格式化代码。
- en: There are even tools that can change the format of your code automatically to
    fit a certain style! (Search for “source code beautifier” or “Java pretty printer”
    to see some examples.)
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至有一些工具可以自动更改代码的格式以适应特定的风格！（搜索“源代码美化器”或“Java代码美化器”来看一些例子。）
- en: Study Drills
  id: totrans-1241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习方法
- en: 1\. Instead of an input protection loop use an `if`  statement and `Math.abs()`  to
    handle taking the square root of negative numbers, too. Detect when the number
    is negative, take the square root of the positive version, and print a little
    `"i"`  next to the answer.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 不要使用输入保护循环，使用`if`语句和`Math.abs()`来处理负数的平方根。当数字为负时，取正数的平方根，并在答案旁边打印一个小的“i”。
- en: 'Exercise 30: Do­While loops'
  id: totrans-1243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习30：Do-While循环
- en: In this exercise I am going to do something I normally don’t do. I am going
    to show you another way to make loops in Java. Since you have only been looking
    at `while`  loop for four exercises, showing you a different type of loop can
    be confusing. Usually I like to wait until students have been doing something
    a long time before I show them a new way to do the same thing.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我要做一些我通常不做的事情。我要向你展示在Java中制作循环的另一种方法。因为你只看了四个练习的`while`循环，向你展示一种不同类型的循环可能会让你感到困惑。通常我喜欢等到学生做了很长时间的事情后再向他们展示做同样事情的新方法。
- en: So if you think you are going to be confused, feel free to skip this exercise.
    It won’t hurt you hardly at all, and you can come back to it when you’re feeling
    more confident.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果你认为你会感到困惑，随时可以跳过这个练习。这几乎不会伤害你，你可以在更有信心的时候再回来。
- en: Anyway, there are several ways to make a loop in Java. In addition to the `while`  loop,
    there is also a do­while loop. They are virtually identical because they both
    check a condition in parentheses. If the condition is true, the body of the loop
    is executed. If the condition is false, the body of the loop is skipped (or the
    looping stops).
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在Java中有几种制作循环的方法。除了`while`循环之外，还有do-while循环。它们几乎相同，因为它们都在括号中检查条件。如果条件为真，则执行循环体。如果条件为假，则跳过循环体（或停止循环）。
- en: So what’s the difference? Type in the code and then we’ll talk about it.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有什么区别呢？输入代码，然后我们再谈论它。
- en: '[PRE261]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: What You Should See
  id: totrans-1249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE262]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: There are only two differences between `while`  loops and do­while loops.
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环和do-while循环之间只有两个区别。'
- en: The condition of a `while`  loop is before the body, but do­while loops just
    have the keyword `do`  before the body and the condition is at the end, just after
    the close curly brace. (And there’s a semicolon after the close paren of the loop
    condition, which `while`  loops don’t have.)
  id: totrans-1252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`循环的条件在循环体之前，但是do-while循环在循环体之前有关键字`do`，条件在循环体结束后，紧跟着右花括号。 （并且在循环条件的右括号后有一个分号，而`while`循环没有。）'
- en: '`while`  loops check their condition before going into the loop body, but do­while
    loops run the body of the loop once no matter what and only check the condition
    after the first time through.'
  id: totrans-1253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`循环在进入循环体之前检查它们的条件，但是do-while循环无论如何都会运行一次循环体，并且只在第一次通过后检查条件。'
- en: In computer­science circles, the `while`  loop is called a “pre­test” loop (because
    it checks the condition first) and the do­while is called a “post­test” loop (because
    it checks the condition afterward).
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，`while`循环被称为“前测试”循环（因为它首先检查条件），而do-while被称为“后测试”循环（因为它在之后检查条件）。
- en: If the condition of the `while`  loop is true the very first time it is checked,
    then code using a `while`  loop and equivalent code using a do­while loops will
    behave exactly the same. Anything you can do with a `while`  loop you could do
    with a do­while loop (and slightly different code) and vice­versa.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`while`循环的条件在第一次检查时为真，那么使用`while`循环的代码和使用do-while循环的等效代码将表现完全相同。任何你可以用`while`循环做的事情，你也可以用do-while循环（和稍微不同的代码）做，反之亦然。
- en: So why would the developers of Java bother to make a do­while loop? Because
    sometimes what you’re checking in the condition is something you don’t really
    know until you have gone through the body of the loop at least once.
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么Java的开发者要费心制作do-while循环呢？因为有时你在条件中检查的是一些在至少执行一次循环体后才知道的东西。
- en: In this case, we are flipping a coin by picking a random number between 1­2
    and using an `if`  statement. Then we ask them if they want to flip again or stop.
    The condition of our loop repeats if they say they want to flip again.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过选择1-2之间的随机数来抛硬币，并使用`if`语句。然后我们问他们是否想再抛一次或停止。如果他们说想再抛一次，我们的循环条件会重复。
- en: 'If we had done this with a `while`  loop, the condition would look like this:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`while`循环来做这个，条件会是这样的：
- en: '[PRE263]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: This is fine, and would work, but the variable *again* doesn’t get a value until
    line 28\. And so our code wouldn’t compile because *again* (in the words of the
    Java compiler) “might not have been initialized.” And so we would have to give
    it a value up before the loop that doesn’t mean anything and is only there to
    please the compiler.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，也可以工作，但是变量*again*直到第28行才得到一个值。所以我们的代码不会编译，因为*again*（用Java编译器的话）“可能尚未初始化”。所以我们必须在循环之前给它一个没有意义的值，只是为了取悦编译器。
- en: That is annoying, so the do­while loop allows us to leave our condition the
    same but wait until the end to check it. This is handy.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 这很烦人，所以do-while循环允许我们保持条件不变，但等到最后再检查它。这很方便。
- en: Study Drills
  id: totrans-1262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Change the code so that it uses a `while`  loop instead of a do­while loop.
    Make sure it compiles and works the same.
  id: totrans-1263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码，使用`while`循环代替do-while循环。确保它能编译并且运行结果相同。
- en: Change it back to a do­while loop. (You might look back at this code later when
    you forget how to write a do­while loop and we don’t want your only example to
    have been changed to a `while`  loop.)
  id: totrans-1264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它改回do-while循环。（当你忘记如何编写do-while循环时，你可能会回头看这段代码，我们不希望你唯一的例子被改成`while`循环。）
- en: 'Exercise 31: Adding Values One at a Time'
  id: totrans-1265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习31：逐个添加值
- en: 'This exercise will demonstrate something that you have to do a *lot*: dealing
    with values that you only get one at a time.'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示一件你必须经常做的事情：处理一次只得到一个值。
- en: 'If I asked you to let the human type in three numbers and add them up, and
    if I promised they would only need to type in exactly three numbers (never more,
    never fewer), you would probably write something like this:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我让你让人类输入三个数字并将它们相加，并且我保证他们只需要输入确切的三个数字（不多，不少），你可能会写出这样的东西：
- en: '[PRE264]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'If I told you the human was going to type in *five* numbers, your code might
    look like this:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我告诉你人类要输入*五*个数字，你的代码可能是这样的：
- en: '[PRE265]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: But what if I told you they wanted to type in one hundred numbers? Or ten thousand?
    Or *maybe* three and *maybe* five, I’m not sure? Then you need a different approach.
    You’ll need a loop (that’s how we repeat things, after all). And you need a variable
    that will add the values one at a time as they come. A variable that starts with
    “nothing” in it and adds values one at a time is called an “accumulator” variable,
    although that’s a pretty old word and so your friends who code may never have
    heard it if they’re under the age of forty.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我告诉你他们想要输入一百个数字呢？或者一万个？或者*可能*是三个，*可能*是五个，我不确定？那么你需要另一种方法。你需要一个循环（这就是我们重复事情的方式），并且你需要一个变量，它将随着值的逐个添加而逐渐增加。一个从“空白”开始并逐个添加值的变量称为“累加器”变量，尽管这是一个相当古老的词，所以如果你的编程朋友年龄不到四十岁，他们可能从未听说过。
- en: 'Anyway, the basic idea looks like this:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，基本想法看起来是这样的：
- en: '[PRE266]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: What You Should See
  id: totrans-1274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE267]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'We need two variables: one to hold the value they just typed in (*current*)
    and one to hold the running total (um… *total*). On line 9, we make sure to start
    by putting a zero into *total*. You’ll see why soon.'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个变量：一个用于保存他们刚刚输入的值（*current*），一个用于保存运行总数（嗯...*total*）。在第9行，我们确保首先将零放入*total*中。很快你就会明白为什么。
- en: On line 17 the human gets to type in a number. This is inside the body of a
    do­while loop, which runs at least once no matter what, so this code always happens.
    Let’s pretend they type `3`  at first.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17行，人类可以输入一个数字。这是在do-while循环的主体内，无论如何都会运行至少一次，所以这段代码总是会发生。假设他们一开始输入`3`。
- en: On line 18 the first half of the magic happens. We declare a new variable called
    *newtotal* and set its value equal to the number the human just typed plus *whatever
    value is already in the variable* total. There’s a zero in *total* at first, so
    this line of code adds zero to *current* and stores that number into *newtotal*.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 在第18行，魔法的第一部分发生了。我们声明了一个名为*newtotal*的新变量，并将其值设置为人类刚刚输入的数字加上*变量*total中已经存在的值。一开始*total*中有一个零，所以这行代码将零添加到*current*中，并将该数字存储到*newtotal*中。
- en: 'Then on line 19 the second half of the magic happens: we replace the value
    in total (the zero) with the current value of newtotal. So now total no longer
    has a zero in it; it has the same value current did. So total was `0`, now it
    is `3`.'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第19行，魔法的第二部分发生了：我们用newtotal的当前值替换total中的值（零）。所以现在total不再是零；它具有与current相同的值。所以total是`0`，现在是`3`。
- en: Then we print the subtotal and on line 21 check to see if *current* was zero.
    If not, the loop repeats back up line 14.
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印小计，并在第21行检查*current*是否为零。如果不是，则循环重复到第14行。
- en: The human gets to type in a second number. Let’s say it is a `4`. The variable
    newtotal gets initialized to
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可以输入第二个数字。假设是`4`。变量newtotal被初始化为
- en: current (`4`) plus total (`3`), so newtotal is `7`. Then on line 19 we change
    total’s value to `7`.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: current（`4`）加上total（`3`），所以newtotal是`7`。然后在第19行，我们将total的值更改为`7`。
- en: The condition is checked again, and the process continues. Eventually the human
    types a `0`, that `0`  gets added to the total (which doesn’t hurt it) and the
    condition is false so the do­while loop stops looping.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 条件再次被检查，过程继续。最终，人类输入了一个`0`，那个`0`被添加到总数中（这不会伤害它），条件变为假，所以do-while循环停止循环。
- en: 'I should mention two things before the exercise ends:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 在练习结束之前，我应该提到两件事：
- en: Because the variable *newtotal* is declared (and defined) on line 18, the scope
    of that variable is limited to the body of the do­while loop. That means on line
    21, *newtotal* is no longer in scope, so any attempt to reference *newtotal* in
    the condition of the do­while loop would give an error. The variable keeps getting
    created and destroyed each time through the loop. This is sort­of inefficient.
  id: totrans-1285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为变量*newtotal*在第18行被声明（并定义），所以该变量的范围仅限于do-while循环的主体。这意味着在第21行，*newtotal*不再在范围内，因此在do-while循环的条件中引用*newtotal*的任何尝试都会导致错误。该变量在每次循环中不断创建和销毁。这有点低效。
- en: 'We could have coded this without even using a *newtotal* variable. Since Java
    figures out the final value of the right­hand side before storing it into the
    variable named on the left­hand side, we could have combined lines 18 and 19 into
    a single line:'
  id: totrans-1286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以编写代码而不使用*newtotal*变量。由于Java在将右侧的最终值存储到左侧命名的变量之前，我们可以将第18行和第19行合并为一行：
- en: '[PRE268]'
  id: totrans-1287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: This works totally fine. (In fact, you have seen it before.)
  id: totrans-1288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个工作完全正常。（事实上，你以前见过它。）
- en: Study Drills
  id: totrans-1289
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Rewrite the code to use a `while`  loop instead of a do­while loop. Get it to
    compile and make sure it still works. Then change it back.
  id: totrans-1290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写代码，使用`while`循环而不是do-while循环。确保它能够编译并确保它仍然有效。然后改回来。
- en: Change the condition of the do­while loop so that the loop stops when *newtotal*
    is exactly 20.
  id: totrans-1291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改do-while循环的条件，使得当*newtotal*恰好为20时循环停止。
- en: Oh? It doesn’t compile because *newtotal* is out of scope? Change where *newtotal*
    is declared so that this works.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 哦？它不编译，因为*newtotal*超出了范围？更改*newtotal*声明的位置，使其正常工作。
- en: 'Exercise 32: Adding Values for a Dice Game'
  id: totrans-1293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习32：为骰子游戏添加值
- en: Pig is a simple dice game for two or more players. (You can read the Wikipedia
    entry for Pig if you want a lot more information.) The basic idea is to be the
    first one to “bank” a score of 100 points. When you roll a 1, your turn ends and
    you gain no points that turn. Any other roll adds to your score for that turn,
    but you only keep those points if you decide to “hold”. If you roll a 1 before
    you hold, all your points for that turn are lost.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: Pig是一个简单的骰子游戏，适用于两个或更多玩家。（如果您想了解更多信息，可以阅读维基百科关于Pig的条目。）基本思想是成为第一个“存入”100分的人。当您掷出1时，您的回合结束，这一回合您不会获得任何分数。任何其他掷骰都会增加您这一回合的分数，但只有在您决定“保留”时才能保留这些分数。如果在保留之前掷出1，那么您这一回合的所有分数都将丢失。
- en: 1 import java.util.Scanner; 2
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 1 导入java.util.Scanner; 2
- en: 3 public class PigDiceComputer 4 {
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 3 public class PigDiceComputer 4 {
- en: '5'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '14'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: '17'
- en: '18'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: '18'
- en: '19'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '23'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '23'
- en: '24'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: '25'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: public static void main( String[] args )
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '{'
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: Scanner keyboard = new Scanner(System.in);
- en: int roll, total;
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: int roll, total;
- en: total = 0;
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0;
- en: do
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 做
- en: '{'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: roll = 1 + (int)(Math.random()*6);
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: roll = 1 + (int)(Math.random()*6);
- en: System.out.println( "Computer rolled a " + roll + "." ); if ( roll == 1 )
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("计算机掷出了" + roll + "。"); if (roll == 1)
- en: '{'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "\tThat ends its turn." ); total = 0;
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\t这结束了它的回合。"); total = 0;
- en: '}'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: total += roll;
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: total += roll;
- en: System.out.println( "\tComputer has " + total + " points so far this
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\t计算机到目前为止获得了" + total + "分。");
- en: round." ); 26
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 回合。"); 26
- en: '27'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: '28'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '29'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: '30'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '31'
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '32'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: '33'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: '34'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: if ( total < 20 )
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（总数<20）
- en: '{'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "\tComputer chooses to roll again." );
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("\t计算机选择再次掷骰。");
- en: '}'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} while ( roll != 1 && total < 20 );'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: '} while (roll != 1 && total < 20);'
- en: System.out.println( "Computer ends the round with " + total + " points." );
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("计算机以" + total + "分结束本轮。");
- en: 35 }
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 35 }
- en: 36 }
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 36 }
- en: You know enough to handle the code for the entire game of Pig, but it is a *lot*
    at once compared to the smaller programs you have been seeing, so I am going to
    break it into two lessons. Today we will write only the artificial intelligence
    (A.I.) code for a computer player. This computer player will utilize the “hold
    at 20” strategy, which means the computer keeps rolling until their score for
    the turn adds up to 20 or more, and then holds no matter what. This is actually
    not a terrible strategy, and it is easy enough to code.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经掌握了整个Pig游戏的代码，但与您之前看到的较小程序相比，这是一次性的*很多*，所以我将把它分成两节课。今天我们只会为计算机玩家编写人工智能（A.I.）代码。这个计算机玩家将使用“在20时保留”策略，这意味着计算机会继续掷骰，直到他们这一回合的分数达到20或更多，然后无论如何都会保留。这实际上并不是一个糟糕的策略，而且编码起来也很容易。
- en: What You Should See
  id: totrans-1353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预期输出
- en: '[PRE269]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Basically the whole program is in the body one big do­while loop that tells
    the computer when to stop: either it rolls a 1 or it gets a total of 20 or more.
    As long as the roll is not one *and* the total is less than 20, the condition
    will be true and the loop will start over from the beginning (on line 13). And
    we choose a do­while loop because we want the computer to roll at least once no
    matter what.'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上整个程序都在一个大的do-while循环体中，告诉计算机何时停止：要么掷出1，要么总数达到20或更多。只要掷骰不是1 *并且*总数小于20，条件就会成立，循环将从开始重新开始（在第13行）。我们选择do-while循环是因为我们希望计算机无论如何都至少掷一次骰子。
- en: 'The roll is made on line 15: a random number from 1­6 is a good substitute
    for rolling a dice.'
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 掷骰发生在第15行：从1到6的随机数字是掷骰的良好替代品。
- en: On line 17 we check for rolling a 1\. If so, all points are lost. If not (`else`),
    we add this roll to the running total. Notice we used “plus equals”, which we
    have seen before.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17行，我们检查是否掷出了1。如果是，所有分数都将丢失。如果不是（`else`），我们将此次掷骰的分数加到总分上。请注意我们使用了“加等于”，这是我们以前见过的。
- en: The `if`  statement on line 26 is just so we can get a nice message that the
    computer is going to roll again. Not terrible, right? So come back next lesson
    for the full game!
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 第26行的`if`语句只是为了得到一个漂亮的消息，即计算机将再次掷骰。不错，对吧？所以下一课我们将回来玩完整的游戏！
- en: Study Drills
  id: totrans-1359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: 1\. Find a dice (technically it should be “die”, since “dice” is plural and
    you only need one) or find an app or website to simulate rolling a die. Get out
    a sheet of paper and something to write with. Draw a line down the middle of the
    paper and make two columns. Label the left column “roll” and the right column
    “total”. Put a `0`  in the total column and leave the other column blank at first.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 找到一个骰子（技术上应该是“骰子”，因为“骰子”是复数形式，而您只需要一个）或找到一个模拟掷骰子的应用程序或网站。拿出一张纸和一支笔。在纸张中间画一条线并制作两列。在左列上标注“掷骰”，在右列上标注“总数”。在总数列中放入`0`，并一开始将另一列留空。
- en: Then roll the die and write down the number you rolled at the top of the roll
    column. Put the number `(15)`  in parentheses next to the roll value, since the
    die roll occurs on line 15 in the code.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后掷骰子，并将您掷出的数字写在掷骰列的顶部。由于骰子掷出的行号是代码中的第15行，所以在掷骰值旁边用括号括起数字`(15)`。
- en: Then step through the code line by line just like the computer would. Compare
    the current value of roll with 1\. If they are equal, cross out the current value
    in the total column and put `0 (20)`  there, since total would become zero on
    line 20 of the code.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后逐行执行代码，就像计算机一样。将掷骰的当前值与1进行比较。如果它们相等，则划掉总数列中的当前值，并在那里放入`0 (20)`，因为总数将在代码的第20行变为零。
- en: Keep going until the program would end. Here’s an example of what my table would
    look like for the sample run of the program shown in the “What You Should See”
    section.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行，直到程序结束。以下是程序“预期输出”部分所示程序示例运行的表格样式示例。
- en: roll
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 掷骰
- en: total
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 总数
- en: 0 (11)
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 0 (11)
- en: 2 (15)
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 2 (15)
- en: 2 (24)
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 2 (24)
- en: 3 (15)
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 3 (15)
- en: 5 (24)
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 5 (24)
- en: 1 (15)
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 1 (15)
- en: 0 (20)
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 0 (20)
- en: 'Exercise 33: The Dice Game Called ‘Pig’'
  id: totrans-1373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习33：名为“Pig”的骰子游戏
- en: In the previous lesson we wrote the computer A.I. for the dice game *Pig*. (Remember
    that you can read the Wikipedia entry for Pig if you want a lot more information
    about this game.) In this lesson we will have the code for the entire game, with
    one human player and one computer player that take turns.
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一课中，我们为骰子游戏*Pig*编写了计算机A.I.（记住，如果你想要更多关于这个游戏的信息，你可以阅读维基百科关于Pig的条目。）在这一课中，我们将有整个游戏的代码，有一个人类玩家和一个计算机玩家轮流进行。
- en: The entire program you wrote last time corresponds roughly to lines 43 through
    67 in this program. The only major difference is that instead of a single *total*
    variable we will have a *turnTotal* variable to hold only the points for one turn
    and a *total2* variable that holds the computer’s overall points from round to
    round.
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 你上次写的整个程序大致对应于这个程序中的第43到67行。唯一的主要区别是，我们将有一个*turnTotal*变量来保存一个回合的点数，而*total2*变量则保存计算机从一轮到另一轮的总点数。
- en: 1 import java.util.Scanner; 2
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 1 import java.util.Scanner; 2
- en: 3 public class PigDice 4 {
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 3 public class PigDice 4 {
- en: 5 public static void main( String[] args ) 6 {
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 5 public static void main( String[] args ) 6 {
- en: 7 Scanner keyboard = new Scanner(System.in); 8
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 7 Scanner keyboard = new Scanner(System.in); 8
- en: int roll, total1, total2, turnTotal;
  id: totrans-1380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: int roll, total1, total2, turnTotal;
- en: String choice = ""; 11
  id: totrans-1381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: String choice = ""; 11
- en: total1 = 0;
  id: totrans-1382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: total1 = 0;
- en: total2 = 0; 14
  id: totrans-1383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: total2 = 0; 14
- en: 15 do
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 15 do
- en: 16 {
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 16 {
- en: turnTotal = 0;
  id: totrans-1386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal = 0;
- en: System.out.println( "You have " + total1 + " points." ); 19
  id: totrans-1387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "你有 " + total1 + " 点。" ); 19
- en: 20 do
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 20 do
- en: 21 {
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: 21 {
- en: roll = 1 + (int)(Math.random()*6);
  id: totrans-1390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: roll = 1 + (int)(Math.random()*6);
- en: System.out.println( "\tYou rolled a " + roll + "." );
  id: totrans-1391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t你掷出了 " + roll + "。" );
- en: if ( roll == 1 )
  id: totrans-1392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if ( roll == 1 )
- en: 25 {
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 25 {
- en: System.out.println( "\tThat ends your turn." );
  id: totrans-1394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t这结束了你的回合。" );
- en: turnTotal = 0;
  id: totrans-1395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal = 0;
- en: 28 }
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 28 }
- en: 29 else
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 29 else
- en: 30 {
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 30 {
- en: turnTotal += roll;
  id: totrans-1399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal += roll;
- en: System.out.println( "\tYou have " + turnTotal + " points so far this round."
    );
  id: totrans-1400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t你这一轮到目前为止有 " + turnTotal + " 点。" );
- en: System.out.print( "\tWould you like to \"roll\" again or \"hold\"? " );
  id: totrans-1401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.print( "\t你想再“roll”一次还是“hold”？ " );
- en: choice = keyboard.next(); 35 }
  id: totrans-1402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: choice = keyboard.next(); 35 }
- en: 36 } while ( roll != 1 && choice.equals("roll") ); 37
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 36 } while ( roll != 1 && choice.equals("roll") ); 37
- en: total1 += turnTotal;
  id: totrans-1404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: total1 += turnTotal;
- en: System.out.println( "\tYou end the round with " + total1 + " points." ); 40
  id: totrans-1405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t你以 " + total1 + " 点结束这一轮。" ); 40
- en: 41 if ( total1 < 100 )
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 41 if ( total1 < 100 )
- en: 42 {
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 42 {
- en: turnTotal = 0;
  id: totrans-1408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal = 0;
- en: System.out.println( "Computer has " + total2 + " points." ); 45
  id: totrans-1409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "计算机有 " + total2 + " 点。" ); 45
- en: 46 do
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 46 do
- en: 47 {
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 47 {
- en: roll = 1 + (int)(Math.random()*6);
  id: totrans-1412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: roll = 1 + (int)(Math.random()*6);
- en: System.out.println( "\tComputer rolled a " + roll + "." );
  id: totrans-1413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t计算机掷出了 " + roll + "。" );
- en: if ( roll == 1 )
  id: totrans-1414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if ( roll == 1 )
- en: 51 {
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 51 {
- en: System.out.println( "\tThat ends its turn." );
  id: totrans-1416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t这结束了它的回合。" );
- en: turnTotal = 0;
  id: totrans-1417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal = 0;
- en: 54 }
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 54 }
- en: 55 else
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 55 else
- en: 56 {
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 56 {
- en: turnTotal += roll;
  id: totrans-1421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: turnTotal += roll;
- en: System.out.println( "\tComputer has " + turnTotal + " points so far this round."
    );
  id: totrans-1422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println( "\t计算机到目前为止这一轮有 " + turnTotal + " 点。" );
- en: if ( turnTotal < 20 )
  id: totrans-1423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: if ( turnTotal < 20 )
- en: 60 {
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 60 {
- en: 61 System.out.println( "\tComputer chooses to roll again." ); 62 }
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 61 System.out.println( "\t计算机选择再次掷骰子。" ); 62 }
- en: 63 }
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 63 }
- en: '64'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '64'
- en: '65'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '65'
- en: '66'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: '66'
- en: '67'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '67'
- en: '68'
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: '68'
- en: '69'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '69'
- en: '70'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: '70'
- en: '71'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '71'
- en: '72'
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: '72'
- en: '73'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '73'
- en: '74'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '74'
- en: '75'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: '75'
- en: '76'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '76'
- en: '77'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '77'
- en: '78'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: '78'
- en: '79'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '79'
- en: '80'
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: '80'
- en: '81'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '81'
- en: 82 }
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 82 }
- en: '} while ( roll != 1 && turnTotal < 20 );'
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: '} while ( roll != 1 && turnTotal < 20 );'
- en: total2 += turnTotal;
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: total2 += turnTotal;
- en: System.out.println( "\tComputer ends the round with " + total2 + " points."
    );
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println( "\t计算机以 " + total2 + " 点结束这一轮。" );
- en: '}'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '} while ( total1 < 100 && total2 < 100 );'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '} while ( total1 < 100 && total2 < 100 );'
- en: if ( total1 > total2 )
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: if ( total1 > total2 )
- en: '{'
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "Humanity wins!" );
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println( "人类获胜！" );
- en: '}'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: '{'
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "The computer wins." );
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println( "计算机获胜。" );
- en: '}'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: What You Should See
  id: totrans-1460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE270]'
  id: totrans-1461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'We begin the program with two variables: *total1* holds the human’s total and
    *total2* holds the computer’s total. Both start at 0.'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从两个变量开始程序：*total1*保存人类的总点数，*total2*保存计算机的总点数。两者都从0开始。
- en: Then on line 15 begins a really huge do­while loop that basically contains the
    whole game and doesn’t end until line 70\. Scroll down and you can see that this
    loop repeats as long as both *total1* and *total2* are less than 100\. When either
    player reaches 100 or more, the condition is no longer true and the do­while won’t
    repeat back up again.
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第15行开始一个非常庞大的do-while循环，基本上包含了整个游戏，直到第70行才结束。向下滚动，你会看到这个循环会重复，只要*total1*和*total2*都小于100。当任一玩家达到100或更多时，条件不再成立，do-while循环不会再重复。
- en: Then after that do­while loop ends (starting on line 72) there is an `if`  statement
    and an `else`  to determine the winner.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在那个do-while循环结束之后（从第72行开始），有一个`if`语句和一个`else`来确定赢家。
- en: Let us scroll back up and look at the human’s turn, which begins on line 17\.
    The *turnTotal* is the number of points the human has earned this round so far.
    And since it’s the beginning of the round, we should start it out at 0.
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们往上滚动一下，看看人类的回合，从第17行开始。*turnTotal*是人类到目前为止在这一轮中赚得的点数。由于这是一轮的开始，我们应该从0开始。
- en: Line 20 is the beginning of a do­while loop that contains the human’s turn.
    It ends on line 36, and all the code between lines 20 and 36 will repeat as long
    as the human does not roll a 1 and as long as the human keeps choosing to roll
    again.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 第20行是一个包含人类回合的do-while循环的开始。它在第36行结束，所有在第20行和第36行之间的代码都会重复，只要人类没有掷出1，只要人类继续选择再次掷骰子。
- en: 'Each roll for the human begins just like the computer did: by choosing a random
    number from 1 to 6\. We print this out on line 22.'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的每次掷骰子都和计算机一样开始：选择一个从1到6的随机数。我们在第22行打印出来。
- en: 'Now two things could happen: either the roll is 1 – and the human loses all
    points earned this round – or the roll is 2­6 and the roll is added to their *turnTotal*.
    We display the appropriate messages, and on lines 33 and 34 we give the human
    the choice to chance it by rolling again or play it safe by holding. Then on line
    36 the condition of the do­while loop will check and repeat back up to line 20
    if appropriate.'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能发生两件事：要么掷骰子是1——人类失去本轮获得的所有分数——要么掷骰子是2-6，然后将掷骰子的点数加到他们的*turnTotal*上。我们显示适当的消息，在第33和34行，我们给人类选择再次掷骰的机会，或者通过保持来安全地玩。然后在第36行，do-while循环的条件将检查并在适当的情况下重复回到第20行。
- en: Once the player’s turn ends, we add the *turnTotal* (which might be 0) to the
    player’s overall total and display their current number of points.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家的回合结束，我们将*turnTotal*（可能为0）加到玩家的总分上，并显示他们当前的分数。
- en: 'On line 41 the computer’s turn begins. However, the computer doesn’t get a
    turn if the human has already reached 100 points: the game is over in that case.
    So to prevent the computer from playing we must wrap the whole computer’s turn
    in a big `if`  statement so that it is skipped if the human’s total (total1) is
    greater than or equal to 100\. This `if`  statement begins here on line 41 and
    ends on line 68.'
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 在第41行，计算机的回合开始了。然而，如果人类已经达到了100分，计算机就不会轮到了：在这种情况下游戏结束。因此，为了防止计算机玩游戏，我们必须将整个计算机的回合包装在一个大的`if`语句中，以便在人类的总分（total1）大于或等于100时跳过。这个`if`语句从第41行开始，到第68行结束。
- en: So on line 43 the computer’s turn begins for real. This is basically the same
    as the previous exercise, so I won’t bother to explain it again. Notice that the
    computer is deciding whether or not to roll again based on its turn total.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在第43行，计算机的回合真正开始了。这基本上与上一个练习相同，所以我不会再解释一遍。请注意，计算机正在根据其回合总数决定是否继续掷骰子。
- en: Line 70 ends the do­while loop containing the whole game, and lines 72 through
    79 determine and display the winner.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 第70行结束了包含整个游戏的do-while循环，第72到79行确定并显示赢家。
- en: Hopefully you were able to follow the flow of the game well enough. It’s pretty
    complicated.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能够很好地跟上游戏的流程。这相当复杂。
- en: I would also point out how *important* it is for a program like this that every
    time you put an open brace, you indent everything inside the following block one
    more level. It will save you a lot of grief if you can just scan your eyes visually
    down from the open curly brace on line 47 to the matching close curly brace on
    line 64 to see what is inside that do­while loop and what isn’t.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要指出，对于这样一个程序来说，每次你放一个左大括号，将其后的所有内容缩进一级是*非常重要*的。如果你可以从第47行的左大括号直观地扫描你的眼睛到第64行的右大括号，看看do-while循环中有什么，没有什么，这将为你节省很多烦恼。
- en: 'Exercise 34: Calling a Function'
  id: totrans-1476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习34：调用一个函数
- en: '[The previous exercise was pretty complicated. So we will relax a bit with
    today’s exercise. We are going to learn how to write a “function”](#bookmark116)[10](#bookmark116)
    in Java and how to make it execute by “calling” it.'
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: '[上一个练习相当复杂。所以我们今天的练习会放松一下。我们将学习如何在Java中编写“函数”，以及如何通过“调用”来执行它。](#bookmark116)[10](#bookmark116)'
- en: '[PRE272]'
  id: totrans-1478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: What You Should See
  id: totrans-1479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE273]'
  id: totrans-1480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: So lines 5 through 9 are pretty boring, except that on lines 6 and 8 we are
    referring to some thing called “erebor” that you haven’t seen before in Java.
    Do you know why you haven’t seen it? Because it doesn’t exist!
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第5到9行相当无聊，除了在第6和第8行我们提到了一些叫做“erebor”的东西，你在Java中以前没有见过。你知道为什么你没有见过它吗？因为它根本不存在！
- en: Skipping down to lines 12 through 15 you will notice that I added something
    to our program that is not inside the body of `main()`. Normally the close curly
    brace of `public static void main`  is almost at the end of the code, and the
    only thing after it is the close curly brace of `public class` `Whatevs`. But
    not this time!
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 跳到第12到15行，你会注意到我在我们的程序中添加了一些不在`main()`主体内的东西。通常情况下，`public static void main`的右大括号几乎在代码的末尾，而它之后的唯一内容就是`public
    class` `Whatevs`的右大括号。但这次不是！
- en: Lines 12 through 15 define a function named `erebor()`. (The word `erebor()`  doesn’t
    mean anything in particular to Java. We could have named it `bilbo()`  or `smaug()`  or
    anything we like.)
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 第12到15行定义了一个名为`erebor()`的函数。（`erebor()`这个词在Java中没有特别的含义。我们可以将其命名为`bilbo()`或`smaug()`或者任何我们喜欢的名字。）
- en: This function has an open curly brace on line 13 just like `main()`  always
    has an open curly brace. And on line 15 is the end of the function’s body, and
    there’s a close curly brace. So the function definition starts on line 12 and
    ends on line 15.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在第13行有一个左大括号，就像`main()`总是有一个左大括号一样。在第15行是函数主体的结束，有一个右大括号。所以函数定义从第12行开始，到第15行结束。
- en: What does the function do? It prints the String `"There."`  on the screen.
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是做什么的？它在屏幕上打印字符串`"There."`。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_041.png)'
  id: totrans-1486
  prefs: []
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_041.png)'
- en: 10 This is one of the things where I’m full of lies. Technically, Java doesn’t
    even *have* functions. It only has “methods” and this is a method, not a function.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 10 这是我充满谎言的事情之一。从技术上讲，Java甚至没有*函数*。它只有“方法”，这是一个方法，而不是函数。
- en: But this is *only* a method because that is all Java has. In any other programming
    language, what we have written here would be called a function and not a method.
    This is because methods are an object­oriented thing and this program is not even
    remotely object­oriented.
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是一个方法，因为这就是Java所拥有的。在任何其他编程语言中，我们写的内容都会被称为函数而不是方法。这是因为方法是面向对象的东西，而这个程序根本不是面向对象的。
- en: So even though it’s technically incorrect, I am going to refer to this sort
    of thing as a *function* and only use the word *method*
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管从技术上讲是不正确的，我将这种事情称为*函数*，并且只使用*方法*这个词。
- en: when I make something that actually behaves like a method.
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 当我做出的东西实际上像一个方法时。
- en: My intentionally wrong vocabulary will only cause problems if you are talking
    to a pedantic Java programmer because they might make fun of you. If that happens,
    show them this footnote and ask them how many years they have been teaching beginners
    to code. I promise that doing it this way is better than trying to show you real
    methods from the beginning or doing this now and trying to distinguish between
    “methods that act like functions” and “methods that behave like real methods.”
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 我的故意错误的词汇只会在你与一个迂腐的Java程序员交谈时引起问题，因为他们可能会取笑你。如果发生这种情况，给他们看这个脚注，并问问他们教初学者编程多少年了。我保证这样做比从一开始就向你展示真正的方法，或者现在就这样做并尝试区分“像函数一样运行的方法”和“行为像真正方法的方法”要好。
- en: So now let’s go back up to `main()`  and look at the function calls inside the
    body of `main()`.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 那么现在让我们回到`main()`，看看`main()`体内的函数调用。
- en: On line 5 we print the String `"Here."`  on the screen. Then on line 6 you will
    see a “function call.” This line of code tells the computer to jump down to the
    function `erebor()`, run through all the code in the body of that function, and
    to return to line 6 once that has been accomplished.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行我们在屏幕上打印字符串"Here."。然后第6行你会看到一个“函数调用”。这行代码告诉计算机跳到函数`erebor()`，运行该函数主体中的所有代码，然后在完成后返回到第6行。
- en: So you see that when we call the `erebor()`  function, the String `"There."`  gets
    printed on the screen right after the String `"Here."`. When the computer runs
    line 6, execution of the program pauses in `main()`, skips over all the rest of
    the code in `main()`, jumps down to line 12, runs all the code in the body of
    the function `erebor()`  (all 1 line of it) and then once execution hits the close
    curly brace on line 15, it returns back up to the end of line 6 and unpauses the
    execution in `main()`. It runs line 7 next.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你看到当我们调用`erebor()`函数时，字符串"There."会在字符串"Here."之后打印在屏幕上。当计算机运行第6行时，程序的执行在`main()`中暂停，跳过`main()`中的所有其余代码，跳到第12行，运行`erebor()`函数主体中的所有代码（只有1行），然后一旦执行到第15行的右花括号，它返回到第6行的末尾，恢复`main()`的执行。接着运行第7行。
- en: On line 7 is displays another message on the screen, then on line 8 there is
    another function call. The function erebor is called a second time. It pauses
    `main()`  on line 8, jumps down and runs through the body of erebor (which prints
    the String `"There."`  again), then returns back up to line 8 where execution
    of `main()`  resumes.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 第7行显示屏上显示另一条消息，然后第8行有另一个函数调用。函数erebor被第二次调用。它在第8行暂停了`main()`，跳下去运行erebor的主体（再次打印字符串"There."），然后返回到第8行，`main()`的执行继续。
- en: Finally line 9 prints one last String on the screen. Execution then proceeds
    to the close curly brace of
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 最后第9行在屏幕上打印最后一个字符串。然后执行继续到
- en: '`main()`  which is on line 10\. When `main()`  ends, the program ends.'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`在第10行。当`main()`结束时，程序也结束。'
- en: 'That’s pretty important, so I will say it again: when `main()`  ends, the program
    ends. Even if you have a bunch of different functions inside the `class`, program
    execution begins with the first line of `main()`. And once the last line of `main()`  has
    been executed, the program stops running even if there are functions that never
    got called. (We will see an example of this in the next exercise.)'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，所以我会再说一遍：当`main()`结束时，程序也结束。即使在`class`内有很多不同的函数，程序执行也是从`main()`的第一行开始的。一旦`main()`的最后一行被执行，程序就停止运行，即使有一些从未被调用的函数。（我们将在下一个练习中看到一个例子。）
- en: Study Drills
  id: totrans-1499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: 'Remove the parentheses at the end of the first function call on line 6 so that
    it looks like so:'
  id: totrans-1500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除第6行第一个函数调用末尾的括号，使其看起来像这样：
- en: '[PRE274]'
  id: totrans-1501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: What happens when you compile? (Then put the parentheses back.)
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后会发生什么？（然后把括号放回去。）
- en: '1\. Remove the second function call (the one on line 8). You can either just
    delete the line entirely or put slashes in front of it so the compiler thinks
    it’s a comment like so:'
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 删除第二个函数调用（第8行）。你可以直接删除整行，或者在行前加上斜杠，这样编译器会认为它是注释，就像这样：
- en: '[PRE275]'
  id: totrans-1504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Compile it, but before you run it, how do you think the output will be different?
    Run it and see if you were right.
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 编译它，但在运行之前，你认为输出会有什么不同？运行它，看看你是否正确。
- en: 'Exercise 35: Calling Functions to Draw a Flag'
  id: totrans-1506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习35：调用函数绘制旗帜
- en: Now that you understand the absolute basics about how to define a function and
    how to call that function, let us get some practice by defining *eleven* functions!
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何定义函数和调用函数的绝对基础知识，让我们通过定义*十一个*函数来进行一些练习！
- en: There are no zeros (`0`) in this program. Everything that looks like an `O`  is
    a capital letter O. Also notice that lines 45 and 50 feature `print()`  instead
    of `println()`.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序中没有零（`0`）。所有看起来像`O`的东西都是大写字母O。还要注意，第45行和第50行使用的是`print()`而不是`println()`。
- en: '[PRE276]'
  id: totrans-1509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-1510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-1511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-1512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-1514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-1515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: What You Should See
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: This exercise is ridiculous. There is no good reason that any self­respecting
    programmer would ever write the code to draw a flag on the screen like this. It
    is okay if writing this program felt a little silly. But functions are important
    and I prefer to start with silly examples that you can actually understand instead
    of realistic examples that are too hard to follow.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习很荒谬。没有任何值得尊重的程序员会以这种方式在屏幕上绘制旗帜。如果编写这个程序感觉有点傻，那没关系。但是函数很重要，我更喜欢从你实际能理解的愚蠢例子开始，而不是从太难跟随的现实例子开始。
- en: 'So how do we even trace through the execution of a program like this? We start
    at the beginning: the first line of `main()`. On line 7 the first thing main does
    is call the function `printTopHalf()`. So main gets put on pause and execution
    jumps down to the first line of the `printTopHalf()`  function, which is on line
    66.'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何追踪执行这样的程序呢？我们从开始开始：`main()`的第一行。在第7行，main做的第一件事是调用函数`printTopHalf()`。所以main被暂停，执行跳到`printTopHalf()`函数的第一行，即第66行。
- en: The first thing that printTopHalf does is print a bunch of underscores on the
    screen, which we will be the top of our flag. After that execution moves on to
    line 67, which is another function call! So `main()`  is still on pause from before,
    waiting for `printTopHalf()`  to finish, and now `printTopHalf()`  itself is on
    pause, waiting for `printSixStarLine()`  to finish and return control to here.
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '`printTopHalf` 的第一件事是在屏幕上打印一堆下划线，这将是我们旗帜的顶部。之后，执行移动到第67行，这是另一个函数调用！所以`main()`  仍然在暂停之前，等待`printTopHalf()`  完成，现在`printTopHalf()`  本身也在暂停，等待`printSixStarLine()`  完成并返回控制权到这里。'
- en: '`printSixStarLine()`  begins on line 54, where it calls the `print6Stars()`  function.
    That function (thankfully) only displays something on the screen so when the close
    curly brace of `print6Stars()`  comes on line 45, it returns control back to the
    second line (line 55) of `printSixStarLine()`, which then has another function
    call. This runs through the body of the function `print29Ohs()`  and comes back
    to line 56\. So then `printSixStarLine()`  ends, which returns control to the
    end of line 67.'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '`printSixStarLine()` 从第54行开始，它调用`print6Stars()`  函数。那个函数（幸运的是）只在屏幕上显示一些东西，所以当`print6Stars()`  的右大括号出现在第45行时，它将控制权返回到`printSixStarLine()`  的第二行（第55行），然后又有一个函数调用。这通过`print29Ohs()`  函数的主体运行，并返回到第56行。然后`printSixStarLine()`  结束，将控制权返回到第67行的末尾。'
- en: At this point, I think explaining all the function calls will be more confusing
    than just following the execution path on your own, so here I will just print
    all the line numbers that execute, in order. Calling a function will increase
    the indentation level and returning from that function will reduce the indentation
    level.
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我认为解释所有的函数调用会比跟随执行路径更加混乱，所以在这里我将按顺序打印所有执行的行号。调用一个函数会增加缩进级别，从该函数返回会减少缩进级别。
- en: '[PRE283]'
  id: totrans-1522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-1523
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-1524
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-1526
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-1527
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-1528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-1529
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-1530
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-1531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-1532
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-1533
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-1534
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-1535
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-1536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-1537
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-1538
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-1539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-1540
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-1541
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-1542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-1543
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-1544
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-1546
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-1547
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-1548
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-1549
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-1550
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-1551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-1552
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-1553
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-1554
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-1555
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-1556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-1557
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-1558
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-1559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-1560
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-1561
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-1563
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-1564
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-1565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-1566
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-1567
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-1569
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-1570
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-1571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-1572
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-1573
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-1575
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-1576
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-1577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-1578
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-1579
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-1580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-1581
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-1582
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-1583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: Holy cow! If you can successfully trace through that, then you are well on your
    way to becoming a competent programmer.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 天哪！如果你能成功地追踪到这一点，那么你就已经在成为一个称职的程序员的路上了。
- en: Study Drills
  id: totrans-1585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: You didn’t actually trace all the way through the program, did you? Well, go
    back and do it. This book isn’t called “Learn Java the Halfway” is it? Print out
    the code, grab a pencil, and draw lines whenever a function calls somewhere else
    and draw a line back when the function returns. When you are done it should look
    a bit like a plate of graphite spaghetti!
  id: totrans-1586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你真的没有完全追踪整个程序，是吗？好吧，回去做吧。这本书不叫“学习Java的一半”，对吧？打印出代码，拿起一支铅笔，在一个函数调用其他地方时画一条线，当函数返回时画一条线。完成后，它应该看起来有点像一盘石墨意面！
- en: On lines 32 through 35 you find a definition for a function named `printPledge()`.
    But yet the output of this function never shows up. Why not? At the end of `main()`  add
    a function call to run this function so that it shows up underneath the flag.
  id: totrans-1587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在32到35行，你会找到一个名为`printPledge()`  的函数的定义。但是这个函数的输出从来没有出现过。为什么？在`main()`  的末尾添加一个函数调用来运行这个函数，以便它出现在旗帜下面。
- en: (Despite the evilness of this program, I am pretty proud of that flag. If you
    use a ruler to measure the dimensions of everything you will find that my flag
    is about as close as I think you can make it to the dimensions of a real United
    States flag. I actually spent quite a while measuring and adjusting everything.)
  id: totrans-1588
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （尽管这个程序很邪恶，但我对那面旗帜感到非常自豪。如果你用尺子测量一切的尺寸，你会发现我的旗帜与真正的美国国旗的尺寸几乎一样。我实际上花了很长时间测量和调整一切。）
- en: 'Exercise 36: Displaying Dice with Functions'
  id: totrans-1589
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习36：使用函数显示骰子
- en: The last exercise used functions in a program where functions actually made
    things *worse*. So today we are ready to look at a situation where using a function
    actually makes the program better.
  id: totrans-1590
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上一个练习在一个函数实际上使事情变得更糟的程序中使用了函数。所以今天我们准备看一个情况，使用函数实际上使程序变得更好。
- en: Yacht is an old dice game that was modified for the commercial game Yahtzee.
    It involves rolling five dice at once and earning points for various combinations.
    The rarest combination is “The Yacht”, when all five dice show the same number.
  id: totrans-1591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Yacht是一个古老的骰子游戏，后来被修改为商业游戏Yahtzee。它涉及一次掷五个骰子，并为各种组合赚取积分。最罕见的组合是“游艇”，当五个骰子都显示相同的数字时。
- en: This program doesn’t do any other scoring, it just rolls five dice until they
    are all the same. (Computers go fast, so even if this takes a lot of tries it
    doesn’t take very long.)
  id: totrans-1592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个程序不做任何其他的评分，它只是掷五个骰子，直到它们都相同。（计算机速度很快，所以即使这需要很多次尝试，也不会花费很长时间。）
- en: '[PRE345]'
  id: totrans-1593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-1594
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-1595
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-1596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-1597
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-1598
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-1599
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-1600
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-1601
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-1602
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-1603
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-1604
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-1605
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-1606
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-1607
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-1608
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-1609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-1610
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-1611
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-1613
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-1614
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-1615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-1616
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-1617
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-1618
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-1620
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE372]'
- en: '[PRE373]'
  id: totrans-1621
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-1622
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-1624
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-1625
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-1626
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-1627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: What You Should See
  id: totrans-1628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE380]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: Other than the fancy Boolean expression on line 21, the interesting thing in
    this exercise is a single function called `showDice`.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第21行的花哨的布尔表达式之外，这个练习中有一个名为`showDice`  的单个函数。
- en: On lines 10 through 14 we choose five random numbers (each from 1 to 6) and
    store the results into the five integer variables *roll1* through *roll5*.
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 在10到14行，我们选择五个随机数（每个数从1到6）并将结果存储到五个整数变量*roll1*到*roll5*中。
- en: We want to use some `if`  statements to display a picture of the die’s value
    on the screen, but we don’t want to have to write the same `if`  statements five
    times (which we would have to do because the variables are different). The solution
    is to create a function that takes a parameter.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用一些`if` 语句在屏幕上显示骰子的值，但我们不想写五次相同的`if` 语句（因为变量是不同的）。解决方案是创建一个带参数的函数。
- en: On line 27 you see the beginning of the definition of the `showDice`  function.
    After the name (or “identifier”) `showDice`  there is a set of parentheses and
    between them a variable is declared! This variable is called a “parameter”. The
    `showDice`  function has one parameter. That parameter is an integer. It is named
    roll.
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: 在第27行，你看到了`showDice`  函数定义的开始。在名称（或“标识符”）`showDice`  后面，有一组括号，在它们之间声明了一个变量！这个变量叫做“参数”。`showDice`  函数有一个参数。这个参数是一个整数。它的名字叫roll。
- en: This means that whenever you write a function call for `showDice`  you can not
    just write the name of the function with parentheses like `showDice()`. It won’t
    compile. You must include an integer value in the parentheses (this is called
    an “argument”), either a variable or an expression that simplifies to an integer
    value.
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当你为`showDice`写一个函数调用时，你不能只写函数的名称和括号，比如`showDice()`。它不会编译。你必须在括号中包含一个整数值（这称为“参数”），要么是一个变量，要么是一个简化为整数值的表达式。
- en: Here are some examples.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些例子。
- en: showDice;
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: showDice;
- en: //
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (without parens this refers to a variable not a function call)
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (没有括号，这指的是变量而不是函数调用)
- en: showDice();
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: showDice();
- en: //
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (function call must have one argument, not zero)
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (函数调用必须有一个参数，而不是零)
- en: showDice(1);
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(1);
- en: //
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: YES (one argument is just right)
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 是的（一个参数刚刚好）
- en: showDice(4);
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(4);
- en: //
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'YES'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: showDice(1+2);
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(1+2);
- en: //
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'YES'
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: showDice(roll2);
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(roll2);
- en: //
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'YES'
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: showDice(roll5);
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(roll5);
- en: //
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: 'YES'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: showDice( (roll3+roll4) / 2
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: showDice( (roll3+roll4) / 2
- en: );
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: //
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: YES (strange but legal)
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 是的（奇怪但合法）
- en: showDice(17);
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(17);
- en: //
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: YES (although it won't show a proper dice picture)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 是的（尽管它不会显示一个合适的骰子图片）
- en: showDice(3, 4);
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(3, 4);
- en: //
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (function call must have one argument, not two)
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (函数调用必须有一个参数，而不是两个)
- en: showDice(2.0);
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(2.0);
- en: //
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (argument must be an integer, not a double)
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (参数必须是整数，而不是双精度)
- en: showDice("two");
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
  zh: showDice("two");
- en: //
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (argument must be an integer, not a String)
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (参数必须是整数，而不是字符串)
- en: showDice(false);
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: showDice(false);
- en: //
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
  zh: //
- en: NO (argument must be an integer, not a Boolean)
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: 不 (参数必须是整数，而不是布尔值)
- en: In all cases, a copy of the argument’s value is stored into the parameter. So
    if you call the function like so `showDice(3);`  then the function is called and
    the value `3`  is stored into the parameter roll. So by line 29 the parameter
    variable roll has already been declared and initialized with the value `3`.
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，参数的值的副本都存储在参数中。因此，如果你这样调用函数 `showDice(3);`，那么函数被调用，值`3`被存储到参数roll中。所以到第29行，参数变量roll已经被声明并初始化为值`3`。
- en: If we call the function using a variable like `showDice(roll2);`  then the function
    is called and a copy of whatever value is currently in roll2 will have been stored
    into the parameter variable roll before the body of the function is executed.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用变量调用函数，比如 `showDice(roll2);` 那么在函数体执行之前，函数被调用并且当前在roll2中的任何值的副本将被存储到参数变量roll中。
- en: So on line 16 the `showDice`  function is executed, and roll will have been
    set equal to whatever value is in roll1.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第16行，`showDice`函数被执行，roll将被设置为roll1中的任何值。
- en: Then on line 17 `showDice`  is called again, but this time roll will be set
    equal to whatever value is in
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第17行，`showDice`再次被调用，但这次roll将被设置为roll1中的任何值。
- en: roll2. Line 18 calls `showDice`  while setting its parameter equal to the value
    of roll3. And so on.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: roll2。第18行调用`showDice`，同时将其参数设置为roll3的值。等等。
- en: In this way we basically run the same chunk of code five times, but substituting
    a different variable for
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们基本上运行了相同的代码块五次，但用不同的变量替换
- en: roll each time. This saves us a lot of code.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 每次掷骰子。这为我们节省了很多代码。
- en: 'For comparison, I also wrote a simplified two­dice version of this exercise
    without using functions. Notice how I had to repeat the exact same sequence of
    `if`  statements twice: once for each variable.'
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比，我还写了一个简化的两个骰子版本的练习，而不使用函数。请注意，我必须重复完全相同的`if`语句序列两次：每个变量一次。
- en: Also notice that although defining a function is a little bit more work than
    just copying­and­pasting the
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，虽然定义函数比只是复制和粘贴要多一点工作
- en: '[PRE381]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-1686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[PRE383]'
  id: totrans-1687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-1688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-1689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-1690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-1692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '`if`  statements and changing the variable, the two­dice version is longer
    than the five­dice version.'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句并更改变量，两个骰子版本比五个骰子版本更长。'
- en: '[PRE389]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-1695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-1696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: What You Should See
  id: totrans-1697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE392]'
  id: totrans-1698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Study Drills
  id: totrans-1699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习技巧
- en: 1\. Add a sixth dice. Notice how easy it is to display *roll6* by just adding
    a single function call.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 添加第六个骰子。注意，只需添加一个函数调用就可以轻松显示*roll6*。
- en: 'Exercise 37: Returning a Value from a Function'
  id: totrans-1701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习37：从函数返回一个值
- en: 'Some functions have parameters and some do not. Parameters are the only way
    to send values *into* a function. There is also only one way to get a value *out*
    of a function: the return value.'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 有些函数有参数，有些没有。参数是将值*传递*到函数的唯一方法。也只有一种方法可以从函数中得到一个值：返回值。
- en: 1 public class HeronsFormula 2 {
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 1 public class HeronsFormula 2 {
- en: '3'
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: '14'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: public static void main( String[] args )
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main( String[] args )
- en: '{'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: double a;
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: double a;
- en: a = triangleArea(3, 3, 3);
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: a = triangleArea(3, 3, 3);
- en: System.out.println("A triangle with sides 3,3,3 has an area of " + a );
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为3,3,3的三角形的面积为" + a );
- en: a = triangleArea(3, 4, 5);
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: a = triangleArea(3, 4, 5);
- en: System.out.println("A triangle with sides 3,4,5 has an area of " + a );
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为3,4,5的三角形的面积为" + a );
- en: a = triangleArea(7, 8, 9);
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: a = triangleArea(7, 8, 9);
- en: System.out.println("A triangle with sides 7,8,9 has an area of " + a );
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为7,8,9的三角形的面积为" + a );
- en: System.out.println("A triangle with sides 5,12,13 has an area of " + triangleArea(5,
    12, 13) );
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为5,12,13的三角形的面积为" + triangleArea(5, 12, 13) );
- en: System.out.println("A triangle with sides 10,9,11 has an area of " + triangleArea(10,
    9, 11) );
  id: totrans-1728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为10,9,11的三角形的面积为" + triangleArea(10, 9, 11) );
- en: System.out.println("A triangle with sides 8,15,17 has an area of " + triangleArea(8,
    15, 17) );
  id: totrans-1729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println("一个边长为8,15,17的三角形的面积为" + triangleArea(8, 15, 17) );
- en: '19'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: '22'
- en: '}'
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static double triangleArea( int a, int b, int c )
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: public static double triangleArea( int a, int b, int c )
- en: '{'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: 23 // the code in this function computes the area of a triangle whose sides
    have lengths a, b, and c
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 23 // 此函数中的代码计算具有长度a、b和c的三角形的面积
- en: '24'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '24'
- en: '25'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: '26'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: '27'
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: '28'
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '29'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: '30'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: '31'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: 32 }
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 32 }
- en: double s, A;
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: double s, A;
- en: s = (a+b+c) / 2;
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: s = (a+b+c) / 2;
- en: A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: A = Math.sqrt( s*(s­a)*(s­b)*(s­c) );
- en: return A;
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 返回A;
- en: // ^ after computing the area, "return" it
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: // ^ 计算面积后，“返回”它
- en: '}'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'This exercise gives an example of a function that has three parameters (the
    side lengths of a triangle) and one output: the area of that triangle using Heron’s
    Formula.'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习给出了一个具有三个参数（三角形的边长）和一个输出（使用海伦公式计算三角形的面积）的函数的例子。
- en: What You Should See
  id: totrans-1754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE393]'
  id: totrans-1755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: You can see that the function `triangleArea`  has three parameters. They are
    all integers, and they are named a, b and c. As you already know, this means that
    we cannot call the function without providing three integer values as arguments.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到函数`triangleArea`有三个参数。它们都是整数，它们的名字分别是a、b和c。正如你已经知道的，这意味着我们不能在不提供三个整数值作为参数的情况下调用函数。
- en: In addition to this, the `triangleArea`  function returns a value. Notice that
    on line 21 that it doesn’t say `void`  between `public static`  and `triangleArea`.
    It says `double`. That means “this function returns a value, and the type of value
    it returns is a `double`.”
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`triangleArea`函数返回一个值。请注意，在第21行，它没有在`public static`和`triangleArea`之间说`void`。它说`double`。这意味着“这个函数返回一个值，它返回的值的类型是`double`。”
- en: 'If instead it had the keyword `void`  in this position, it means “this function
    does not return any value.” If we wanted `triangleArea`  to return a different
    type of value:'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在这个位置上有关键字`void`，这意味着“这个函数不返回任何值。” 如果我们想让`triangleArea`返回不同类型的值：
- en: '[PRE394]'
  id: totrans-1759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-1761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: Sometimes my students get confused about functions that return values versus
    functions that do not return values. An analogy is helpful.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我的学生会对返回值和不返回值的函数感到困惑。类比是有帮助的。
- en: Let us say that we are sitting in my school classroom. We hear the sound of
    thunder and I remember that I left my car windows down. I don’t want rain to make
    the inside of my car wet, so I send you out into the parking lot.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们坐在我的学校教室里。我们听到雷声，我记得我把车窗开着。我不想让雨水把车里弄湿，所以我让你出去停车场。
- en: “Student, please go out into the parking lot and roll up the windows of my car.”
    “Yes, sir,” you say.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: “学生，请出去停车场，把我的车窗摇上。” “好的，先生，”你说。
- en: If you need information from me about what my car looks like, then those are
    parameters. If you already know which one is mine, you need no parameters.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要我关于我的车是什么样子的信息，那么这些就是参数。如果你已经知道哪辆是我的，你就不需要参数。
- en: Eventually you return and say “I completed the task.” This sort of function
    does not return a value.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你返回并说“我完成了任务。”这种类型的函数不返回值。
- en: '[PRE397]'
  id: totrans-1767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: 'In either case, the function is executed and goes off and does its thing, but
    returns no value. Now, example #2:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，函数都会被执行并完成其任务，但不返回任何值。现在，例子#2：
- en: Again we are in my classroom. I am online trying to update my car insurance
    and the web page is asking me for my car’s license plate number. I don’t remember
    it, so I ask you to go to the parking lot and get it for me.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次在我的教室里。我正在网上更新我的汽车保险，网页要求我输入我的车牌号。我不记得了，所以我让你去停车场帮我拿。
- en: Eventually you return and *tell me the license plate number*. Maybe you wrote
    it down on a scrap of paper or maybe you memorized it. When you give it to me,
    I copy it down myself. This sort of function returns a value.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 最终你返回并*告诉我车牌号*。也许你把它写在一张纸上，也许你记住了。当你给我时，我自己抄下来。这种类型的函数返回一个值。
- en: '[PRE398]'
  id: totrans-1771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: 'If I am rude, you could return to my classroom and give me the value and I
    could put my fingers in my ears so I don’t hear you or refuse to write it down
    myself so that I quickly forget it. If you call a function that returns a value,
    you can choose to *not* store the return value into a variable and just allow
    the value to vanish:'
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我粗鲁，你可以回到我的教室，把值给我，我可以把手指放在耳朵上，这样我就听不到你，或者拒绝自己写下来，这样我很快就会忘记它。如果你调用一个返回值的函数，你可以选择*不*将返回值存储到一个变量中，而是让这个值消失：
- en: '[PRE399]'
  id: totrans-1773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: This is usually a bad idea, but maybe you have your reasons.
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个坏主意，但也许你有你的理由。
- en: In any case, on line 10 we call the `triangleArea`  function. We pass in `3`,
    `4`  and `5`  as the three arguments. The `3`  gets stored as the value of a (down
    on line 21). The `4`  is stored into b, and `5`  is put into
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，在第10行我们调用`triangleArea`函数。我们传入`3`、`4`和`5`作为三个参数。`3`被存储为a的值（在第21行）。`4`被存储为b，`5`被放入
- en: c. It runs all the code on lines 23 through 28 with those values for the parameters.
    By the end, the variable A has a value stored in it.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: c. 使用这些参数值运行第23到28行的所有代码。最后，变量A中存储了一个值。
- en: On line 29 we *return* the value that is in the variable *A*[.](#bookmark129)[11](#bookmark129)
    This value travels back up to line 10, where it is stored into the variable *a*.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: 在第29行，我们*返回*变量*A*中的值。这个值返回到第10行，存储到变量*a*中。
- en: '[PRE400]'
  id: totrans-1778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-1779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-1780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-1781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: And just to make sure you can see why functions are worth the trouble, here
    is an example of writing this same program without using a function.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你能明白函数值得麻烦的原因，这里有一个例子，写出了同样的程序，但没有使用函数。
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_052.png)'
  id: totrans-1783
  prefs: []
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_052.png)'
- en: (The variable A itself does not get returned, only its value. In fact, remember
    that the “scope” of a variable is limited to the block of code inside which it
    is defined? (You learned that in Exercise 21.) The variable a is only in scope
    inside the function main, and the variables s, A, and the parameter variables
    a, b and c are only in scope inside the function triangleArea.)
  id: totrans-1784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （变量A本身并没有被返回，只有它的值。事实上，要记住变量的“作用域”仅限于它所定义的代码块内吗？（你在练习21中学到了这一点。）变量a只在函数main内部的作用域内，变量s、A和参数变量a、b和c只在函数triangleArea内部的作用域内。）
- en: '[PRE404]'
  id: totrans-1785
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE404]'
- en: What You Should See
  id: totrans-1786
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE405]'
  id: totrans-1787
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE405]'
- en: Study Drills
  id: totrans-1788
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Which one is longer, the one with the function or the one without?
  id: totrans-1789
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪一个更长，有函数的还是没有函数的？
- en: There is a bug in the formula for both files. When `(a+b+c)`  is an odd number,
    dividing by `2`  throws away the `.5`. Fix it so that instead of `(a+b+c)/2`  you
    have `(a+b+c)/2.0`. How much harder would it have been to fix the version that
    didn’t use a function?
  id: totrans-1790
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个文件的公式中有一个错误。当`(a+b+c)`是奇数时，除以`2`会丢失`.5`。将其修正为`(a+b+c)/2.0`。在没有使用函数的版本中修复会更难吗？
- en: 'Add one more test: find the area of a triangle with sides 9, 9, and 9\. Was
    it difficult to add? How much harder would it have been to add the test to the
    version that didn’t use a function?'
  id: totrans-1791
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再添加一个测试：找到一个边长为9、9和9的三角形的面积。添加起来难吗？如果在不使用函数的版本中添加测试会更难吗？
- en: What You Should See After Doing the Study Drills
  id: totrans-1792
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在完成了学习练习后，你应该看到的内容
- en: '[PRE406]'
  id: totrans-1793
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE406]'
- en: That’s better.
  id: totrans-1794
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这更好。
- en: 'Exercise 38: Areas of Shapes'
  id: totrans-1795
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习38：形状的面积
- en: Today’s exercise has nothing new. It is merely additional practice with functions.
    This program has three functions (four if you count `main`) and they all have
    parameters and all three return values.
  id: totrans-1796
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 今天的练习没有什么新东西。这只是对函数的额外练习。这个程序有三个函数（如果算上`main`就有四个），它们都有参数，三个都有返回值。
- en: '[PRE407]'
  id: totrans-1797
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-1798
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-1799
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-1800
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-1801
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-1802
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-1803
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-1804
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-1805
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-1806
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-1807
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-1808
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-1809
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-1810
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-1811
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-1812
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-1813
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-1814
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-1815
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-1816
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE426]'
- en: '[PRE427]'
  id: totrans-1817
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-1818
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-1819
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-1820
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-1821
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE431]'
- en: What You Should See
  id: totrans-1822
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE432]'
  id: totrans-1823
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-1824
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-1825
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-1826
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-1827
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-1828
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-1829
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-1830
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-1831
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE440]'
- en: '[PRE441]'
  id: totrans-1832
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-1833
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-1834
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-1835
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-1836
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-1837
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-1838
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE447]'
- en: On line 57 we have defined a function to compute the area of a triangle (using
    just the base and height this time). It needs two arguments and will return a
    `double`  value. On line 59 we declare a variable named A. This variable is “local”
    to the function. Even though there is a variable named A declared on line 66,
    they are not the same variable. (It’s like having two friends named “Michael”.
    Just because they have the same name doesn’t make them the same person.)
  id: totrans-1839
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第57行，我们定义了一个计算三角形面积的函数（这次只使用底边和高）。它需要两个参数，并将返回一个`double`值。在第59行，我们声明了一个名为A的变量。这个变量是函数“局部”的。尽管在第66行声明了一个名为A的变量，但它们并不是同一个变量。（就像有两个名叫“迈克尔”的朋友。只是因为他们有相同的名字并不意味着他们是同一个人。）
- en: The value of the variable *b* (defined on line 27) is passed in as the initial
    value of the parameter *base* in the function call on line 30\. *b* is stored
    into *base* because *b* is first, not because *base* starts with a *b*. The
  id: totrans-1840
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量*b*（在第27行定义）的值作为函数调用中参数*base*的初始值传入。*b*被存储到*base*中，因为*b*是首先出现的，而不是因为*base*以*b*开头。
- en: computer doesn’t care anything about that. Only the order matters.
  id: totrans-1841
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算机对此并不在乎。只有顺序才重要。
- en: On line 61 the value of A is returned to `main`  and ends up getting stored
    in the variable called area. I did three strange things in the rectangle area
    function whose definition begins on line 71.
  id: totrans-1842
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第61行，A的值返回到`main`，最终被存储在名为area的变量中。在矩形面积函数的定义开始于第71行时，我做了三件奇怪的事情。
- en: First, the formal parameters have the same names as the actual arguments. (Remember,
    the parameters are the variables declared in the function definition on line 71
    and the arguments are the variables in the parentheses in the function call on
    line 46.) This is a neat coincidence, but it doesn’t mean anything. It is like
    having an actor named “Steven” playing a character named “Steven”. The value from
    `main`’s version of length gets stored into `computeRectangleArea`’s length variable
    because they are both listed first in the parentheses and for no other reason.
  id: totrans-1843
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，形式参数与实际参数具有相同的名称。（记住，参数是函数定义中声明的变量，位于第71行，参数是函数调用中括号中的变量。）这是一个巧合，但并不意味着什么。这就像一个名叫“史蒂文”的演员扮演一个名叫“史蒂文”的角色。`main`版本的length的值被存储到`computeRectangleArea`的length变量中，因为它们都在括号中首先列出，没有其他原因。
- en: Secondly, I did not bother to create a variable for the value the function is
    going to return on line 73\. I simply returned the value of the expression `length*width`.
    The function will figure out what the value is and return it right away without
    ever storing it into a variable.
  id: totrans-1844
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其次，我没有费心为函数将要返回的值创建一个变量。我只是返回了表达式`length*width`的值。函数会计算出值并立即返回，而不会将其存储到变量中。
- en: 'Thirdly, the rectangle area value is returned back to `main`  on line 46, but
    I didn’t bother to store the return value into a variable: I just printed it on
    the screen directly. (I also did this in `HeronsFormula`  but I didn’t call attention
    to it.) This is totally fine and actually pretty common. We call functions all
    the time and we almost always use the return value of the function but we don’t
    always need to store the return value into its own variable.'
  id: totrans-1845
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三，矩形面积值在第46行返回到`main`，但我没有费心将返回值存储到变量中：我直接在屏幕上打印出来。(我在`HeronsFormula`中也这样做了，但我没有特别指出。)这是完全可以的，实际上非常常见。我们经常调用函数，几乎总是使用函数的返回值，但我们并不总是需要将返回值存储到自己的变量中。
- en: Finally, before we move on to another topic I should mention that in Java, functions
    can only return a single value. In some other programming languages functions
    can return more than one value. But in Java functions can return a single value
    or no value (if the function is `void`) but never more than one.
  id: totrans-1846
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，在我们转到另一个话题之前，我应该提到，在Java中，函数只能返回一个值。在其他一些编程语言中，函数可以返回多个值。但在Java中，函数可以返回一个值或没有值（如果函数是`void`），但绝不会超过一个。
- en: P.S. These functions are a bit silly. If I were *really* needing a shape area
    calculator, I am not sure if it would be worth it to create a whole function for
    an equation that is only one line of code. But this example is good for explaining,
    anyway.
  id: totrans-1847
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: P.S.这些函数有点傻。如果我*真的*需要一个形状面积计算器，我不确定是否值得为一个只有一行代码的方程创建一个完整的函数。但是这个例子用来解释是很好的。
- en: Study Drills
  id: totrans-1848
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: 1\. Add a function to compute the area of a square. Add it to the menu as well.
  id: totrans-1849
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 添加一个计算正方形面积的函数。也将其添加到菜单中。
- en: 'Exercise 39: Thirty Days Revisited with Javadoc'
  id: totrans-1850
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习39：使用Javadoc重新审视三十天
- en: In the previous exercise we wrote some functions that might have been better
    off omitted. In today’s exercise we are going to re­do a previous exercise, making
    it better with functions.
  id: totrans-1851
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们写了一些可能更好被省略的函数。在今天的练习中，我们将重新做一个之前的练习，使用函数使其更好。
- en: And, because I always have to keep pushing, I have added special comments above
    the class and above each function called “Javadoc comments”.
  id: totrans-1852
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而且，因为我总是不断努力，我在类的上方和每个函数的上方添加了称为“Javadoc注释”的特殊注释。
- en: '[PRE448]'
  id: totrans-1853
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-1854
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-1855
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-1856
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-1857
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-1858
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-1859
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-1860
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-1861
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-1862
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-1863
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-1864
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-1865
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-1866
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE461]'
- en: '[PRE462]'
  id: totrans-1867
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-1868
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-1869
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-1870
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-1871
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE466]'
- en: '[PRE467]'
  id: totrans-1872
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-1873
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-1874
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-1875
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-1876
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE471]'
- en: '[PRE472]'
  id: totrans-1877
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-1878
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-1879
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-1880
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-1881
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-1882
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-1883
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-1884
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-1885
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-1886
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-1887
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-1888
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-1889
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-1890
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-1891
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-1892
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-1893
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-1894
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-1895
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-1896
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-1897
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE492]'
- en: What You Should See
  id: totrans-1898
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您应该看到的内容
- en: '[PRE493]'
  id: totrans-1899
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE493]'
- en: If you ignore the Javadoc comments for now, hopefully you should see that using
    functions here actually improves the code. `main()`  is very short, because most
    of the interesting work is being done in the functions.
  id: totrans-1900
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果现在忽略Javadoc注释，希望您应该能够看到在这里使用函数实际上改进了代码。`main()`非常简短，因为大部分有趣的工作都是在函数中完成的。
- en: All the code and variables pertaining to the name of the month is isolated in
    the `monthName()`  function. And all the code to find the number of days in a
    month is contained inside the `monthDays()`  function.
  id: totrans-1901
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与月份名称相关的所有代码和变量都被隔离在`monthName()`函数中。查找月份天数的所有代码都包含在`monthDays()`函数中。
- en: Collecting variables and code into functions like this is called “procedural
    programming” and it is considered a major advance over just having all your code
    in `main()`. It makes your code easier to debug because if you have a problem
    with the name of the month, you know it has to be inside the `monthName()`  function.
  id: totrans-1902
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像这样将变量和代码收集到函数中被称为“过程式编程”，这被认为是比将所有代码放在`main()`中更重要的进步。这使得您的代码更容易调试，因为如果您遇到月份名称的问题，您就知道它必须在`monthName()`函数中。
- en: Okay, now let’s talk about the Javadoc comments.
  id: totrans-1903
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，现在让我们谈谈Javadoc注释。
- en: '`javadoc`  is an automatic documentation­generating tool that is included with
    the Java compiler. You write document right in your code by doing a special sort
    of block comment above classes, functions or variables.'
  id: totrans-1904
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`javadoc` 是随同Java编译器一起提供的自动生成文档的工具。您可以通过在类、函数或变量上方使用特殊类型的块注释来在代码中编写文档。'
- en: The comment begins with `/**`  and ends with `*/`  and every line in between
    starts with an asterisk (`*`)
  id: totrans-1905
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注释以`/**`开头，以`*/`结尾，中间的每一行都以星号(`*`)开头
- en: which is lined up like you see in the exercise.
  id: totrans-1906
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像您在练习中看到的那样排列。
- en: The first line of the javadoc comment is a one­sentence summary of the thing
    (class or function). And then there are tags like `@author`  or `@return`  that
    give more detail about who wrote the code, what parameters the function expects
    or what value it is going to return.
  id: totrans-1907
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: javadoc注释的第一行是关于该事物（类或函数）的一句话摘要。然后有标签如`@author`或`@return`，提供了更多关于谁编写了代码，函数期望的参数或它将返回的值的详细信息。
- en: 'Okay, so now for the magic part. Go to the terminal window just like you were
    going to compile your code, and type the following command:'
  id: totrans-1908
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，现在是魔法部分。打开终端窗口，就像您要编译代码一样，然后输入以下命令：
- en: '[PRE494]'
  id: totrans-1909
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE494]'
- en: Then if you look in the folder where `ThirtyDaysFunctions.java`  is located,
    you will see a lot of new files. (Maybe I should have warned you first.) Open
    the file called `index.html`  in the web browser of your choice.
  id: totrans-1910
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，如果您查看`ThirtyDaysFunctions.java`所在的文件夹，您将看到许多新文件。（也许我应该先警告您。）在您选择的Web浏览器中打开名为`index.html`的文件。
- en: This is javadoc documentation, and there is a *lot* of information there. You
    can find the comment you put for the class near the top, and the comments for
    the functions are in the section called “Method Summary”.
  id: totrans-1911
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是javadoc文档，其中包含*大量*的信息。您可以在顶部附近找到您为类放置的注释，函数的注释在名为“Method Summary”的部分中。
- en: The details about the parameters and return types are down below in the section
    called “Method Detail”.
  id: totrans-1912
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有关参数和返回类型的详细信息在名为“Method Detail”的部分下面。
- en: Study Drills
  id: totrans-1913
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: '1\. Look at the javadoc documentation for one of the built­in Java classes:
    java.util.Scanner. Notice how similar it looks to what the javadoc tool generated?
    All the official Java documentation is created using the javadoc tool, so learning
    how to read it will be an important part of becoming an expert Java programmer.
    Don’t worry too much about the details right now, though. Just try to get a feel
    for how it looks.'
  id: totrans-1914
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 查看内置Java类java.util.Scanner的javadoc文档。注意它看起来与javadoc工具生成的文档有多相似？所有官方的Java文档都是使用javadoc工具创建的，因此学习如何阅读它将成为成为专业Java程序员的重要部分。不过现在不要太担心细节，只是试着感受一下它的外观。
- en: In the upper left is a list of all the packages of code that are included as
    part of Java and below that on the left is a list of all the classes/ libraries
    you could import to save you from having to write code. A big part of what professional
    Java programmers do is write code to glue together existing Java libraries.
  id: totrans-1915
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 左上角是包含在Java中的所有代码包的列表，下面是左侧是您可以导入以避免编写代码的所有类/库的列表。专业的Java程序员的工作的一大部分是编写代码来粘合现有的Java库。
- en: This is probably overwhelming right now. That’s fine because you have just started.
    Hopefully no one expects you to understand much about this yet. In fact, most
    programmers only know about a fraction of the built­in Java libraries, and they
    search on the Internet and read the documentation when they need to do something
    new, just like you do!
  id: totrans-1916
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在这可能让您感到不知所措。这没关系，因为您刚刚开始。希望没有人期望您现在就了解太多。事实上，大多数程序员只了解Java的内置库的一小部分，并且当他们需要做一些新的事情时，他们会在互联网上搜索并阅读文档，就像您一样！
- en: 'Exercise 40: Importing Standard Libraries'
  id: totrans-1917
  prefs:
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习40：导入标准库
- en: In the last exercise you got a terrifying look at all of the built­in modules
    that are available in Java. Today we will look at a “simple” program that took
    me about half an hour to write because I spent a lot of time searching the Internet
    and importing things and trying things that didn’t work.
  id: totrans-1918
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个练习中，您看到了Java中可用的所有内置模块，这可能让您感到恐慌。今天我们将看一个“简单”的程序，我花了大约半个小时的时间编写，因为我花了很多时间在互联网上搜索和导入东西，尝试了一些不起作用的东西。
- en: This code works, though. It allows the human to enter a password (or anything,
    really) and then prints out the SHA­256 message digest of that password.
  id: totrans-1919
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码有效。它允许用户输入密码（或任何内容），然后打印出该密码的SHA-256消息摘要。
- en: When you are typing in this code, don’t forget to put the `throws Exception`  at
    the end of line 7.
  id: totrans-1920
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您在编写此代码时，不要忘记在第7行的末尾加上`throws Exception`。
- en: '[PRE495]'
  id: totrans-1921
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-1922
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-1923
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-1924
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE498]'
- en: What You Should See
  id: totrans-1925
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您应该看到的内容
- en: '[PRE499]'
  id: totrans-1926
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE499]'
- en: That 64­character long string is the SHA­256 digest of the String `password`.
    That message digest will always be the same for that input.
  id: totrans-1927
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那个64个字符长的字符串是字符串`password`的SHA­256摘要。该消息摘要对于该输入始终是相同的。
- en: 'If you type in a different password, you’ll get a different digest, of course:'
  id: totrans-1928
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您输入不同的密码，当然会得到不同的摘要：
- en: '[PRE500]'
  id: totrans-1929
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE500]'
- en: Back in the early days of programming, when machines first started having usernames
    and password, it was pretty obvious that you wouldn’t want to store the passwords
    themselves in a database. Instead, they would store some sort of cryptographic
    hash of the password.
  id: totrans-1930
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编程的早期，当机器开始拥有用户名和密码时，很明显您不希望直接在数据库中存储密码本身。相反，他们会存储密码的某种加密哈希。
- en: 'Cryptographic hashes have two useful properties:'
  id: totrans-1931
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 加密哈希具有两个有用的属性：
- en: They are consistent. A given input will always produce exactly the same output.
  id: totrans-1932
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们是一致的。给定的输入将始终产生完全相同的输出。
- en: They are one­way. You can easily compute the output for a given input, but figuring
    out the input that gave you a certain output is very hard or impossible.
  id: totrans-1933
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们是单向的。您可以轻松计算给定输入的输出，但找出给您某个输出的输入是非常困难或不可能的。
- en: SHA­256 is a very good cryptographic hash function, and it produces a “digest”
    for a given input (or “message”) that is always exactly 256 bits long. Here instead
    of trying to deal with bits we have printed out the base­64 representation of
    those bits, which ends up being 64 characters long where each character is a hexadecimal
    digit.
  id: totrans-1934
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SHA­256是一个非常好的加密哈希函数，它始终产生一个给定输入（或“消息”）的“摘要”，长度恰好为256位。在这里，我们没有尝试处理位，而是打印出了这些位的base­64表示，最终是64个字符长，其中每个字符都是十六进制数字。
- en: Back in the 1970s, to change your password on a certain machine you would type
    your password and the machine would store your username and the hash of your new
    password in a file.
  id: totrans-1935
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 回到20世纪70年代，要在某台机器上更改密码，您需要输入密码，然后机器会将您的用户名和新密码的哈希存储在文件中。
- en: Then when you wanted to log in to the machine later, it would make you type
    in your username and password. It would find the username in the password database
    file and find the stored hash of your password. Then it would find the hash of
    whatever password you just typed. If the stored hash and the computed hash match,
    then you must have typed in the correct password and you would be allowed access
    to the machine.
  id: totrans-1936
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，当您以后想要登录到机器时，它会让您输入用户名和密码。它会在密码数据库文件中找到用户名，并找到您密码的存储哈希值。然后它会找到您刚刚输入的密码的哈希值。如果存储的哈希值和计算的哈希值匹配，那么您必须输入了正确的密码，您将被允许访问该机器。
- en: This is a clever scheme. It is also *much* better than ever storing passwords
    directly in a database. However, nowadays computers are way too fast and have
    way too much storage space for this to be enough security. Since machines can
    compute the SHA­256 of a password *very* quickly, it doesn’t take long for a determined
    hacker to figure out what your password was.
  id: totrans-1937
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个聪明的方案。这也比直接在数据库中存储密码要好得多。然而，现在计算机速度太快，存储空间太大，这已经不足以提供足够的安全性。由于机器可以非常快速地计算密码的SHA­256，一个决心的黑客不需要很长时间就能够弄清楚您的密码是什么。
- en: (If you really want to securely store passwords in a database, you should be
    using `bcrypt`, which is made for such things. Unfortunately bcrypt isn’t built­in
    to Java, so you will need to download a bcrypt library made by someone else.)
  id: totrans-1938
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果您真的想要在数据库中安全存储密码，您应该使用`bcrypt`，它专门用于此类事情。不幸的是，bcrypt并没有内置到Java中，因此您需要下载其他人制作的bcrypt库。）
- en: Okay, enough about secure passwords, let us walk through this code. You might
    want to have the javadoc documentation for these two libraries open.
  id: totrans-1939
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好了，关于安全密码就说这么多，让我们走一遍这段代码。您可能希望打开这两个库的javadoc文档。
- en: java.security.MessageDigest
  id: totrans-1940
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.security.MessageDigest
- en: javax.xml.bind.DatatypeConverter
  id: totrans-1941
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: javax.xml.bind.DatatypeConverter
- en: On lines 2 and 3 we import the two libraries we will be using to do the hard
    parts of this exercise.
  id: totrans-1942
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第2和3行，我们导入了两个库，这两个库将用于执行此练习的难点。
- en: On line 13 we create a variable of type `MessageDigest`  (which now exists because
    we imported `java.security.MessageDigest`. Our variable is named digest, although
    I could have called it something else. And the value of the variable comes from
    the return value of the method `MessageDigest.getInstance()`. We pass in a String
    as an argument to this method, which is which digest we want. In this case we
    are using `"SHA­256"`, but `"SHA­1"`  and `"MD5"`  would have also worked. You
    can read about this stuff in the javadoc documentation.
  id: totrans-1943
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第13行，我们创建了一个`MessageDigest`类型的变量（现在存在，因为我们导入了`java.security.MessageDigest`）。我们的变量名为digest，尽管我也可以叫它其他名字。变量的值来自于`MessageDigest.getInstance()`方法的返回值。我们将一个字符串作为该方法的参数传递，这是我们想要的摘要。在这种情况下，我们使用了`"SHA­256"`，但`"SHA­1"`和`"MD5"`也可以工作。您可以在javadoc文档中阅读有关此内容的信息。
- en: Lines 15 and 16 are hopefully boring. Notice that I used `nextLine()`  instead
    of just `next()`  to read in the password, which allows the human to type in more
    than one word.
  id: totrans-1944
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第15和16行希望是无聊的。请注意，我使用`nextLine()`而不是`next()`来读取密码，这允许用户输入多个单词。
- en: On line 18 we call the `getBytes()`  method of the String class, with an argument
    of `"UTF­8"`. This converts the String value to a raw list of bytes in UTF­8 format
    which we pass directly as an argument to the `update()`  method of the MessageDigest
    object named digest. I learned about the `getBytes()`  method by reading the javadoc
    documentation for the String class!
  id: totrans-1945
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第18行，我们调用了String类的`getBytes()`方法，参数为`"UTF­8"`。这将把字符串值转换为UTF­8格式的原始字节列表，然后将其直接作为参数传递给名为digest的MessageDigest对象的`update()`方法。我通过阅读String类的javadoc文档了解了`getBytes()`方法！
- en: java.lang.String
  id: totrans-1946
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: java.lang.String
- en: On line 19 we call the `digest()`  method of the MessageDigest object named
    digest. This gives us a raw list of bytes and isn’t suitable for printing on the
    screen, so we pass that raw list of bytes directly as a parameter to the `printHexBinary()`  method
    of the DatatypeConverter class. This returns a String, which we store into the
    variable hash.
  id: totrans-1947
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第19行我们调用了名为digest的MessageDigest对象的`digest()`方法。这给了我们一个原始的字节列表，不适合在屏幕上打印，所以我们直接将这个原始的字节列表作为参数传递给DatatypeConverter类的`printHexBinary()`方法。这将返回一个字符串，我们将其存储到变量hash中。
- en: We then display the hash value on the screen. Whew!
  id: totrans-1948
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们在屏幕上显示哈希值。哇！
- en: If this exercise freaked you out a little bit, don’t worry. If you can make
    it through the first 39 exercises in the book, then you could learn to do this
    sort of thing, too. You have to learn how to read javadoc documentation to learn
    what sort of tools other people have already written for you and how to connect
    them together to get what you want. It just takes a lot of practice! Remember
    that writing this exercise the first time took me more than half an hour, and
    I’ve been programming since the 1980s and started coding in Java in 1996!
  id: totrans-1949
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这个练习让你有点紧张，别担心。如果你能完成本书的前39个练习，那么你也可以学会做这种事情。你必须学会阅读javadoc文档，了解其他人已经为你写好了什么样的工具，以及如何将它们连接在一起以获得你想要的东西。这只是需要大量的练习！记住，第一次写这个练习花了我半个多小时，而我从上世纪80年代开始编程，1996年开始编写Java代码！
- en: Study Drills
  id: totrans-1950
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习 Drill
- en: 'Look at the javadoc documentation for all the methods used in this exercise:
    getInstance, getBytes, update, digest, and printHexBinary. Look at what arguments
    they expect and look at the types of values they will return.'
  id: totrans-1951
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看本练习中使用的所有方法的javadoc文档：getInstance、getBytes、update、digest和printHexBinary。查看它们期望的参数和它们将返回的值的类型。
- en: Remove the `throws Exception`  from the end of line 7\. Try to compile it. (Then
    put it back.) You will learn a tiny bit about exceptions in the next exercise.
  id: totrans-1952
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第7行的末尾删除`throws Exception`。尝试编译它。（然后再放回去。）你将在下一个练习中学到一点关于异常。
- en: 'Exercise 41: Programs that Write to Files'
  id: totrans-1953
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习41：写入文件的程序
- en: We are going to take a break from focusing on functions now for a bit and learn
    something easy. We are going to create a program that can put information into
    a text file instead of only being able to print things on the screen.
  id: totrans-1954
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在要暂时停下来专注于函数，学习一些简单的东西。我们要创建一个程序，可以将信息放入文本文件，而不仅仅是在屏幕上打印东西。
- en: When you are typing in this code, don’t miss the `throws Exception`  at the
    end of line 6\. (And in this exercise, I’ll actually explain what that means.)
  id: totrans-1955
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你在输入这段代码时，不要错过第6行末尾的`throws Exception`。（在这个练习中，我会解释这意味着什么。）
- en: What You Should See
  id: totrans-2009
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_055.png)'
  id: totrans-2010
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_055.png)'
- en: That’s right. When you run your program, it will appear to do nothing. But if
    you wrote it correctly, it should have created a file called `letter.txt`  in
    the same folder your code is in. You can view this file using the same text editor
    you are using to write your code.
  id: totrans-2011
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没错。当你运行你的程序时，它似乎什么都没做。但如果你写得正确，它应该在与你的代码相同的文件夹中创建一个名为`letter.txt`的文件。你可以使用与写代码相同的文本编辑器查看这个文件。
- en: 'If for some reason you are using the version of Notepad that came with Windows
    95, it will look a little something like this:'
  id: totrans-2012
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果由于某种原因你正在使用随Windows 95一起提供的版本的记事本，它看起来可能会像这样：
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_056.gif)'
  id: totrans-2013
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_056.gif)'
- en: (I made that screenshot a long time ago, okay? I’ve been doing this a long time,
    remember. When I first
  id: totrans-2014
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （那个截图是很久以前做的，好吧？记住我做这个已经很长时间了。当我第一次
- en: gave this assignment to students, Windows 95 was the newest version of Windows….
    In fact, I guess the zip code changed at some point.)
  id: totrans-2015
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我把这个作业给学生时，Windows 95是最新版本的Windows……实际上，我猜邮政编码在某个时候改变了。）
- en: On lines 1 and 2 there are two new `import`  statements, one for each of the
    Java classes that will make this easy.
  id: totrans-2016
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第1行和第2行有两个新的`import`语句，分别是用于这两个Java类的。
- en: On line 8 we declare a variable. The variable is of type `PrintWriter`  and
    I have chosen to name it
  id: totrans-2017
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第8行，我们声明了一个变量。这个变量的类型是`PrintWriter`，我选择将它命名为fileout（尽管变量的名称并不重要）。
- en: fileout (although the variable’s name doesn’t matter).
  id: totrans-2018
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: fileout（尽管变量的名称并不重要）。
- en: 'On line 10 we give the PrintWriter variable a value: the reference to a new
    PrintWriter object. Creating the PrintWriter object requires an argument, though.
    The argument we give it is a new `FileWriter`  object, which itself is created
    with the filename as an argument.'
  id: totrans-2019
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第10行，我们给PrintWriter变量赋了一个值：一个新的PrintWriter对象的引用。创建PrintWriter对象需要一个参数。我们给它的参数是一个新的`FileWriter`对象，它本身是用文件名作为参数创建的。
- en: It is possible to write to a text file using only a `FileWriter`  object and
    without using any PrintWriter at all. However, PrintWriters are much easier to
    work with, as you can tell by looking at the rest of the code. So instead of working
    with the FileWriter object directly, we “wrap” the FileWriter object with a PrintWriter
    object and just work through the PrintWriter object.
  id: totrans-2020
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以只使用`FileWriter`对象而不使用任何PrintWriter来写入文本文件。然而，PrintWriters更容易使用，你可以通过查看代码的其余部分来看出来。所以我们不直接使用FileWriter对象，而是用PrintWriter对象“包装”FileWriter对象，然后通过PrintWriter对象进行操作。
- en: (It is okay if you didn’t understand the last two paragraphs. You don’t need
    to understand them to write to files.)
  id: totrans-2021
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果你不理解最后两段，没关系。你不需要理解它们来写文件。）
- en: The good news is that once the PrintWriter object is set up, everything else
    is easy. Because you have secretly been working with PrintWriters since the very
    beginning! This is because `System.out`  is a PrintWriter!
  id: totrans-2022
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好消息是，一旦PrintWriter对象设置好了，其他的事情就很容易了。因为你从一开始就在秘密地使用PrintWriters！这是因为`System.out`是一个PrintWriter！
- en: So on line 12 you can see that writing to the file looks very similar to printing
    on the screen. But the String (`+­­­­­`) will not be printed on the screen. It
    will be stored as the first line of the file `letter.txt`!
  id: totrans-2023
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在第12行，您可以看到写入文件看起来与在屏幕上打印非常相似。但是字符串（`+­­­­­`）不会被打印在屏幕上。它将被存储为文件`letter.txt`的第一行！
- en: If a file named `letter.txt`  already exists in that folder, its contents will
    be overwritten without warning. If the file does not exist, it will be created.
  id: totrans-2024
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果该文件夹中已经存在名为`letter.txt`的文件，则其内容将被覆盖而不会有警告。如果文件不存在，则将创建该文件。
- en: The only other important line in the exercise is line 23\. This actually saves
    the contents of the file and closes it so your program can’t write to it anymore.
    If you remove this line, your program will most likely create a file called `letter.txt`,
    but the file will be empty.
  id: totrans-2025
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 练习中的另一个重要行是第23行。这实际上保存了文件的内容并关闭了它，因此您的程序无法再对其进行写入。如果删除此行，您的程序很可能会创建一个名为`letter.txt`的文件，但该文件将为空。
- en: Okay, before I end the exercise, I want to briefly discuss `throws Exception`.
    This is not something we do much in Real Programming, and explaining it properly
    is beyond the scope of this book, but I do want to touch on it.
  id: totrans-2026
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，在结束练习之前，我想简要讨论一下`throws Exception`。这在真正的编程中并不常见，并且适当地解释它超出了本书的范围，但我确实想谈一下。
- en: In the original version of the exercise, when you put `throws Exception`  after
    the first line of a function, it means “I have written code in this function that
    might not work, and if it fails it will blow up (by throwing an exception).”
  id: totrans-2027
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在练习的原始版本中，当您在函数的第一行之后放置`throws Exception`时，它的意思是“我已经在这个函数中编写了可能不起作用的代码，如果失败，它将会失败（通过抛出异常）。”
- en: In this case the thing that might not work is the line `new FileWriter( "letter.txt"
    )`  because it tries to open a file for writing in the current folder. This could
    fail if there is already a file called “letter.txt” and the file is read­only.
    Or maybe the whole folder is read­only. Or there’s some other reason the program
    can’t get write permission to the file.
  id: totrans-2028
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，可能不起作用的是`new FileWriter（“letter.txt”）`这一行，因为它试图在当前文件夹中打开一个文件进行写入。如果已经有一个名为“letter.txt”的文件并且该文件是只读的，这可能会失败。或者整个文件夹是只读的。或者有其他原因导致程序无法获得对文件的写入权限。
- en: 'So instead of just blowing up the program we are supposed to detect the exception
    and handle it. Like so:'
  id: totrans-2091
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，我们不是简单地使程序崩溃，而是应该检测异常并处理它。就像这样：
- en: The `try`  block means “this code may throw an exception, but attempt it.” If
    everything goes well (if there is no exception thrown) then the `catch`  block
    is skipped. If there is an exception thrown, the `catch`  block gets executed,
    and the exception that was thrown gets passed in as a parameter. (I have named
    the exception parameter err, though it could be named anything.)
  id: totrans-2092
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`try`块的意思是“这段代码可能会抛出异常，但尝试执行它。”如果一切顺利（如果没有抛出异常），那么`catch`块将被跳过。如果抛出异常，则会执行`catch`块，并将抛出的异常作为参数传递进去。（我已经将异常参数命名为err，尽管它可以被命名为任何东西。）'
- en: Inside the `catch`  block I print out a suitable error message and then end
    the program by calling the built­in function `System.exit()`. If you pass an argument
    of `0`  to `System.exit()`, the program will end, but the zero means “everything
    is fine”. An argument of `1`  means “this program is ending, and it is because
    something went wrong.”
  id: totrans-2093
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`catch`块中，我打印出一个合适的错误消息，然后通过调用内置函数`System.exit()`来结束程序。如果向`System.exit()`传递参数`0`，程序将结束，但零表示“一切正常”。参数`1`表示“程序正在结束，因为出了问题”。
- en: So I won’t use `try`  and `catch`  anymore in this book, but at least now you
    know what you are avoiding by putting `throws Exception`.
  id: totrans-2094
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以我不会在这本书中再使用`try`和`catch`了，但至少现在你知道通过使用`throws Exception`来避免什么了。
- en: 'Exercise 42: Getting Data from a File'
  id: totrans-2095
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习42：从文件中获取数据
- en: A program that can put information into a file is only part of the story. So
    in this exercise you will learn how to read information that is already in a text
    file.
  id: totrans-2096
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 能够将信息放入文件的程序只是故事的一部分。因此，在这个练习中，您将学习如何读取已经存在于文本文件中的信息。
- en: If you type up this code and compile it and run, it will blow up. This is because
    it is trying to read from a text file called `name­and­numbers.txt`, which must
    be in the same folder as your code. You probably don’t have a file like this!
  id: totrans-2097
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你输入这段代码并编译并运行，它会崩溃。这是因为它试图从一个名为`name-and-numbers.txt`的文本文件中读取，这个文件必须与你的代码在同一个文件夹中。你可能没有这样的文件！
- en: 'So before you even write the code, let us make a text file containing a String
    and three integers. My file looks like this:'
  id: totrans-2098
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在你写代码之前，让我们创建一个包含一个字符串和三个整数的文本文件。我的文件看起来像这样：
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_058.jpg)'
  id: totrans-2099
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_058.jpg)'
- en: (This is a slightly newer version of Notepad. Happy now?) Okay, to the code!
  id: totrans-2100
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （这是一个稍微更新的记事本版本。现在开心了吗？）好了，来看代码吧！
- en: '[PRE501]'
  id: totrans-2101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-2102
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-2103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE503]'
- en: What You Should See
  id: totrans-2104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE504]'
  id: totrans-2105
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE504]'
- en: Did you know that the Scanner object doesn’t have to get input from the human
    at the keyboard? It can read data from text files, too!
  id: totrans-2106
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你知道Scanner对象不一定要从键盘上的人那里获取输入吗？它也可以从文本文件中读取数据！
- en: 'We just create the Scanner object slightly differently: instead of `System.in`  as
    the argument, we use `new File("blah.txt")`. This will open the text file read­only.
    The Scanner object (which I have chosen to call fileIn) will be attached to the
    file like a straw stuck into a juice box. (The juice box is the text file, and
    the Scanner object is the straw.)'
  id: totrans-2107
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只是稍微不同地创建了Scanner对象：不再使用`System.in`作为参数，而是使用`new File("blah.txt")`。这将以只读方式打开文本文件。我选择称之为fileIn的Scanner对象将附加到文件上，就像吸管插入果汁盒一样。（果汁盒就是文本文件，Scanner对象就是吸管。）
- en: Line 14 looks pretty uninteresting. It “pauses” the program and reads in a String
    from the Scanner object, which gets it from the file. This String from the file
    is stored into the variable.
  id: totrans-2108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第14行看起来相当无聊。它“暂停”程序并从Scanner对象中读取一个字符串，这个字符串来自文件。这个来自文件的字符串被存储到变量中。
- en: Lines 15 through 17 are simple, too. Except what is read from the file is converted
    to an integer before putting it in the variables.
  id: totrans-2109
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第15到17行也很简单。除了从文件中读取的内容在放入变量之前被转换为整数。
- en: 'What if the next thing in the file isn’t an integer? Then your program will
    blow up. And now you can’t blame the human anymore: you created this file. It
    is your job to make sure you know what values are in it, and in what order.'
  id: totrans-2110
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文件中的下一个内容不是整数会怎样？那么你的程序将崩溃。现在你不能再责怪人类了：你创建了这个文件。你的工作是确保你知道里面有什么值，以及顺序是什么。
- en: On line 18 the file is closed, which means your Scanner object isn’t connected
    to it anymore. Was this easier than you expected it to be? Hopefully so.
  id: totrans-2111
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第18行，文件被关闭，这意味着你的Scanner对象不再与它连接。这比你预期的要容易吗？希望是这样。
- en: Study Drills
  id: totrans-2112
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Open the text file and change the name or numbers. Save it. Then run your program
    again (you don’t have to compile it again; the code hasn’t changed and it doesn’t
    open the file until it is run.)
  id: totrans-2113
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文本文件并更改名称或数字。保存它。然后再次运行程序（您不必重新编译它；代码没有更改，直到运行程序时它才会打开文件）。
- en: 'Exercise 43: Saving a High Score'
  id: totrans-2114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习43：保存最高分
- en: Now that you know how to get information from files *and* how to put information
    in files, we can create a game that saves the high score!
  id: totrans-2115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你知道如何从文件中获取信息*以及*如何将信息放入文件，我们可以创建一个保存最高分的游戏！
- en: This is the coin flipping game from a few exercises ago, but now the high score
    is saved from run to run.
  id: totrans-2116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是之前几个练习中的抛硬币游戏，但现在高分保存在运行之间。
- en: '[PRE505]'
  id: totrans-2117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-2118
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-2119
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-2120
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-2121
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-2122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-2123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-2124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-2125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-2126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-2127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE515]'
- en: '[PRE516]'
  id: totrans-2128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-2129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-2130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-2131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-2132
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-2133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-2134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-2135
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-2136
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE524]'
- en: What You Should See
  id: totrans-2137
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE525]'
  id: totrans-2138
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE525]'
- en: (Okay, so I cheated. It took me quite a few tries to get a streak of three in
    a row.)
  id: totrans-2139
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （好吧，我作弊了。我尝试了很多次才连续三次猜对。）
- en: On line 15 we create a `File`  object using the filename `coin­flip­score.txt`.
    We can do this even if the file doesn’t exist.
  id: totrans-2140
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第15行，我们使用文件名`coin-flip-score.txt`创建了一个`File`对象。即使文件不存在，我们也可以这样做。
- en: On line 16 there is an `if`  statement, and in the condition I call the `createNewFile()`  method
    of the File object. This will check to see if the file exists. If so, it will
    do nothing and return the Boolean value `false`. If the file does not exist, it
    will create the file empty and return the value `true`.
  id: totrans-2141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第16行有一个`if`语句，在条件中我调用了File对象的`createNewFile()`方法。这将检查文件是否存在。如果是，它将什么也不做并返回布尔值`false`。如果文件不存在，它将创建一个空文件并返回值`true`。
- en: When the `if`  statement is true, then, it means the save game file didn’t exist.
    We say so and put suitable initial values into the variables best and bestName.
    If not, then there’s already a file there, so we use a Scanner object to get the
    existing name and high score out of the file. Cool, eh?
  id: totrans-2142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`if`语句为真时，这意味着保存游戏文件不存在。我们会这样说，并将合适的初始值放入变量best和bestName中。如果不是，那么已经有一个文件存在，所以我们使用Scanner对象从文件中获取现有的名称和最高分。很酷，对吧？
- en: Lines 32 through 57 are the existing coin flip game. I didn’t change any of
    this code at all.
  id: totrans-2143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第32到57行是现有的抛硬币游戏。我一点也没有改变这段代码。
- en: On line 59 we need to figure out if they beat the high score. If so, we print
    out a message to that effect and let them enter their name.
  id: totrans-2144
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第59行，我们需要弄清楚他们是否打破了最高分。如果是，我们会打印出相应的消息并让他们输入他们的名字。
- en: If they tied the high score, we say so, but they don’t get any fame for that.
  id: totrans-2145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果他们打破了最高分，我们会这样说，但他们不会因此而得到任何名声。
- en: And on line 70 the `else`  will run if they didn’t beat or tie the high score.
    So we taunt them, of course.
  id: totrans-2146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并且在第70行，如果他们没有打破或并列最高分，`else`将运行。所以我们当然会嘲笑他们。
- en: On lines 75 through 79 we save the current high score along with the name of
    the high scorer to the file. This might be a new score, or it might be the previous
    value we read at the beginning of the program.
  id: totrans-2147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第75到79行，我们将当前的最高分以及最高得分者的名字保存到文件中。这可能是一个新分数，也可能是我们在程序开始时读取的先前值。
- en: Study Drills
  id: totrans-2148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Change the program so that it only saves to the high score file if it has changed.
  id: totrans-2149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改程序，只有在高分发生变化时才保存到高分文件。
- en: “Hack” the high score file by opening it in a text editor and manually changing
    it. Impress your friends with your amazing lucky streak!
  id: totrans-2150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在文本编辑器中打开高分文件并手动更改它来“黑客”高分文件。用您惊人的幸运连胜给朋友留下深刻印象！
- en: 'Exercise 44: Counting with a For Loop'
  id: totrans-2151
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习44：使用for循环计数
- en: As you have seen in previous exercises, `while`  loops and do­while loops can
    be used to to make something happen more than once.
  id: totrans-2152
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您在以前的练习中看到的，`while`循环和do-while循环可以用来多次执行某些操作。
- en: '[PRE526]'
  id: totrans-2153
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE526]'
- en: '[PRE527]'
  id: totrans-2154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-2155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-2156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-2157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE530]'
- en: '[PRE531]'
  id: totrans-2158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-2159
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-2160
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE533]'
- en: 'But both kinds of loops are designed to keep going as long as something is
    true. If we know in advance how many times we want to do something, Java has a
    special kind of loop designed just for making a variable change values: the `for`  loop.'
  id: totrans-2161
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，这两种循环都设计成只要条件为真就继续进行。如果我们事先知道要做某事的次数，Java有一种专门设计用于改变变量值的循环：`for`循环。
- en: What You Should See
  id: totrans-2162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您应该看到的内容
- en: '[PRE534]'
  id: totrans-2163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-2164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-2165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE536]'
- en: '[PRE537]'
  id: totrans-2166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-2167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-2168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-2169
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-2170
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE541]'
- en: Line 16 demonstrates a very basic `for`  loop. Every `for`  loop has three parts
    with semicolons between.
  id: totrans-2171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第16行演示了一个非常基本的`for`循环。每个`for`循环都有三个部分，它们之间用分号分隔。
- en: The first part (`n=1`) only happens once no matter how many times the loop repeats.
    It happens at the very beginning of the loop and usually sets a starting value
    for some variable that is going to be used to control the loop. In this case,
    our “loop control variable” is n and it will start with a value of `1`.
  id: totrans-2172
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一部分（`n=1`）无论循环重复多少次，都只会发生一次。它发生在循环的最开始，并且通常为将要用于控制循环的某个变量设置一个起始值。在这种情况下，我们的“循环控制变量”是n，它将以`1`的值开始。
- en: The second part (`n <= 5`) is a condition, just like the condition of a `while`  or
    do­while loop. The `for`  loop is a pre­test loop just like a `while`  loop, which
    means that this condition is tested before the loop starts looping. If the condition
    is true, the loop body will be executed one time. If the condition is false, the
    loop body will be skipped and the loop is over.
  id: totrans-2173
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第二部分（`n <= 5`）是一个条件，就像`while`或do-while循环的条件一样。`for`循环是一个前测试循环，就像`while`循环一样，这意味着在循环开始之前会测试这个条件。如果条件为真，循环体将执行一次。如果条件为假，循环体将被跳过，循环结束。
- en: The third part (`n++`) runs after each iteration of the loop, just before it
    checks the condition again. Remember that `++`  adds one to a variable.
  id: totrans-2174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第三部分（`n++`）在每次循环迭代之后运行，就在再次检查条件之前。请记住，`++`会将变量加一。
- en: 'So if we *unroll* this loop, these are the statements that will happen and
    their order:'
  id: totrans-2175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，如果我们*展开*这个循环，这些语句将会发生并按顺序执行：
- en: '[PRE542]'
  id: totrans-2176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE542]'
- en: Notice that the first part only happened once, and that the third part happened
    exactly as many times as the loop body did.
  id: totrans-2177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，第一部分只发生了一次，第三部分发生的次数正好与循环体发生的次数一样多。
- en: On line 22 there is another `for`  loop. The loop control variable is still
    n. (Notice that the loop control variable appears in all three parts of the loop.
    This is almost always the case.)
  id: totrans-2178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第22行有另一个`for`循环。循环控制变量仍然是n。（请注意，循环控制变量出现在循环的所有三个部分中。这几乎总是这种情况。）
- en: The first part (the “initialization expression”) sets the loop control variable
    to start at `5`. Then the second part checks to see if n is less than or equal
    to `50`. If so, the body is executed one time and then the third part is executed.
    The third part adds `5`  to the loop control variable, and then the condition
    is checked again. If it is still true, the loop repeats. Once it is false, the
    loop stops.
  id: totrans-2179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一部分（“初始化表达式”）将循环控制变量设置为`5`。然后第二部分检查n是否小于或等于`50`。如果是，循环体将执行一次，然后执行第三部分。第三部分将`5`添加到循环控制变量中，然后再次检查条件。如果条件仍然为真，循环将重复。一旦条件为假，循环停止。
- en: On line 28 there is one final `for`  loop. This time the loop control variable
    starts at `3`  and the loop repeats as long as n is greater than zero. And after
    each iteration of the loop body the third part (the “update expression”) subtracts
    `1`  from the loop control variable.
  id: totrans-2180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第28行有一个最后的`for`循环。这次循环控制变量从`3`开始，只要n大于零，循环就会重复。并且在循环体的每次迭代之后，第三部分（“更新表达式”）会从循环控制变量中减去`1`。
- en: So when should you use a `for`  loop versus a `while`  loop?
  id: totrans-2181
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那么何时应该使用`for`循环而不是`while`循环？
- en: '`for`  loops are best when we know in advance how many times we want to do
    something.'
  id: totrans-2182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们事先知道要做某事的次数时，最好使用`for`循环。
- en: Do this ten times.
  id: totrans-2183
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做这件事十次。
- en: Do this five times.
  id: totrans-2184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做这件事五次。
- en: Pick a random number, and do it that many times.
  id: totrans-2185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个随机数，并执行相应次数。
- en: Take this list of items, and do it one time for each item in the list.
  id: totrans-2186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拿这个物品清单，对列表中的每个物品执行一次。
- en: 'On the other hand, `while`  and do­while loops are best for repeating as long
    as something is true:'
  id: totrans-2187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一方面，`while`和do-while循环最适合在条件为真时重复执行：
- en: Keep going as long as they haven’t guessed it.
  id: totrans-2188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要他们没有猜到，就继续进行。
- en: Keep going as long as you haven’t got doubles.
  id: totrans-2189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要你没有得到对子，就继续进行。
- en: Keep going as long as they keep typing in a negative number.
  id: totrans-2190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要他们继续输入负数，就继续进行。
- en: Keep going as long as they haven’t typed in a zero.
  id: totrans-2191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要他们没有输入零，就继续进行。
- en: Study Drills
  id: totrans-2192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: 1\. Delete the first part (the “initialization expression”) from the third loop.
    If you remove it correctly, it will still compile. What happens when you run it?
  id: totrans-2193
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 从第三个循环中删除第一部分（“初始化表达式”）。如果您正确删除它，它仍将编译。当您运行它时会发生什么？
- en: 'Exercise 45: Caesar Cipher (Looping Through a String)'
  id: totrans-2194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习45：凯撒密码（遍历字符串）
- en: The Caesar cipher is a very simple form of cryptography named after Julius Caesar,
    who used it to protect his private letters. In the cipher, each letter is shifted
    up or down in the alphabet by a certain amount. For example, if the shift is `2`,
    then all `A`s in the message are replaced with `C`, `B`  is replaced with `D`,
    and so on.
  id: totrans-2195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 凯撒密码是一种非常简单的密码学形式，以朱利叶斯·凯撒命名，他用它来保护他的私人信件。在密码中，每个字母都会按照字母表中的某个数量上下移动。例如，如果移位是`2`，那么消息中的所有`A`都会被替换为`C`，`B`被替换为`D`，依此类推。
- en: 1 import java.util.Scanner; 2
  id: totrans-2196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 import java.util.Scanner; 2
- en: 3 public class CaesarCipher
  id: totrans-2197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 public class CaesarCipher
- en: 4 {
  id: totrans-2198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 4 {
- en: '5'
  id: totrans-2199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: /**
  id: totrans-2200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: /**
- en: '6'
  id: totrans-2201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '* Returns the character shifted by the given number of letters.'
  id: totrans-2202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*返回移动了给定字母数的字符。'
- en: '7'
  id: totrans-2203
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: '*/'
  id: totrans-2204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*/'
- en: '8'
  id: totrans-2205
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: public static char shiftLetter( char c, int n )
  id: totrans-2206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static char shiftLetter(char c, int n)
- en: '9'
  id: totrans-2207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: '{'
  id: totrans-2208
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '10'
  id: totrans-2209
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: int ch = c;
  id: totrans-2210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: int ch = c;
- en: '11'
  id: totrans-2211
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-2212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: if ( ! Character.isLetter(c) )
  id: totrans-2213
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (!Character.isLetter(c))
- en: '13'
  id: totrans-2214
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: return c;
  id: totrans-2215
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回c;
- en: '14'
  id: totrans-2216
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-2217
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: ch = ch + n;
  id: totrans-2218
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch = ch + n;
- en: '16'
  id: totrans-2219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: if ( Character.isUpperCase(c) && ch > 'Z' || Character.isLowerCase(c) && ch
    > 'z' )
  id: totrans-2220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (Character.isUpperCase(c) && ch > 'Z' || Character.isLowerCase(c) && ch >
    'z')
- en: '17'
  id: totrans-2221
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: ch ­= 26;
  id: totrans-2222
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch ­= 26;
- en: '18'
  id: totrans-2223
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: if ( Character.isUpperCase(c) && ch < 'A' || Character.isLowerCase(c) && ch
    < 'a' )
  id: totrans-2224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if (Character.isUpperCase(c) && ch < 'A' || Character.isLowerCase(c) && ch <
    'a')
- en: '19'
  id: totrans-2225
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: ch += 26;
  id: totrans-2226
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ch += 26;
- en: '20'
  id: totrans-2227
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-2228
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: return (char)ch;
  id: totrans-2229
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return (char)ch;
- en: '22'
  id: totrans-2230
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '22'
- en: '}'
  id: totrans-2231
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '23'
  id: totrans-2232
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '23'
- en: '24'
  id: totrans-2233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '24'
- en: public static void main( String[] args )
  id: totrans-2234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main(String[] args)
- en: '25'
  id: totrans-2235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '25'
- en: '{'
  id: totrans-2236
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '26'
  id: totrans-2237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '26'
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-2238
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scanner keyboard = new Scanner(System.in);
- en: '27'
  id: totrans-2239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '27'
- en: String plaintext, cipher = "";
  id: totrans-2240
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: String plaintext, cipher = "";
- en: '28'
  id: totrans-2241
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '28'
- en: int shift;
  id: totrans-2242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: int shift;
- en: '29'
  id: totrans-2243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '29'
- en: '30'
  id: totrans-2244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '30'
- en: 'System.out.print("Message: ");'
  id: totrans-2245
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'System.out.print("Message: ");'
- en: '31'
  id: totrans-2246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '31'
- en: plaintext = keyboard.nextLine();
  id: totrans-2247
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: plaintext = keyboard.nextLine();
- en: '32'
  id: totrans-2248
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '32'
- en: 'System.out.print("Shift (0­26): ");'
  id: totrans-2249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'System.out.print("Shift (0­26): ");'
- en: '33'
  id: totrans-2250
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '33'
- en: shift = keyboard.nextInt();
  id: totrans-2251
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: shift = keyboard.nextInt();
- en: '34'
  id: totrans-2252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '34'
- en: '35'
  id: totrans-2253
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '35'
- en: for ( int i=0; i<plaintext.length(); i++ )
  id: totrans-2254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for (int i=0; i<plaintext.length(); i++)
- en: '36'
  id: totrans-2255
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '36'
- en: '{'
  id: totrans-2256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '37'
  id: totrans-2257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '37'
- en: cipher += shiftLetter( plaintext.charAt(i), shift );
  id: totrans-2258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: cipher += shiftLetter(plaintext.charAt(i), shift);
- en: '38'
  id: totrans-2259
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '38'
- en: '}'
  id: totrans-2260
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '39'
  id: totrans-2261
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '39'
- en: System.out.println( cipher );
  id: totrans-2262
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println(cipher);
- en: '40'
  id: totrans-2263
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '40'
- en: '41'
  id: totrans-2264
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '41'
- en: '}'
  id: totrans-2265
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '42'
  id: totrans-2266
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '42'
- en: '}'
  id: totrans-2267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: What You Should See
  id: totrans-2268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE543]'
  id: totrans-2269
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE543]'
- en: Did you know that `main()`  doesn’t have to be the first function in the class?
    Well, it doesn’t. Functions can appear in any order.
  id: totrans-2270
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你知道`main()`不一定要是类中的第一个函数吗？好吧，它不是。函数可以以任何顺序出现。
- en: 'Also in addition to `int`, `double`, `String`  and `boolean`  there is a basic
    variable type I haven’t mentioned: `char`. A `char`  variable can hold characters
    like `String`s do, but it can only hold one character at a time. String literals
    in the code are enclosed in double quotes like `"Axe"`, while `char`  literals
    in the code are in single quotes like `''A''`.'
  id: totrans-2271
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了`int`，`double`，`String`和`boolean`之外，还有一种基本的变量类型我没有提到：`char`。`char`变量可以像`String`一样保存字符，但一次只能保存一个字符。代码中的字符串文字用双引号括起来，如`"Axe"`，而代码中的`char`文字用单引号括起来，如`'A'`。
- en: 'Starting on line 8 there is a function called `shiftLetter()`. It has two parameters:
    c is the character to shift and n is the number of spaces to shift it. This function
    returns a `char`. So `shiftLetter(''A'', 2)`  would return the character `''C''`.'
  id: totrans-2272
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从第8行开始有一个名为`shiftLetter()`的函数。它有两个参数：c是要移动的字符，n是要移动的空格数。这个函数返回一个`char`。所以`shiftLetter('A',
    2)`将返回字符`'C'`。
- en: We don’t want to try to shift anything that isn’t a letter, so on line 10 we
    use the built­in Character class
  id: totrans-2273
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不想尝试移动任何不是字母的东西，所以在第10行我们使用内置的Character类
- en: to tell us.
  id: totrans-2274
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 告诉我们。
- en: Then we are going to be doing a little math with the character, so we store
    the character’s Unicode value into an `int`  on line 13 to make this easier. Then
    on line 15 we add the desired offset to the character.
  id: totrans-2275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们将对字符进行一些简单的数学运算，所以我们在第13行将字符的Unicode值存储到一个`int`中，以便更容易进行操作。然后在第15行，我们将所需的偏移量添加到字符上。
- en: This would be it, except that we want the offset to “wrap around”, so lines
    16 through 19 make sure that the final value is still a letter. Then finally on
    line 21 we take the value of ch, cast it to a `char`, and return it.
  id: totrans-2276
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这就是它，除了我们希望偏移“环绕”，所以第16到19行确保最终值仍然是一个字母。最后在第21行，我们取ch的值，将其转换为`char`，并返回它。
- en: 'In `main()`, lines 27 through 34 are pretty boring. Before I can explain the
    `for`  loop, though, I need to explain two `String`  class methods: `charAt()`  and
    `length()`.'
  id: totrans-2277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`main()`中，第27到34行非常无聊。在我解释`for`循环之前，我需要解释两个`String`类方法：`charAt()`和`length()`。
- en: 'If you have a `String`  you can get a single `char`  out of it using the `charAt()`  method.
    Like so:'
  id: totrans-2278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你有一个`String`，你可以使用`charAt()`方法从中获取一个单独的`char`。就像这样：
- en: '[PRE544]'
  id: totrans-2279
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '`charAt()`  is zero­based, so `s.charAt(0)`  gets the first character out of
    a String s. And if `s.length()`  tells you how many characters there are in s,
    then `s.charAt( s.length()­1 )`  gets the final character.'
  id: totrans-2280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`charAt()`是从零开始的，所以`s.charAt(0)`从字符串s中获取第一个字符。如果`s.length()`告诉你s中有多少个字符，那么`s.charAt(s.length()­1)`获取最后一个字符。'
- en: Now we can understand the `for`  loop on line 36\. The initialization expression
    declares and a loop control variable i and sets it equal to `0`. The condition
    goes as long as i is less than the number of characters in the message. And the
    update expression will add `1`  to i each time.
  id: totrans-2281
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们可以理解第36行的`for`循环了。初始化表达式声明并设置了一个循环控制变量i，将其设置为`0`。条件是只要i小于消息中的字符数。更新表达式将每次将`1`添加到i。
- en: On line 38, a lot of things are happening. We use the `charAt`  method to pull
    out only the i­th character of the message. That character and the shift value
    are passed as arguments to the `shiftLetter()`  function, which returns the shifted
    letter. And finally that shifted letter is tacked on to the end of the String
    cipher.
  id: totrans-2282
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第38行，发生了很多事情。我们使用`charAt`方法只提取消息的第i个字符。该字符和移位值作为参数传递给`shiftLetter()`函数，该函数返回移位后的字母。最后，该移位后的字母被添加到String
    cipher的末尾。
- en: By the time the loop ends, it has gone through each letter of the message one
    at a time and built up a new message from the shifted versions of the letters.
  id: totrans-2283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当循环结束时，它已经逐个遍历了消息的每个字母，并从字母的移位版本中构建了一个新的消息。
- en: Maybe that was too much at once. Let me know.
  id: totrans-2284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也许这一次太多了。让我知道。
- en: Study Drills
  id: totrans-2285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演练
- en: Make a new version of this exercise that gets the message from a text file instead
    and creates an “encrypted” file with the ciphertext instead of just printing it
    on the screen.
  id: totrans-2286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作这个练习的新版本，从文本文件中获取消息，并创建一个“加密”文件，而不仅仅是在屏幕上打印它。
- en: 'Exercise 46: Nested For Loops'
  id: totrans-2287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习46：嵌套for循环
- en: '[PRE545]'
  id: totrans-2288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-2289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-2290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-2291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE548]'
- en: '[PRE549]'
  id: totrans-2292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE549]'
- en: In programming, the term “nested” usually means to put something inside the
    same thing. “Nested loops” would be two loops with one inside the other one. If
    you do it right, then means the inner loop will repeat all its iterations every
    time the outer loop does one more iteration.
  id: totrans-2293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编程中，“嵌套”一词通常意味着将某物放在同一物体内。“嵌套循环”将是两个循环，一个在另一个内部。如果你做对了，那么内部循环将在外部循环执行一次迭代时重复所有迭代。
- en: What You Should See
  id: totrans-2294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE550]'
  id: totrans-2295
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE550]'
- en: Study Drills
  id: totrans-2296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Look at the first set of nested loops (“CN”). Which variable changes faster?
    Is it the variable
  id: totrans-2297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看嵌套循环的第一组（“CN”）。哪个变量变化更快？是变量
- en: controlled by the outer loop (c) or the variable controlled by the inner loop
    (n)?
  id: totrans-2298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由外部循环（c）控制还是由内部循环（n）控制的变量？
- en: Change the order of the loops so that the “c” loop is on the inside and the
    “n” loop is on the outside. How does the output change?
  id: totrans-2299
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改循环的顺序，使“c”循环在内部，“n”循环在外部。输出如何改变？
- en: Look at the second set of nested loops (“AB”). Change the `print()`  statement
    to `println()`. How does the output change? (Then change it back to `print()`.)
  id: totrans-2300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看第二组嵌套循环（“AB”）。将`print（）`语句更改为`println（）`。输出如何改变？（然后将其改回`print（）`。）
- en: Add a `System.out.println()`  statement after the close brace of the inner loop
    (the “b” loop), but still inside the outer loop. How does the output change?
  id: totrans-2301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在内部循环（“b”循环）的关闭大括号后添加一个`System.out.println（）`语句，但仍在外部循环内。输出如何改变？
- en: 'Exercise 47: Generating and Filtering Values'
  id: totrans-2302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习47：生成和过滤值
- en: Nested `for`  loops are sometimes handy because they are very compact and can
    make some variables change through a lot of different combinations of values.
  id: totrans-2303
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌套的`for`循环有时很方便，因为它们非常紧凑，可以使一些变量通过许多不同的值组合进行更改。
- en: 'Many years ago, a student posed the following math problem to me:'
  id: totrans-2304
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多年前，一名学生向我提出了以下数学问题：
- en: “Farmer Brown wants to spend exactly $100.00 and wants to purchase exactly 100
    animals. If sheep cost $10 each, goats cost $3.50 each and chickens are $0.50
    apiece, then how many of each animal should he buy?”
  id: totrans-2305
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: “布朗农场主想要花费100.00美元，并且想要购买确切的100只动物。如果每只羊的成本为10美元，每只山羊的成本为3.50美元，每只鸡的成本为0.50美元，那么他应该购买多少只动物？”
- en: After he left, I thought about it for a few seconds and then wrote the following
    program.
  id: totrans-2306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 他离开后，我想了几秒钟，然后写了以下程序。
- en: '[PRE551]'
  id: totrans-2307
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-2308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-2309
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-2310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-2311
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE555]'
- en: What You Should See
  id: totrans-2312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE556]'
  id: totrans-2313
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE556]'
- en: This program is neat because it is very short. But an observer sitting inside
    the innermost loop (just in front of the `if`  statement on line 11 will see one
    million different combinations of s, g and c flow by. The first combination attempted
    will be 1 sheep, 1 goat, 1 chicken. That will be plugged into the math equations
    in the `if`  statement. They won’t be true, and nothing will be printed.
  id: totrans-2314
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个程序很整洁，因为它非常简短。但是，坐在最内部循环内（在第11行的`if`语句前面）的观察者将看到一百万种不同的s、g和c组合。尝试的第一个组合将是1只羊，1只山羊，1只鸡。这将被插入到`if`语句中的数学方程式中。它们不会是真的，也不会打印任何东西。
- en: Then the next combination will be 1 sheep, 1 goat and 2 chickens. Which will
    also fail. Then 1 sheep, 1 goat, 3 chickens. And so on up to 1 sheep, 1 goat and
    100 chickens when the inner loop runs its last iteration.
  id: totrans-2315
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后下一个组合将是1只羊，1只山羊和2只鸡。这也会失败。然后是1只羊，1只山羊，3只鸡。等等，直到1只羊，1只山羊和100只鸡，当内部循环运行最后一次迭代时。
- en: Then the `g++`  on line 7 will execute, the condition on line 7 will check to
    make sure g is still less than or equal to 100 (which it is) and the body of the
    middle `for`  loop will execute again.
  id: totrans-2316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，第7行的`g ++`将执行，第7行的条件将检查g是否仍然小于或等于100（是的），并且中间`for`循环的主体将再次执行。
- en: This will cause the initialization expression of the innermost loop to run again,
    which resets c to 1\. So the next combination of variable that will be tested
    in the `if`  statement is 1 sheep, 2 goats and 1 chicken. Then 1 sheep, 2 goats,
    2 chickens, then 1 sheep, 2 goats, 3 chickens. Et cetera.
  id: totrans-2317
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致最内层循环的初始化表达式再次运行，将c重置为1。因此，在`if`语句中将测试的下一个变量组合是1只羊，2只山羊和1只鸡。然后是1只羊，2只山羊，2只鸡，然后是1只羊，2只山羊，3只鸡。依此类推。
- en: By the end all 100 * 100 * 100 combinations have been tested and 999,999 of
    them failed. But because computers are very fast, the answer appears instantaneously.
  id: totrans-2318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到最后，所有100 * 100 * 100种组合都经过了测试，其中999,999种失败了。但是因为计算机非常快，答案立即出现。
- en: Since curly braces are optional in Java when there is only a single line of
    code in the body of an `if`
  id: totrans-2319
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于在`if`的主体中只有一行代码时，Java中的大括号是可选的
- en: 1 public class FarmerBrownCompact 2 {
  id: totrans-2320
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 public class FarmerBrownCompact 2 {
- en: '3'
  id: totrans-2321
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-2322
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-2323
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-2324
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-2325
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-2326
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-2327
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: public static void main( String[] args )
  id: totrans-2328
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main（String[] args）
- en: '{'
  id: totrans-2329
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: for ( int s = 1 ; s <= 100 ; s++ )
  id: totrans-2330
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于（int s = 1; s <= 100; s ++）
- en: for ( int g = 1 ; g <= 100 ; g++ )
  id: totrans-2331
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于（int g = 1; g <= 100; g ++）
- en: for ( int c = 1 ; c <= 100 ; c++ )
  id: totrans-2332
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于（int c = 1; c <= 100; c ++）
- en: if ( s+g+c == 100 && 10.00*s + 3.50*g + 0.50*c == 100.00 )
  id: totrans-2333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果（s + g + c == 100 && 10.00 * s + 3.50 * g + 0.50 * c == 100.00）
- en: System.out.println( s + " sheep, " + g + " goats, and " + c + "
  id: totrans-2334
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println（s +“只羊，”+ g +“只山羊和”+ c +“只
- en: chickens." ); 10 }
  id: totrans-2335
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小鸡。“）; 10 }
- en: 11 }
  id: totrans-2336
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 11 }
- en: 'statement or in the body of a `for`  loop, I could have made the code even
    more compact:'
  id: totrans-2337
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`if`的主体或`for`循环的主体中，我可以使代码更加紧凑：
- en: 'This is perfectly legal and behaves identically to the previous version. Compare
    that to how much code we would have to write if we had solved this program with
    `while`  loops instead of `for`  loops:'
  id: totrans-2338
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是完全合法的，并且与以前的版本行为完全相同。将其与我们使用`while`循环而不是`for`循环解决此程序时需要编写多少代码进行比较：
- en: '[PRE557]'
  id: totrans-2339
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-2340
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-2341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-2342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-2343
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE561]'
- en: The `while`  loop version is also more fragile because it would be easy to accidentally
    forget to reset a variable to `1`  or to increment it at the end of the loop body.
    Doing this with `while`  loops might be easier to get to compile but it is more
    likely to have subtle logical errors that compile but don’t work as intended.
  id: totrans-2344
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`while`循环版本也更加脆弱，因为很容易忘记将变量重置为`1`或在循环体的末尾递增它。使用`while`循环可能更容易编译，但更有可能出现细微的逻辑错误，编译后却不能按预期工作。'
- en: Study Drills
  id: totrans-2345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: 1\. Our code works, but it is not as efficient as it could be. (For example,
    there is no reason to make the “sheep” loop try 11 or 12 or more sheep because
    we can’t afford them. See if you can change the loop bounds to make the combinations
    less wasteful.
  id: totrans-2346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1.我们的代码可以运行，但不够高效。（例如，没有理由让“sheep”循环尝试11只或12只或更多的羊，因为我们买不起。看看你是否可以改变循环边界，使组合更少浪费。
- en: 'Exercise 48: Arrays ­ Many Values in a Single Variable'
  id: totrans-2347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习48：数组-单个变量中的多个值
- en: In this exercise you will learn two new things. The first one is *super* important
    and the second one is just kind­of neat.
  id: totrans-2348
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个练习中，你将学到两件新事物。第一件事*非常*重要，第二件事只是有点有趣。
- en: '[PRE562]'
  id: totrans-2349
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE562]'
- en: '[PRE563]'
  id: totrans-2350
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-2351
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-2352
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE565]'
- en: In Java, an “array” is a type of variable with one name (“identifier”) but containing
    more than one variable. In my opinion, you’re not a Real Programmer until you
    can work with arrays. So, that’s good news. You’re almost there!
  id: totrans-2353
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Java中，“数组”是一种类型的变量，它有一个名称（“标识符”），但包含多个变量。在我看来，只有当你能够处理数组时，你才能成为一个真正的程序员。所以，这是个好消息。你快要成功了！
- en: What You Should See
  id: totrans-2354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE566]'
  id: totrans-2355
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE566]'
- en: 'On line 5 we declare and define a variable named *planets*. It is not just
    a String: notice the square brackets. This variable is an *array* of Strings.
    That means that this one variable holds all eight of those Strings and they are
    separated into distinct slots so we can access them one at a time.'
  id: totrans-2356
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第5行，我们声明并定义了一个名为*planets*的变量。它不仅仅是一个字符串：注意方括号。这个变量是一个字符串数组。这意味着这个变量包含了所有八个字符串，并且它们被分成不同的槽，所以我们可以逐个访问它们。
- en: The curly braces on this line are used for a different purpose than usual. All
    these values are in quotes because they are Strings. There are commas between
    each value, then the whole initializer list is in curly braces. And there’s a
    semicolon at the end.
  id: totrans-2357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行上的花括号用于不同于通常的目的。所有这些值都在引号中，因为它们是字符串。每个值之间有逗号，然后整个初始化列表在花括号中。最后有一个分号。
- en: The second new thing in this exercise is a new kind of `for`  loop. (This is
    sometimes called a “foreach” loop, since it works a bit like a loop in another
    programming language where the keyword actually is `foreach`  instead of `for`.)
  id: totrans-2358
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习中的第二个新东西是一种新的`for`循环。（有时被称为“foreach”循环，因为它有点像另一种编程语言中的循环，那里的关键字实际上是`foreach`而不是`for`。）
- en: 'On line 7 you will see this foreach loop in action. You read it out loud like
    this: “for each String ‘p’ in the array ‘planets’….”'
  id: totrans-2359
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第7行，你将看到这个foreach循环在运行。你可以这样大声朗读：“对于数组‘planets’中的每个字符串‘p’……”
- en: So inside the body of this foreach loop the String variable p will take on a
    copy of the value of each value in the String array planets. That is, the first
    time through the loop, p will contain a copy of the first value in the array (`"Mercury"`).
    Then the second time through the loop, p will contain a copy of the second value
    in the array (`"Venus"`). And so on, until all the values in the array have been
    seen. Then the loop will automatically stop.
  id: totrans-2360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在这个foreach循环的循环体内，字符串变量p将获得字符串数组planets中每个值的副本。也就是说，第一次循环时，p将包含数组中的第一个值（“Mercury”）的副本。然后第二次循环时，p将包含数组中的第二个值（“Venus”）的副本。依此类推，直到数组中的所有值都被看到。然后循环将自动停止。
- en: Inside the body of the loop (on line 9) we are just printing out the current
    value of *p* and an uppercase version of *p*. Just for fun, I guess.
  id: totrans-2361
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在循环体内（第9行），我们只是打印出*p*的当前值和*p*的大写版本。可能只是为了好玩。
- en: 'This new kind of `for`  loop only works with compound variables like this:
    variables that have one name'
  id: totrans-2362
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种新的`for`循环只适用于像这样的复合变量：只有一个名称的变量。
- en: but contain multiple values. Arrays aren’t the only sort of compound variable
    in Java, but we won’t be looking at any of the others in this book.
  id: totrans-2363
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但包含多个值。数组不是Java中唯一的复合变量，但我们在本书中不会研究其他任何复合变量。
- en: Arrays are a big deal, so that’s enough for this exercise. I want to make *absolutely
    sure* you understand what is happening in this assignment before throwing more
    on your plate.
  id: totrans-2364
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组很重要，所以这就够了。在给你增加更多内容之前，我想要*绝对确定*你理解了这个任务中发生的事情。
- en: 'Exercise 49: Finding Things in an Array'
  id: totrans-2365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习49：在数组中查找东西
- en: '[PRE567]'
  id: totrans-2366
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-2367
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-2368
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-2369
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-2370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE571]'
- en: '[PRE572]'
  id: totrans-2371
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-2372
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-2373
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-2374
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE575]'
- en: More with arrays! In this exercise we will examine how to find a particular
    value. The technique we are using here is sometimes called a “linear search” because
    it starts with the first slot of the array and looks there, then moves to the
    second slot, then the third and so on down the line.
  id: totrans-2375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于数组的内容！在这个练习中，我们将研究如何找到特定的值。我们在这里使用的技术有时被称为“线性搜索”，因为它从数组的第一个槽开始查找，然后移动到第二个槽，然后是第三个，依此类推。
- en: What You Should See
  id: totrans-2376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的内容
- en: '[PRE576]'
  id: totrans-2377
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE576]'
- en: This time the array is named orderNumbers and it is an array of integers. It
    has seven slots. `12345`  is the first slot, and `271828`  is in the last slot
    of the array. Each of the seven slots can hold an integer.
  id: totrans-2378
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次数组的名称是orderNumbers，它是一个整数数组。它有七个槽。`12345`是第一个槽，`271828`在数组的最后一个槽。这七个槽中的每一个都可以容纳一个整数。
- en: When we create an array Java gives us a built­in variable which tells us the
    capacity of the array. This variable is read­only (you can retrieve its value
    but not change it) and is called `.length`. In this case, since the array orderNumbers
    has seven slots, the variable `orderNumbers.length`  is equal to `7`. This is
    used on line 12.
  id: totrans-2379
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们创建一个数组时，Java会给我们一个内置变量，告诉我们数组的容量。这个变量是只读的（你可以检索它的值，但不能改变它），被称为`.length`。在这种情况下，由于数组orderNumbers有七个槽，变量`orderNumbers.length`等于`7`。这在第12行中使用。
- en: On line 15 we have a foreach loop to display all the order numbers on the screen.
    “For each integer ‘num’ in the array ‘orderNumbers’….” So inside the body of this
    loop, *num* will take on each value in the array one at a time and display them
    all.
  id: totrans-2380
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第15行，我们有一个foreach循环，以在屏幕上显示所有订单号。 “对于数组`orderNumbers`中的每个整数‘num’...”。因此，在此循环的主体中，*num*将逐个接受数组中的每个值，并将它们全部显示出来。
- en: On line 22 we let the human type in an order number. Then we use the loop to
    let *num* take on each
  id: totrans-2381
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第22行，我们让人类输入订单号。然后我们使用循环让*num*逐个接受每个
- en: order number and compare them to *toFind* one at a time. When we have a match,
    we say so.
  id: totrans-2382
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 订单号并将它们与*toFind*逐个比较。当我们找到匹配时，我们会这样说。
- en: (You have to imagine that we have hundreds or thousands of orders in the database
    instead of just seven and that we print out more than just the order number when
    we find a match. We’ll be getting there soon enough.)
  id: totrans-2383
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （你必须想象我们的数据库中有数百或数千个订单，而不仅仅是七个，当我们找到匹配时，我们会打印出更多内容。我们很快就会到那里。）
- en: Study Drills
  id: totrans-2384
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: We created an `int`  called num inside both foreach loops. Could we have just
    declared the variable once up on line 10 and then removed the `int`  from both
    loops? Try it and see.
  id: totrans-2385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在两个foreach循环中都创建了一个名为num的`int`。我们是否可以只在第10行声明变量一次，然后从两个循环中删除`int`？试一试看看。
- en: Try to change the code so that if the order number is *not* found, it prints
    out a single message saying so. This is tricky. Even if you aren’t successful,
    give it a good effort before moving on to the next exercise.
  id: totrans-2386
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试更改代码，以便如果未找到订单号，则打印出一条单一消息。这很棘手。即使您没有成功，也要努力尝试，然后再进行下一个练习。
- en: 'Exercise 50: Saying Something Is NOT in an Array'
  id: totrans-2387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习50：说数组中没有某个东西
- en: In life, there is a general lack of symmetry between certain types of statements.
  id: totrans-2388
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在生活中，某些类型的陈述之间存在一般缺乏对称性。
- en: A white crow exists.
  id: totrans-2389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 存在一只白色的乌鸦。
- en: This statement is easy enough to prove. Start looking at crows. Once you find
    a white one, stop. Done.
  id: totrans-2390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个陈述很容易证明。开始观察乌鸦。一旦找到一只白色的，就停下。完成。
- en: No white crows exist.
  id: totrans-2391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不存在白色的乌鸦。
- en: This statement is *much* harder to prove because to prove it we have to gather
    up everything in the world that qualifies as a crow. If we have looked at them
    *all* and not found any white crows, only then can we safely say that *none* exist.
  id: totrans-2392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个陈述*要难得多，因为要证明它，我们必须收集世界上所有符合乌鸦资格的东西。如果我们已经*全部*看过它们，却没有找到任何白色的乌鸦，那么我们才能安全地说*没有*存在。
- en: 1 import java.util.Scanner; 2
  id: totrans-2393
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1 import java.util.Scanner; 2
- en: 3 public class ItemNotFound 4 {
  id: totrans-2394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3 public class ItemNotFound 4 {
- en: '5'
  id: totrans-2395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-2396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-2397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-2398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-2399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-2400
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-2401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-2402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-2403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '13'
- en: '14'
  id: totrans-2404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '14'
- en: '15'
  id: totrans-2405
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '15'
- en: '16'
  id: totrans-2406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '16'
- en: '17'
  id: totrans-2407
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '17'
- en: '18'
  id: totrans-2408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '18'
- en: '19'
  id: totrans-2409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '19'
- en: '20'
  id: totrans-2410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '20'
- en: '21'
  id: totrans-2411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '21'
- en: '22'
  id: totrans-2412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '22'
- en: '23'
  id: totrans-2413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '23'
- en: '24'
  id: totrans-2414
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '24'
- en: '25'
  id: totrans-2415
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '25'
- en: '26'
  id: totrans-2416
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '26'
- en: '27'
  id: totrans-2417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '27'
- en: '28'
  id: totrans-2418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '28'
- en: '29'
  id: totrans-2419
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '29'
- en: '30'
  id: totrans-2420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '30'
- en: '31'
  id: totrans-2421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '31'
- en: '32'
  id: totrans-2422
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '32'
- en: '33'
  id: totrans-2423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '33'
- en: '34'
  id: totrans-2424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '34'
- en: 35 }
  id: totrans-2425
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 35 }
- en: public static void main( String[] args )
  id: totrans-2426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: public static void main( String[] args )
- en: '{'
  id: totrans-2427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: Scanner keyboard = new Scanner(System.in);
  id: totrans-2428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scanner keyboard = new Scanner(System.in);
- en: String[] heroes = {
  id: totrans-2429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: String[] heroes = {
- en: '"Abderus", "Achilles", "Aeneas", "Ajax", "Amphitryon", "Bellerophon", "Castor",
    "Chrysippus", "Daedalus", "Diomedes", "Eleusis", "Eunostus", "Ganymede", "Hector",
    "Iolaus", "Jason",'
  id: totrans-2430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"阿布德鲁斯"，"阿喀琉斯"，"埃涅阿斯"，"阿贾克斯"，"安菲特里翁"，"贝勒福龙"，"卡斯特尔"，"克里西普"，"戴达罗斯"，"迪俄米德"，"埃琉西斯"，"尤诺斯图斯"，"盖尼米德"，"赫克托尔"，"伊阿索"，"贾森"，'
- en: '"Meleager", "Odysseus", "Orpheus", "Perseus", "Theseus" }; String guess;'
  id: totrans-2431
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"梅勒阿格尔"，"奥德修斯"，"奥耳佩斯"，"佩尔修斯"，"忒修斯"}; String guess;'
- en: boolean found;
  id: totrans-2432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: boolean found;
- en: 'System.out.print( "Pop Quiz! Name any mortal hero from Greek mythology: " );
    guess = keyboard.next();'
  id: totrans-2433
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.print( "小测验！说出希腊神话中的任何凡人英雄：" ); guess = keyboard.next();
- en: found = false;
  id: totrans-2434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: found = false;
- en: 'for ( String hero : heroes )'
  id: totrans-2435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'for ( String hero : heroes )'
- en: '{'
  id: totrans-2436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: if ( guess.equals(hero) )
  id: totrans-2437
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if ( guess.equals(hero) )
- en: '{'
  id: totrans-2438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "That's correct!" ); found = true;
  id: totrans-2439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "那是正确的！" ); found = true;
- en: '}'
  id: totrans-2440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: if ( found == false )
  id: totrans-2442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: if ( found == false )
- en: '{'
  id: totrans-2443
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: System.out.println( "No, " + guess + " wasn't a Greek mortal hero." );
  id: totrans-2444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: System.out.println( "不，" + guess + "不是希腊凡人英雄。" );
- en: '}'
  id: totrans-2445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-2446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: Hopefully you tried the study drill in yesterday’s exercise.
  id: totrans-2447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 希望您尝试了昨天练习中的学习演习。
- en: What You Should See
  id: totrans-2448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE577]'
  id: totrans-2449
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE577]'
- en: Most students want to solve this problem by putting another `if`  statement
    (or an `else`) inside the loop to say “not found”. But this can not work. If I
    want to know if something is found, it is okay to say so as soon as I find it.
    But if I want to know if something was never found, you have to wait until the
    loop is over before you know for sure.
  id: totrans-2450
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数学生希望通过在循环内部放置另一个`if`语句（或`else`）来解决这个问题，以表明“未找到”。但这是行不通的。如果我想知道是否找到了某物，那么一旦我找到它，就可以这样说。但是，如果我想知道某物从未被找到，您必须等到循环结束才能确定。
- en: So in this case I use a technique called a “flag”. A flag is a variable that
    starts with one value. The value is changed if something happens. Then later in
    the program you can use the value of the flag to see if the thing happened or
    not.
  id: totrans-2451
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以在这种情况下，我使用了一种称为“标志”的技术。标志是一个以一个值开始的变量。如果发生了某事，该值将被更改。然后在程序的后面，您可以使用标志的值来查看是否发生了该事件。
- en: My flag variable is a Boolean called found, which is set to `false`  on line
    20\. If a match is found, we say so and change the flag to `true`  on line 26\.
    Notice that inside the loop there is no code that can change the flag to `false`,
    so once it has been flipped to `true`  it will stay that way.
  id: totrans-2452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我的标志变量是一个名为found的布尔变量，在第20行设置为`false`。如果找到匹配，我们会这样做，并在第26行将标志更改为`true`。请注意，在循环内部没有可以将标志更改为`false`的代码，因此一旦它被翻转为`true`，它将保持不变。
- en: Then on line 30, after the loop is done, you can examine the flag. If it is
    still `false`, then we know the
  id: totrans-2453
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在第30行，在循环结束后，您可以检查标志。如果它仍然是`false`，那么我们知道
- en: '`if`  statement inside the loop was never true and therefore we never found
    what we were looking for.'
  id: totrans-2454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 循环内的`if`语句从未为真，因此我们从未找到我们要找的东西。
- en: 'Exercise 51: Arrays Without Foreach Loops'
  id: totrans-2455
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习51：没有foreach循环的数组
- en: As you might noticed by now, arrays and foreach loops are designed to work together
    well. But there are situations where what we have been doing won’t work.
  id: totrans-2456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如您现在可能已经注意到的那样，数组和foreach循环被设计为很好地配合使用。但也有一些情况下，我们一直在做的事情不起作用。
- en: A foreach loop can’t iterate through an array *backward*; it can only go forward.
  id: totrans-2457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: foreach循环无法*向后*迭代数组；它只能向前。
- en: A foreach loop can’t be used to change the values in the slots of the array.
    The foreach loop variable is a read­only copy of what’s in the array and changing
    it doesn’t change the array.
  id: totrans-2458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: foreach循环不能用来更改数组槽中的值。foreach循环变量是数组中的一个只读副本，更改它不会改变数组。
- en: 'In addition, we have only been putting values into an array using an initializer
    list (the curly braces thing), which has its own limitations:'
  id: totrans-2459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，我们一直在使用初始化列表（花括号的东西）将值放入数组中，这有其自身的局限性：
- en: An initializer list only works when the array is being declared; you can’t use
    it elsewhere in the code.
  id: totrans-2460
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化列表只在声明数组时有效；你不能在代码的其他地方使用它。
- en: An initializer list is best suited for relatively small arrays, if you have
    1000 values in the array, an initializer list will be no fun.
  id: totrans-2461
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化列表最适合相对较小的数组，如果数组中有1000个值，初始化列表就不好玩了。
- en: Initializer lists don’t help us if we want the values in the array to come from
    a file or some other place we don’t have when we are typing the code.
  id: totrans-2462
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们希望数组中的值来自文件或者我们在输入代码时没有的其他地方，初始化列表就帮不上忙了。
- en: '[PRE578]'
  id: totrans-2463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-2464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-2465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-2466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-2467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-2468
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-2469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE584]'
- en: So there is another way to store values in an array and access them. In fact,
    it is more common than what you have been doing. Using square brackets and a slot
    number, we can access the slots of an array individually.
  id: totrans-2470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以还有另一种方法可以存储数组中的值并访问它们。事实上，这种方法比你一直在做的更常见。使用方括号和槽号，我们可以单独访问数组的槽。
- en: '[PRE585]'
  id: totrans-2471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-2472
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-2473
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE587]'
- en: What You Should See
  id: totrans-2474
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE588]'
  id: totrans-2475
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE588]'
- en: On line 5 we are creating an array of integers without using an initializer
    list. The `[3]`  means that the array has a capacity of 3\. Since we didn’t provide
    values, every slot in the array starts out with a value of `0`  stored in it.
    Once an array has been created, its capacity can’t be changed.
  id: totrans-2476
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第5行，我们创建了一个整数数组，没有使用初始化列表。`[3]`表示数组的容量为3。由于我们没有提供值，数组中的每个槽最初都存有值`0`。一旦数组被创建，它的容量就不能改变。
- en: On lines 8 through 10 there is a surprise. The array has 3 slots, but the slot
    numbers are 0­based. (The number that refers to an array slot is called an “index”.
    Collectively these ought to be called “indices” (INN­duh­SEEZ) but most people
    just say “indexes”.)
  id: totrans-2477
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第8到10行有一个惊喜。数组有3个槽，但槽号是基于0的。（指代数组槽的数字称为“索引”。总体上应该称为“索引”（INN-duh-SEEZ），但大多数人只说“索引”）。
- en: So the first slot in an array is index `0`. This array can hold three values,
    so the last index is `2`. There is nothing you can do about this except get used
    to it. So `arr.length`  is `3`, but there is not a slot with index `3`. This will
    probably be a source of bugs for you at first, but eventually you will learn.
  id: totrans-2478
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以数组中的第一个槽是索引`0`。这个数组可以容纳三个值，所以最后一个索引是`2`。除了习惯它，你无法做任何事情。所以`arr.length`是`3`，但没有一个槽的索引是`3`。这可能会在一开始给你带来bug，但最终你会学会的。
- en: Anyway, lines 8 through 10 store the value `0`  into all three slots in the
    array. (Which is the value that was already in them, so this code doesn’t do anything
    useful.)
  id: totrans-2479
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何，第8到10行将值`0`存储到数组的所有三个槽中。（这个值已经在其中了，所以这段代码没有任何用处。）
- en: On line 12 we print out all three current values in the array so you can see
    that they’re all zero.
  id: totrans-2480
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第12行，我们打印出数组中所有三个当前值，这样你就可以看到它们都是零。
- en: On lines 15 through 17 we put random numbers into each slot of the array. And
    print them out again on line 20.
  id: totrans-2481
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第15到17行，我们将随机数放入数组的每个槽中。然后在第20行再次打印出来。
- en: Starting on line 22 I have done something silly. Try to withhold judgment until
    the end of the exercise.
  id: totrans-2482
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从第22行开始，我做了一些傻事。在练习结束之前，请不要下判断。
- en: Forgetting about why you might want to do it, do you see that line 24 is essentially
    identical to line 15? Line 24 stores a random number into a spot in the array.
    Which spot? The index depends on the current value of i. And i is currently `0`.
    So we are storing the random number into the slot with index `0`. Okay?
  id: totrans-2483
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不管你为什么要这样做，你看到第24行基本上与第15行相同吗？第24行将一个随机数存储到数组的一个位置。哪个位置？索引取决于i的当前值。而i当前是`0`。所以我们将随机数存储到索引为`0`的槽中。明白了吗？
- en: So on line 25 we change the value of i from `0`  to `1`. Then on line 26 we
    store a random value in the slot indexed by the value of i, so index `1`. Clear?
    Weird, but legal.
  id: totrans-2484
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以在第25行，我们将i的值从`0`改为`1`。然后在第26行，我们将一个随机值存储在由i的值索引的槽中，所以索引是`1`。明白了吗？奇怪，但合法。
- en: I have used similar shenanigans on lines 31 through 38 to display all the values
    on the screen again. Now, this is clearly objectively worse than what I was doing
    on line 20\. I mean, it took me 8 lines of code to do what I had been doing in
    one line. (Stay with me.)
  id: totrans-2485
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我在第31到38行使用了类似的花招来再次在屏幕上显示所有的值。现在，这显然比我在第20行做的要糟糕。我的意思是，我用了8行代码来做我之前用一行代码做的事情。（跟着我。）
- en: On lines 40 through 47 we do something that might even be worse than lines 22
    through 28\. Lines 41 and 42 are the same, but instead of putting a `1`  directly
    into i on line 43, I just say “increase the value of i by 1.” So i had contained
    a `0`; it contains a `1`  after line 43 is done.
  id: totrans-2486
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第40到47行，我们做的事情甚至可能比第22到28行更糟糕。第41和42行是一样的，但在第43行，我没有直接将`1`放入i，而是说“增加i的值1”。所以i原来是`0`；在第43行之后它变成了`1`。
- en: Pretty much the only advantage to this approach is that at least copy­and­paste
    is easier. Lines 42 and 43 are *literally identical* to lines 44 and 45\. And
    the same for lines 46 and 47\. I mean, like byte­for­byte the same.
  id: totrans-2487
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法的唯一优势几乎是复制和粘贴更容易。第42和43行*完全相同*于第44和45行。第46和47行也是如此。我的意思是，完全一样。
- en: We display them in a similar silly fashion on lines 50 through 58.
  id: totrans-2488
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们以类似的愚蠢方式在第50到58行显示它们。
- en: But then maybe it occurs to you. “Why would I bother to type the exact same
    lines three times in a row when I could just….” You know a thing that allows you
    to repeat a chunk of code while making a single variable increase by one each
    time, right?
  id: totrans-2489
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但也许你会想到。“为什么我要连续三次输入完全相同的行，而不是……”你知道一种允许你重复一段代码的东西，同时使一个变量每次增加一个的东西，对吧？
- en: 'That’s right: a `for`  loop is just the thing. Not so silly after all, am I?'
  id: totrans-2490
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 没错：`for`循环就是这样的。我一点都不傻，对吧？
- en: Lines 61 through 64 are the same as lines 41 through 47 except that we let the
    `for`  loop handle the repeating and the changing of the index. The initialization
    expression (the first part) of the `for`  loop sets i to start at `0`, which happens
    to be the smallest legal index for an array. The condition says “repeat this as
    long as i is less than `arr.length`  (which is `3`).” And note that that is less
    than, not less than or equal to, which would be too far. The update expression
    (the third part) just adds 1 to i each time.
  id: totrans-2491
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第61到64行与第41到47行相同，只是我们让`for`循环处理重复和索引的变化。`for`循环的初始化表达式（第一部分）将i设置为`0`，这恰好是数组的最小合法索引。条件说“只要i小于`arr.length`（即`3`）就重复这个操作。”请注意，这是小于，而不是小于或等于，那样就太多了。更新表达式（第三部分）每次只是将i加1。
- en: Lines 67 through 72 display the values on the screen.
  id: totrans-2492
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第67到72行显示了屏幕上的值。
- en: 'Here’s the thing: this sort of code on lines 61 through 72 might seem a little
    bit complex, but working with arrays in Java you end up writing code like this
    all the time. I cannot even tell you how many times I have written a `for`  loop
    just like that for working with an array.'
  id: totrans-2493
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 事实上，这种代码在61到72行之间可能看起来有点复杂，但在Java中使用数组时，你会一直写这样的代码。我甚至无法告诉你我有多少次为了处理数组而写了一个像那样的`for`循环。
- en: In fact, if your question is “How do I  an array?” (Fill in the blank with any
    task you like.) The answer is “With a `for`  loop.” Pretty much guaranteed.
  id: totrans-2494
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，如果你的问题是“我怎么才能一个数组？”（在空白处填入你喜欢的任何任务。）答案是“用`for`循环。”几乎可以肯定。
- en: Study Drills
  id: totrans-2495
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: 1\. At the top of the code, change it so the array has a capacity of 1000 instead
    of 3\. Don’t change any other code and recompile and run it again. Guess what?
    Those `for`  loops at the bottom might have been a little more work to write and
    to understand, but once written they work just as well for 1000 values as for
    3\. And that’s pretty cool.
  id: totrans-2496
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 1. 在代码的顶部，将数组的容量改为1000而不是3。不要改变任何其他代码，然后重新编译和运行。猜猜看？底部的那些`for`循环可能会更难写和理解，但一旦写好，它们对于1000个值和3个值一样有效。这很酷。
- en: 'Exercise 52: Lowest Temperature'
  id: totrans-2497
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习52：最低温度
- en: Before we move on from arrays, this exercise will pull together functions, loops,
    arrays and reading from files to do something (hopefully) interesting!
  id: totrans-2498
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们离开数组之前，这个练习将整合函数、循环、数组和从文件中读取数据，做一些（希望）有趣的事情！
- en: 'I have created a text file containing the average daily temperature in Austin,
    Texas from January 1, 1995 through June 23, 2013\. There are a few data points
    missing, so there are a total of 6717 temperatures in the file. You can see the
    numbers here:'
  id: totrans-2499
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我已经创建了一个文本文件，其中包含了1995年1月1日至2013年6月23日德克萨斯州奥斯汀市的平均日温度。文件中有一些数据点丢失，所以文件中共有6717个温度。你可以在这里看到这些数字：
- en: http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt
  id: totrans-2500
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt
- en: '[PRE589]'
  id: totrans-2501
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[8 double[] temps = arrayFromUrl("http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt");](http://learnjavathehardway.org/txt/avg)'
  id: totrans-2502
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[8 double[] temps = arrayFromUrl("http://learnjavathehardway.org/txt/avg­daily­temps­atx.txt");](http://learnjavathehardway.org/txt/avg)'
- en: '[PRE590]'
  id: totrans-2503
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-2504
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-2505
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-2506
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE593]'
- en: '[PRE594]'
  id: totrans-2507
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-2508
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-2509
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-2510
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE597]'
- en: '[PRE598]'
  id: totrans-2511
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-2512
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE599]'
- en: The values are in degrees Fahrenheit. This exercise will read all the values
    from the file (directly off the Internet, even) into an array of `double`s and
    then use a loop to find the lowest temperature in that entire 17­1/2 year range.
    Sound interesting? Let’s go.
  id: totrans-2513
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些值是以华氏度为单位。这个练习将把文件中的所有值（甚至直接从互联网上）读入一个`double`数组，然后使用循环来找到整个17年半范围内的最低温度。听起来有趣吗？让我们开始吧。
- en: What You Should See
  id: totrans-2514
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE600]'
  id: totrans-2515
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE600]'
- en: (If you have to run this program on a machine without Internet access, then
    the code won’t work. Since you know how to read from a text file already, you
    could modify it yourself to read from a local file (a file in the same folder
    as your code instead of on the Internet). But if you are lazy I have listed an
    alternate version down below.)
  id: totrans-2516
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果你必须在没有互联网访问权限的机器上运行这个程序，那么这段代码就行不通了。因为你已经知道如何从文本文件中读取数据，你可以自己修改它，让它从一个本地文件中读取（一个与你的代码在同一个文件夹中的文件，而不是在互联网上）。但如果你懒得动手，我在下面列出了一个备用版本。）
- en: Well, right off the bat I have thrown a curve ball. On line 8 we declare an
    array of `double`s named
  id: totrans-2517
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嗯，一开始我就扔了一个曲线球。在第8行，我们声明了一个名为`double`的数组
- en: 'temps, but instead of just doing the normal thing and setting its capacity
    like this:'
  id: totrans-2518
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 温度，但是不是像这样简单地设置它的容量：
- en: '[PRE601]'
  id: totrans-2519
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE601]'
- en: …I initialize the array with an array that is the return value from a function!
    So let’s look down at the function before we proceed.
  id: totrans-2520
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: ……我用一个函数的返回值初始化了数组！所以在继续之前，让我们看看函数。
- en: 'On line 26 the function definition begins. The function is called `arrayFromUrl()`  and
    it has one parameter: a String. And it returns what? It returns not a `double`  but
    `double[]`  (an array of `double`s).'
  id: totrans-2521
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第26行，函数定义开始。这个函数叫做`arrayFromUrl()`，它有一个参数：一个字符串。它返回什么？它返回的不是`double`，而是`double[]`（一个`double`数组）。
- en: On line 28 we create a Scanner object to read data from a file, but instead
    of getting the data from a file, we get the information from a URL. One of the
    nice things about Java is that this is only a tiny change.
  id: totrans-2522
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第28行，我们创建了一个Scanner对象来从文件中读取数据，但是我们并没有从文件中获取数据，而是从一个URL中获取信息。Java的一个好处就是这只是一个微小的改变。
- en: 'Now, I do a trick with my text file that I learned many years ago. At the time
    I am writing this chapter, my file contains 6717 temperatures. But maybe you are
    reading this a year later and I want to update the file to add more temperatures.
    So the first line of the file is just a number: `6717`. Then after that I have
    6717 lines of temperatures, one per line.'
  id: totrans-2523
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我用了一个我多年前学会的文本文件技巧。在我写这一章的时候，我的文件包含了6717个温度。但也许你是在一年后读到这篇文章，我想更新文件以添加更多的温度。所以文件的第一行只是一个数字：`6717`。然后在那之后，我有6717行温度，每行一个。
- en: On line 29 in this code I read the *count* from the first thing in the file.
    And I use that count to decide how big my array should be on line 31\. So six
    months from now if I decide to add more temperatures to the file, all I have to
    do is change the first line of my file to match and this code will still work.
    Not a bad trick, eh?
  id: totrans-2524
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这段代码的第29行，我从文件中的第一行读取*count*。我使用该计数来决定第31行上我的数组应该有多大。所以，六个月后，如果我决定向文件中添加更多温度，我只需要更改文件的第一行，这段代码仍然可以工作。是不是一个不错的技巧？
- en: On line 31 we define an array of doubles with *count* slots. (Currently 6717.)
  id: totrans-2525
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第31行，我们定义了一个具有*count*槽的双精度数组。（目前为6717。）
- en: On line 33 there’s a `for`  loop that iterates through each slot in the array,
    and on line 34 we read a `double`  from the file each time (`fin.nextDouble()`)
    and store it into the next indexed slot in array.
  id: totrans-2526
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第33行，有一个`for`循环，它遍历数组中的每个槽，并且在第34行，我们每次从文件中读取一个`double`（`fin.nextDouble()`）并将其存储到数组中的下一个索引槽中。
- en: Then when the loop ends, I `close()`  the file. Then on line 37 the array is
    returned from the function and that array is what is stored into the array temps
    back on line 8 of `main()`.
  id: totrans-2527
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后当循环结束时，我`close()`了文件。然后在第37行，数组从函数中返回，这个数组就是存储在`main()`的第8行的数组temps中的。
- en: On line 10 we print out the current length of the array to make sure nothing
    went wrong with the reading.
  id: totrans-2528
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第10行，我们打印出数组的当前长度，以确保读取没有出错。
- en: On line 12 we create a variable that will eventually hold the lowest temperature
    in the whole array. At first we put a really large value in there, though.
  id: totrans-2529
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第12行，我们创建一个变量，最终将保存整个数组中的最低温度。起初，我们在那里放了一个非常大的值。
- en: Line 14 is another `for`  loop that is going to give us all the legal indexes
    in the array. In this case, since the array has 6717 values in it, the indexes
    will run from `0`  to `6716`.
  id: totrans-2530
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第14行是另一个`for`循环，将给出数组中的所有合法索引。在这种情况下，由于数组中有6717个值，索引将从`0`到`6716`。
- en: Line 16 compares the value we are currently looking at in the array (depending
    on the current value of *i*). If that value is less than whatever is in *lowest*,
    then we have a new record! On line 18 we replace what used to be in *lowest* with
    this new smaller value.
  id: totrans-2531
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第16行比较了我们当前在数组中查看的值（取决于当前值*i*）。如果该值小于*lowest*中的任何值，那么我们就有了一个新的记录！在第18行，我们用这个新的更小的值替换了以前在*lowest*中的值。
- en: And the loop continues until all the values in the array have been compared.
    When the loop ends, the variable *lowest* now actually does contain the smallest
    value.
  id: totrans-2532
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 循环会一直持续，直到数组中的所有值都被比较。当循环结束时，变量*lowest*现在实际上包含了最小的值。
- en: There is a small function down on lines 40 through 43 to convert a temperature
    from degrees Fahrenheit to degrees Celsius. So on line 23 we display the lowest
    temperature as it came from the file and also converted to Celsius.
  id: totrans-2533
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第40到43行有一个小函数，用于将华氏度转换为摄氏度的温度。所以在第23行，我们显示了来自文件的最低温度，也转换为摄氏度。
- en: You may be thinking that 22.1F (­5.5C) is not a very cold temperature. Well,
    that’s Texas for you. Also remember that the temperatures aren’t the lowest temperature
    of the day, they are the average of 24 hourly temperature samples for each day.
  id: totrans-2534
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能会认为22.1华氏度（-5.5摄氏度）不是非常寒冷的温度。好吧，这就是德克萨斯。还要记住，这些温度不是一天中最低的温度，它们是每天24小时温度样本的平均值。
- en: Study Drills
  id: totrans-2535
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Change the code to display both the lowest average daily temperature and and
    the highest.
  id: totrans-2536
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码更改为显示最低平均日温度和最高平均日温度。
- en: Try to find another temperature file online for a city closer to where you live
    and change your code to read from it instead!
  id: totrans-2537
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在网上找到另一个离你更近的城市的温度文件，并将你的代码更改为从该文件中读取！
- en: (I mentioned it above, but this is the modified code to read the temperature
    data from a local file in case you can’t run your Java program on a machine with
    Internet access.)
  id: totrans-2538
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （我上面提到过，但这是修改后的代码，用于从本地文件中读取温度数据，以防你无法在具有互联网访问权限的计算机上运行Java程序。）
- en: '[PRE602]'
  id: totrans-2539
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-2540
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE603]'
- en: '[PRE604]'
  id: totrans-2541
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE604]'
- en: 'Exercise 53: Mailing Addresses (Records)'
  id: totrans-2542
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习53：邮寄地址（记录）
- en: Today’s exercise is about what I call “records”. In the programming languages
    C and C++ they are called “structs”. An array is a bunch of different values in
    one variable where the values are *all the same type* and they are distinguished
    by *index* (slot number). A record is a few different values in one variable but
    the values can be different types and they are distinguished by *name* [(usually
    called a “field”).](#bookmark176) [12](#bookmark176)
  id: totrans-2543
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 今天的练习是关于我所谓的“记录”。在C和C++编程语言中，它们被称为“结构”。数组是一个变量中的许多不同值，其中值都是*相同类型*的，并且它们由*索引*（槽号）区分。记录是一个变量中的几个不同值，但值可以是不同类型的，并且它们由*名称*（通常称为“字段”）区分。
- en: Type the following code into a single file named `MailingAddresses.java`. (The
    line that says
  id: totrans-2544
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码输入到一个名为`MailingAddresses.java`的单个文件中。（第一行说
- en: '[PRE605]'
  id: totrans-2545
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-2546
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-2547
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE607]'
- en: '[PRE608]'
  id: totrans-2548
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-2549
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-2550
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-2551
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-2552
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-2553
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-2554
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-2555
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE615]'
- en: '[PRE616]'
  id: totrans-2556
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-2557
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-2558
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-2559
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-2560
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '`class Address`  is correct but you can’t name your file `Address.java`  or
    it won’t work.)'
  id: totrans-2561
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`class Address`是正确的，但你不能把你的文件命名为`Address.java`，否则它就不会工作。'
- en: What You Should See
  id: totrans-2562
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE621]'
  id: totrans-2563
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_069.png)'
  id: totrans-2564
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Learn%20Java%20the%20Hard%20Way_files/Image_069.png)'
- en: 'There’s only one problem will all of this: Java doesn’t actually have records.
    It turns out that if you make a nested class with no methods and only public variables
    it works just like a struct  even if it isn’t the Java Way.'
  id: totrans-2565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一切只有一个问题：Java实际上并没有记录。事实证明，如果你创建一个没有方法，只有公共变量的嵌套类，它就像一个结构一样工作，即使它不是Java的方式。
- en: I don’t care if it is the Java Way or not. I have been teaching students a long
    time and I firmly believe that you can’t
  id: totrans-2566
  prefs: []
  type: TYPE_NORMAL
  zh: 我不在乎这是否是Java的方式。我已经教了很多学生，我坚信如果你不先理解记录，就很难理解面向对象的编程。
- en: understand object­oriented programming very well if you don’t first understand
    records. So I am going to fake them in a way that works perfectly fine and would
    be very nice code in lots of different programming languages.
  id: totrans-2567
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不先理解记录，就很难理解面向对象的编程。所以我要以一种完全正常的方式伪造它们，这在许多不同的编程语言中都是非常好的代码。
- en: Some die­hard object­oriented Java­head is going to stumble across this exercise
    and send me an nasty email that I am Doing It Wrong and why am I filling these
    poor kids’ heads with lies? Oh, well.
  id: totrans-2568
  prefs: []
  type: TYPE_NORMAL
  zh: 一些顽固的面向对象的Java爱好者会偶然发现这个练习，并给我发送一封恶毒的电子邮件，说我做错了，为什么我要用谎言来填充这些可怜的孩子的头脑？哦，好吧。
- en: '[PRE622]'
  id: totrans-2569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: So up on lines 1 through 7 we have defined a record called `Address`.
  id: totrans-2570
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第1到7行，我们定义了一个名为`Address`的记录。
- en: (I know it says `class`, not `record`. If I could do something about this I
    promise I would. You should call this a “record” anyway, or a “struct” if you
    really want. If you call it a “class” it will confuse any Java programmer that
    loves object­oriented programming and if you call it a “struct” at least the C
    and C++ programmers will understand you.)
  id: totrans-2571
  prefs: []
  type: TYPE_NORMAL
  zh: （我知道它说`class`，而不是`record`。如果我能做点什么，我发誓我会。无论如何，您应该将其称为“record”，或者如果您真的想要的话，称为“struct”。如果您将其称为“class”，它将使任何热爱面向对象编程的Java程序员感到困惑，如果您将其称为“struct”，至少C和C++程序员会理解您。）
- en: Our record has four fields. The first field is a String named *street*. The
    second field is a String called
  id: totrans-2572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的记录有四个字段。 第一个字段是名为*street*的字符串。 第二个字段是称为
- en: city. And so on.
  id: totrans-2573
  prefs: []
  type: TYPE_NORMAL
  zh: 城市。等等。
- en: Then on line 9 our “real” class starts.
  id: totrans-2574
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第9行开始我们的“真正”类。
- en: On line 13 we declare three variables named uno, dos and tres. These variables
    are not integers or Strings; they are records. Of type `Address`. Each one has
    four fields in it.
  id: totrans-2575
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行，我们声明了三个名为uno，dos和tres的变量。 这些变量不是整数或字符串； 它们是记录。 类型为`Address`。 每个记录中都有四个字段。
- en: On line 15 we have to store an Address object in the variable because remember
    we only declared the variables and they haven’t been initialized yet.
  id: totrans-2576
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15行，我们必须将一个Address对象存储在变量中，因为请记住，我们只声明了变量，它们还没有被初始化。
- en: Once that is taken care of you will see that we can store the String `"191 Marigold
    Lane"`  into the
  id: totrans-2577
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理好这些，您将看到我们可以将字符串`"191 Marigold Lane"`存储到
- en: street field of the Address record named uno, and that’s exactly what we do
    on line 16\. Line 17 stores the String `"Miami"`  into the city field of the record
    uno.
  id: totrans-2578
  prefs: []
  type: TYPE_NORMAL
  zh: Address记录名为uno的street字段，这正是我们在第16行所做的。 第17行将字符串`"Miami"`存储到记录uno的city字段中。
- en: I’m not going to bother to explain what is happening for the rest of the program
    because I think it is
  id: totrans-2579
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算解释程序的其余部分发生了什么，因为我认为这是
- en: pretty clear. I guess the only thing worth mentioning is that although three
    of the fields in the record are Strings, the *zip* field is an integer. The fields
    of a record can be whatever type you want.
  id: totrans-2580
  prefs: []
  type: TYPE_NORMAL
  zh: 非常清楚。 我想值得一提的是，尽管记录中的三个字段都是字符串，但*zip*字段是整数。 记录的字段可以是您想要的任何类型。
- en: Study Drills
  id: totrans-2581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演练
- en: Create a fourth Address variable on line 13 and change the code to put *your*
    mailing address in it. Don’t forget to print it out at the bottom.
  id: totrans-2582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第13行创建第四个Address变量，并更改代码以将*您的*邮寄地址放入其中。不要忘记在底部打印出来。
- en: Frequently­Asked Questions
  id: totrans-2583
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见问题
- en: Where did you get these addresses?
  id: totrans-2584
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你从哪里得到这些地址的？
- en: I made them up. I’m fairly certain those streets don’t exist in those cities.
    If by some miracle I made up a real address, let me know and I’ll change it.
  id: totrans-2585
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我编造了它们。 我相当肯定这些街道在这些城市中并不存在。 如果我奇迹般地编造了一个真实地址，请告诉我，我会更改它。
- en: 'Exercise 54: Records from a File'
  id: totrans-2586
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习54：从文件中读取记录
- en: This exercise will show you how to read values into a record from a text file.
    There is also an example of a loop that reads in the entire file, no matter how
    long it is.
  id: totrans-2587
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习将向您展示如何从文本文件中读取记录的值。 还有一个示例，演示了一个循环，该循环会读取整个文件，无论文件有多长。
- en: If you run this program on a machine that isn’t connected to the Internet, this
    code won’t work as written, although the change is very small. The code accesses
    this file, which you can download if you need to.
  id: totrans-2588
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在一个没有连接到互联网的机器上运行这个程序，这段代码将无法正常工作，尽管更改非常小。 该代码访问此文件，如果需要，您可以下载该文件。
- en: http://learnjavathehardway.org/txt/s01e01­cast.txt
  id: totrans-2589
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://learnjavathehardway.org/txt/s01e01­cast.txt
- en: '[PRE623]'
  id: totrans-2590
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-2591
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-2592
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE625]'
- en: '[PRE626]'
  id: totrans-2593
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-2594
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-2595
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-2596
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[String url =](http://learnjavathehardway.org/txt/s01e01) ["http://learnjavathehardway.org/txt/s01e01­cast.txt";](http://learnjavathehardway.org/txt/s01e01)'
  id: totrans-2597
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[String url =](http://learnjavathehardway.org/txt/s01e01) ["http://learnjavathehardway.org/txt/s01e01­cast.txt";](http://learnjavathehardway.org/txt/s01e01)'
- en: '[PRE630]'
  id: totrans-2598
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE630]'
- en: '[PRE631]'
  id: totrans-2599
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-2600
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-2601
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-2602
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-2603
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE635]'
- en: Type the following code into a single file named `ActorList.java`. (The line
    that says `class` `Actor`  is correct but you can’t name your file `Actor.java`  or
    it won’t work.)
  id: totrans-2604
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码键入名为`ActorList.java`的单个文件中。（说`class` `Actor`的行是正确的，但您不能将文件命名为`Actor.java`，否则它将无法工作。）
- en: What You Should See
  id: totrans-2605
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到什么
- en: '[PRE636]'
  id: totrans-2606
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE636]'
- en: This time our record is called `Actor`  and has three fields, all of which are
    Strings.
  id: totrans-2607
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次我们的记录称为`Actor`，有三个字段，所有字段都是字符串。
- en: On line 16 we create a Scanner object that is connected to the Internet address
    of the input text file. Did you notice that I didn’t import `java.net.URL`  at
    the top? You only need to import a class if you want to be able to type the short
    version of the class name.
  id: totrans-2608
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第16行，我们创建了一个与输入文本文件的互联网地址连接的Scanner对象。 您注意到我在顶部没有导入`java.net.URL`吗？ 只有在您想要能够输入类名的简短版本时，才需要导入类。
- en: 'In this case, if I had imported `java.net.URL`  at the top of the code, I could
    have just written:'
  id: totrans-2609
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我在代码顶部导入了`java.net.URL`，我可以直接写：
- en: '[PRE637]'
  id: totrans-2610
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE637]'
- en: Sometimes if I am going to be using a class only once, I’d rather just use the
    full name in my code instead of bothering to import it. I used the same trick
    on line 15; instead of importing `java.io.File`  I just used the full classname
    here.
  id: totrans-2611
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，如果我只打算使用一个类一次，我宁愿在我的代码中使用完整的名称，而不是导入它。 我在第15行也使用了同样的技巧； 而不是导入`java.io.File`，我只是在这里使用了完整的类名。
- en: (If your machine doesn’t have Internet access, remove the two slashes at the
    beginning of line 15 so that it is no longer a comment and then *add* two slashes
    at the beginning on line 16 to *make* it a comment.
  id: totrans-2612
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （如果您的机器没有互联网访问权限，请删除第15行开头的两个斜杠，这样它就不再是注释，然后在第16行开头*添加*两个斜杠*使*它成为注释。
- en: Then the program will read the file locally instead of over the Internet.)
  id: totrans-2613
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后程序将在本地读取文件，而不是通过互联网读取。）
- en: Whether you open the file from the Internet or your own machine, after line
    17 we have a Scanner object named *inFile* which is connected to a text file.
  id: totrans-2614
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论您是从互联网还是从您自己的计算机打开文件，在第17行之后，我们都有一个名为*inFile*的Scanner对象，它连接到一个文本文件。
- en: 'A lot of the time when we are reading from a text file, we don’t know in advance
    how long it is going to be. In the lowest temperature exercise I showed you one
    trick for dealing with this: storing the number of items as the first line of
    the file. But a more common technique is the one I have used here: just use a
    loop that repeats until we reach the end of the file.'
  id: totrans-2615
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们从文本文件中读取数据时，很多时候我们事先不知道它的长度。在最低温度练习中，我向你展示了一个处理这个问题的技巧：将项目数量存储为文件的第一行。但更常见的技术是我在这里使用的：只需使用一个循环，直到我们到达文件的末尾。
- en: The `.hasNext()`  method of the Scanner object will return `true`  if there
    is more data that hasn’t been read in yet. And it returns `false`  if there is
    no more data. So on line 18 we create a `while`  loop that repeats as long as
    `.hasNext()`  continues to return `true`.
  id: totrans-2616
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Scanner对象的`.hasNext()`方法将在尚未读取的数据时返回`true`。如果没有更多数据，则返回`false`。因此，在第18行，我们创建一个`while`循环，只要`.hasNext()`继续返回`true`，就会重复。
- en: Before we look at line 20 let us skip down to lines 27 through 35 where I have
    created a function that will read all the data for a single Actor record from
    the file.
  id: totrans-2617
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们查看第20行之前，让我们跳到第27到35行，我在那里创建了一个函数，该函数将从文件中读取单个演员记录的所有数据。
- en: 'The function is called getActor. It has one parameter: a Scanner object! That’s
    right, you pass in an already­open Scanner object to the function and it reads
    from it. And the getActor function returns an `Actor`. It returns an entire record.'
  id: totrans-2618
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该函数名为getActor。它有一个参数：一个Scanner对象！没错，你将一个已经打开的Scanner对象传递给函数，它会从中读取。getActor函数返回一个`Actor`。它返回整个记录。
- en: If we are going to return an `Actor`  object from the function we need a variable
    of type `Actor`  to return, so we define one on line 29\. I just called it a because
    inside the function we don’t know anything about the purpose of this variable.
    You should give good names to variables but in a situation like this a short,
    meaningless name like a is perfectly fine.
  id: totrans-2619
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们要从函数中返回一个`Actor`对象，我们需要一个`Actor`类型的变量来返回，因此我们在第29行定义了一个。我只是称它为a，因为在函数内部我们对这个变量的目的一无所知。您应该为变量提供良好的名称，但在这种情况下，像a这样的简短、无意义的名称是完全可以的。
- en: Lines 30 through 32 read three lines from the text file and store them into
    the three fields of the record. Then the function has done its job and we return
    the record back up to line 20 in `main()`.
  id: totrans-2620
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第30到32行读取文本文件中的三行并将它们存储到记录的三个字段中。然后函数完成了它的工作，我们将记录返回到`main()`中的第20行。
- en: Why must we create an `Actor`  variable named a here in `main()`  and also down
    in the function? Because of variable scope. A variable is only in scope (aka “visible”)
    within the block in which it was
  id: totrans-2621
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为什么我们在`main()`中和函数中都要创建一个名为a的`Actor`变量？因为变量作用域。变量只在其所在的块中（也就是“可见”）。
- en: declared. Period. It doesn’t matter if the variable is “returned” from a function
    or not because remember it is not the variable itself which is returned but a
    copy of the *value* of the variable.
  id: totrans-2622
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 声明。不管变量是否从函数中“返回”，因为请记住，返回的不是变量本身，而是变量的*值*的副本。
- en: There is an `Actor`  variable called a declared (and defined) on line 20 in
    `main()`, but that variable goes out of scope when the close curly brace occurs
    on line 23\. There is a different `Actor`  variable called a declared (and defined)
    on line 29 in the `getActor()`  function, but it goes out of scope when the close
    curly brace occurs on line 35.
  id: totrans-2623
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`main()`的第20行声明（和定义）了一个名为a的`Actor`变量，但当第23行的闭合大括号出现时，该变量就超出了作用域。在`getActor()`函数的第29行声明（和定义）了另一个名为a的`Actor`变量，但当第35行的闭合大括号出现时，该变量也超出了作用域。
- en: Okay, back to line 20\. The variable a gets its value from the return value
    of the function `getActor()`. We pass in the open Scanner object inFile as the
    argument to the function and it returns to us an `Actor`  object with all its
    fields filled in.
  id: totrans-2624
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好的，回到第20行。变量a的值来自函数`getActor()`的返回值。我们将打开的Scanner对象inFile作为函数的参数传递给它，它会返回一个填充了所有字段的`Actor`对象。
- en: (Why is the argument called *inFile* and the parameter named *input*? Because
    they are not the same variable. The parameter *input* is declared on line 27 and
    gets a copy of the value from the argument *inFile*. They are two different variables
    that have the same value.)
  id: totrans-2625
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （为什么参数称为*inFile*，而参数称为*input*？因为它们不是同一个变量。参数*input*在第27行声明，并从参数*inFile*获取值的副本。它们是两个具有相同值的不同变量。）
- en: 'After all that, lines 21 and 22 are pretty boring: they simply display the
    values of all the fields of the record. On line 23 the loop repeats back up to
    check the condition again: now that we have read another record from the file,
    does the file still have more? If so, keep looping. If not, skip down to line
    24 where we close the file.'
  id: totrans-2626
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经过所有这些，第21和22行非常无聊：它们只是显示记录的所有字段的值。在第23行，循环会再次重复检查条件：现在我们从文件中读取了另一条记录，文件是否仍然有更多？如果是，继续循环。如果不是，跳到第24行，关闭文件。
- en: Notice that both in the function and in the `while`  loop in `main()`  the variable
    a only holds one record at a time. We read all the records from the file and print
    them all out on the screen, but when the program is finishing its last time through
    the loop, the variable a only holds the most recent record. All the other records
    are still in the file and have been displayed on the screen, but their values
    are not currently being held in any variables.
  id: totrans-2627
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，在函数和`main()`中的`while`循环中，变量a一次只保存一个记录。我们从文件中读取所有记录并将它们全部打印在屏幕上，但当程序最后一次通过循环时，变量a只保存最近的记录。所有其他记录仍然在文件中，并且已经显示在屏幕上，但它们的值目前没有保存在任何变量中。
- en: We can fix that, but not until the next exercise.
  id: totrans-2628
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以修复这个问题，但要等到下一个练习。
- en: 'Exercise 55: An Array of Records'
  id: totrans-2629
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习55：记录数组
- en: Records are great and arrays are better, but there is not much in this life
    you can’t code when you put records *into* an array.
  id: totrans-2630
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记录很棒，数组更好，但是当你把记录放入数组时，这个生活中几乎没有你不能编码的东西。
- en: '[PRE638]'
  id: totrans-2631
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE638]'
- en: What You Should See
  id: totrans-2632
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE639]'
  id: totrans-2633
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-2634
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE640]'
- en: When you see the square brackets just to the right of something in a variable
    definition, that’s an “array of” whatever. In fact, since this book is almost
    over, maybe I should explain that `public static` `void main`  business. At least
    partially.
  id: totrans-2635
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你看到变量定义中某物的右侧有方括号时，那就是“某物的数组”。实际上，由于这本书快要结束了，也许我应该解释一下`public static` `void
    main`的业务。至少部分地。
- en: '[PRE641]'
  id: totrans-2636
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE641]'
- en: 'This line declares a function named main. That function requires one parameter:
    an array of `String`s named args (which is short for “arguments”). The function
    doesn’t return any value; it is `void`.'
  id: totrans-2637
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一行声明了一个名为main的函数。该函数需要一个参数：名为args的字符串数组（缩写为“arguments”）。该函数不返回任何值；它是`void`。
- en: Anyway.
  id: totrans-2638
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 无论如何。
- en: Line 12 declares *db* as a variable that can hold an “array of Students”. There’s
    no array yet, just a variable that can potentially hold one. Just like when we
    say…
  id: totrans-2639
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第12行声明了*db*作为一个可以容纳“学生数组”的变量。还没有数组，只是一个可能容纳数组的变量。就像我们说…
- en: '[PRE642]'
  id: totrans-2640
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE642]'
- en: …there’s no integer yet. The variable *n* can potentially hold an integer, but
    there’s no number in it yet. *n* is declared but undefined. In the same way, once
    line 12 has finished executing, *db* is a variable that *could* refer to an array
    of Students, but is still undefined.
  id: totrans-2641
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …还没有整数。变量*n*可能容纳一个整数，但它里面还没有数字。*n*被声明但未定义。同样，一旦第12行执行完毕，*db*是一个*可能*指向学生数组的变量，但仍未定义。
- en: 'Fortunately we don’t have to wait long; line 13 initializes db by creating
    an actual array of Students with three slots. At this point db is defined, `db.length`  is
    `3`  and db has three legal indexes: `0`, `1`  and `2`.'
  id: totrans-2642
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必等太久；第13行通过创建一个实际的具有三个槽的学生数组来初始化db。此时，db被定义，`db.length`为`3`，db有三个合法索引：`0`，`1`和`2`。
- en: Okay, at this point, *db* is an array of Student records. Except that it isn’t.
    *db* is an array of Student *variables*, each of which can *potentially* hold
    a Student record, but none of which do. All three slots in the array are undefined.
  id: totrans-2643
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 好吧，在这一点上，*db*是一个学生记录的数组。除了它不是。*db*是一个学生*变量*的数组，每个变量都*可能*容纳一个学生记录，但没有一个变量是这样的。数组中的所有三个槽都未定义。
- en: (Technically they contain the value `null`, which is the special value that
    reference variables in Java have when there’s no object in them yet.)
  id: totrans-2644
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: （从技术上讲，它们包含值`null`，这是Java中引用变量在其中没有对象时具有的特殊值。）
- en: So on line 15 it is important that a Student object is created and stored into
    the first slot (index `0`) of the array. Then on line 16 we can store a value
    into the name field of the Student record which is in index `0`  of the array
    db.
  id: totrans-2645
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在第15行，重要的是创建一个学生对象并将其存储到数组的第一个槽（索引`0`）中。然后在第16行，我们可以将一个值存储到数组db中索引`0`的学生记录的名字字段中。
- en: 'Let’s trace it from the outside in:'
  id: totrans-2646
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们从外到内追踪它：
- en: expression
  id: totrans-2647
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表达式
- en: type
  id: totrans-2648
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型
- en: description
  id: totrans-2649
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述
- en: db
  id: totrans-2650
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: db
- en: Student[]
  id: totrans-2651
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生[]
- en: an array of Student records
  id: totrans-2652
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一组学生记录
- en: db[0]
  id: totrans-2653
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: db[0]
- en: Student
  id: totrans-2654
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生
- en: a single Student record (the first one)
  id: totrans-2655
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个单独的学生记录（第一个）
- en: db[0].name
  id: totrans-2656
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: db[0].name
- en: String
  id: totrans-2657
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字符串
- en: the *name* field of the first Student in the array
  id: totrans-2658
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组中第一个学生的*name*字段
- en: db.name
  id: totrans-2659
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: db.name
- en: error
  id: totrans-2660
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 错误
- en: the whole array doesn’t have a single *name* field
  id: totrans-2661
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个数组没有一个名字字段
- en: So line 16 stores a value into the *name* field of the first record in the array.
    Lines 17 and 18 store values into the remaining fields in that record. Lines 20
    through 28 create then fill the other two records in the array
  id: totrans-2662
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，第16行将一个值存储到数组中第一个记录的*name*字段中。第17和18行将值存储到该记录中的其余字段中。第20到28行创建并填充数组中的其他两个记录
- en: On lines 30 though 34 we use a loop to display all the values on the screen.
  id: totrans-2663
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管在第30到34行，我们使用循环在屏幕上显示所有的值。
- en: Then lines 37 through 42 find the student with the highest GPA. This is worth
    explaining in more detail. On line 37 an `int`  called max is defined. But max
    is not going to hold the value of the highest GPA; it is going to hold only its
    index.
  id: totrans-2664
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，第37到42行找到了GPA最高的学生。这值得更详细解释。在第37行，定义了一个名为max的`int`。但max不会保存最高GPA的值；它只会保存它的索引。
- en: So when I put `0`  into max I mean “As this point in the code, as far as I know,
    the highest­scoring student
  id: totrans-2665
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所以当我把`0`放入max时，我的意思是“在代码的这一点上，就我所知，最高分的学生
- en: is in slot `0`.” This is probably not true, but since we haven’t looked at any
    of the values in the database yet it is as good a starting place as any.
  id: totrans-2666
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在槽`0`中。”这可能不是真的，但由于我们还没有查看数据库中的任何值，这是一个很好的起点。
- en: Then on line 38 we set up the loop to look through each slot of the array. Notice,
    however, that the loop starts with index `1`  (the second slot). Why?
  id: totrans-2667
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在第38行，我们设置循环来查看数组的每个槽。然而，请注意，循环从索引`1`（第二个槽）开始。为什么？
- en: Because max is already `0`. So if i started at `0`  too then the `if`  statement
    would be comparing
  id: totrans-2668
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为max已经是`0`。所以如果i也从`0`开始，那么`if`语句将进行以下比较：
- en: '[PRE643]'
  id: totrans-2669
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '…which is a waste. So by starting i at `1`, then the first time through the
    loop the `if`  statement makes the following comparison instead:'
  id: totrans-2670
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: …这是浪费。因此，通过从`1`开始，第一次循环时，`if`语句将进行以下比较：
- en: '[PRE644]'
  id: totrans-2671
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE644]'
- en: “If Dave’s GPA is greater than Esteban’s GPA, then change max from `0`  to the
    current value of i (`1`).”
  id: totrans-2672
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: “如果戴夫的GPA大于埃斯特万的GPA，则将max从`0`更改为i（`1`）的当前值。”
- en: So by the time the loop is over, *max* contains the **index** of the record
    with the highest GPA. Which is exactly what we display on line 42.
  id: totrans-2673
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，当循环结束时，*max*包含具有最高GPA的记录的**索引**。这正是我们在第42行显示的内容。
- en: Study Drills
  id: totrans-2674
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演习
- en: Change the array to have a capacity of `4`  instead of 3\. Change nothing else
    and compile and run the program. Do you understand why the program blows up?
  id: totrans-2675
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组的容量更改为`4`而不是3。不改变任何其他内容，编译并运行程序。你明白为什么程序会崩溃吗？
- en: Now add some more code to put values into the fields for your new student. Give
    this new student a higher GPA than “Dave” and confirm that the code correctly
    labels them as having the highest GPA.
  id: totrans-2676
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一些代码，将值放入新学生的字段中。给这个新学生一个比“Dave”更高的GPA，并确认代码正确地将他们标记为具有最高的GPA。
- en: Change the code so that it finds the person with the fewest credits instead
    of the person with the highest GPA.
  id: totrans-2677
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码，使其查找具有最少学分的人，而不是具有最高GPA的人。
- en: 'Exercise 56: Array of Records from a File (Temperatures Revisited)'
  id: totrans-2678
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习56：从文件中读取记录的数组（温度重访）
- en: This exercise populates an array of records from a file on the Internet. By
    now you should know if you need to download a copy of this file or if your computer
    can just open it from the Internet.
  id: totrans-2679
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习从互联网上的一个文件中填充了一个记录数组。到目前为止，您应该知道您是否需要下载此文件的副本，还是您的计算机可以直接从互联网上打开它。
- en: http://learnjavathehardway.org/txt/avg­daily­temps­with­dates­atx.txt
  id: totrans-2680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: http://learnjavathehardway.org/txt/avg­daily­temps­with­dates­atx.txt
- en: 'Unlike all the other files you have used so far in this book this data file
    is exactly the way I downloaded it from the University of Dayton’s average daily
    temperature archive. This means three things:'
  id: totrans-2681
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中迄今为止使用的所有其他文件不同，这个数据文件正是我从戴顿大学的平均日温度档案中下载的。这意味着三件事：
- en: There is no number in the first line of the file telling us how many records
    there are.
  id: totrans-2682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件的第一行没有数字告诉我们有多少记录。
- en: In addition to the temperature each record also has the month, day and year
    for the sample.
  id: totrans-2683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了温度之外，每个记录还包括样本的月份、日期和年份。
- en: There is bad data in the file. In particular, “We use ‘­99’ as a no­data flag
    when data are not available.”
  id: totrans-2684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件中有错误数据。特别是，“当数据不可用时，我们使用‘-99’作为无数据标志。”
- en: '[PRE645]'
  id: totrans-2685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-2686
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-2687
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-2688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-2689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: '[PRE650]'
  id: totrans-2690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-2691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: So some days have a temperature of ­99\. We will have to handle this in the
    code.
  id: totrans-2692
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有些天的温度是-99。我们将不得不在代码中处理这个问题。
- en: '[PRE652]'
  id: totrans-2693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-2694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-2695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-2696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-2697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-2698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-2699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-2700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-2701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: What You Should See
  id: totrans-2702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的是
- en: '[PRE661]'
  id: totrans-2703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: Lines 3 through 7 declare our record, which will store a single average daily
    temperature value (a
  id: totrans-2704
  prefs: []
  type: TYPE_NORMAL
  zh: 第3到7行声明了我们的记录，它将存储单个平均日温度值（一个
- en: '`double`) but also has fields for the month, day and year.'
  id: totrans-2705
  prefs: []
  type: TYPE_NORMAL
  zh: '`double`），还有月份、日期和年份的字段。'
- en: 'Line 16 defines an array of records. We have a problem, though. We can’t define
    an array without providing a capacity and we don’t know the capacity we need until
    we see how many records are in the file. There are three possible solutions to
    this problem:'
  id: totrans-2706
  prefs: []
  type: TYPE_NORMAL
  zh: 第16行定义了一个记录数组。但是我们有一个问题。我们无法在不提供容量的情况下定义数组，而在看到文件中有多少记录之前，我们不知道需要多大的容量。这个问题有三种可能的解决方案：
- en: Don’t use an array. Use something else like an array that can automatically
    grow as you add entries. This is actually probably the right solution, but that
    “something else” is beyond the scope of this book.
  id: totrans-2707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用数组。使用其他东西，比如一个可以在添加条目时自动增长的数组。这实际上可能是正确的解决方案，但是“其他东西”超出了本书的范围。
- en: Read the file twice. Do it once just to count the number of records and then
    create the array with the perfect size. Then read it again to slurp all the values
    into the array. This works but it’s slow.
  id: totrans-2708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件两次。首先只计算记录的数量，然后使用完美大小创建数组。然后再次读取文件将所有值读入数组。这样做很慢，但有效。
- en: Don’t worry about making the array the right size. Just make it “big enough”.
    Then count how many records you actually have while reading them in and use that
    count instead of the array’s capacity for any loops. This is not perfect, but
    it works and it’s easy. Writing software sometimes requires compromise, and this
    is one of them.
  id: totrans-2709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要担心使数组的大小合适。只需使其“足够大”。然后在读取它们时计算实际拥有的记录数量，并在任何循环中使用该计数，而不是数组的容量。这并不完美，但它有效且简单。编写软件有时需要妥协，这就是其中之一。
- en: 'So line 16 declares the array and defines it to have ten thousand slots: “big
    enough.”'
  id: totrans-2710
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，第16行声明了数组并定义为有一万个槽位：“足够大”。
- en: On line 19 we start a loop to read all the values from the file. We are using
    an index variable *i* to keep track of which slot in the array needs to be filled
    next. So our loop keeps going as long as the file has more integers in it **and**
    we haven’t run out of capacity in our array.
  id: totrans-2711
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第19行，我们开始一个循环，读取文件中的所有值。我们使用索引变量*i*来跟踪数组中下一个需要填充的槽位。因此，只要文件中还有更多整数，并且我们的数组容量还没有用完，我们的循环就会继续。
- en: Just because we took a shortcut by making our array “big enough” doesn’t mean
    we are going to be stupid about it. If the file ended up bigger than our array’s
    capacity we want to stop reading the file too early rather than blow up the program
    with an ArrayIndexOutOfBounds exception.
  id: totrans-2712
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅仅因为我们通过使数组“足够大”来节省了一些步骤，并不意味着我们会对此感到愚蠢。如果文件最终比我们的数组容量大，我们希望尽早停止读取文件，而不是因为ArrayIndexOutOfBounds异常而使程序崩溃。
- en: Line 21 defines a TemperatureSample record named *e*. Lines 22 through 25 load
    the next few values from the file into the appropriate fields of that record.
  id: totrans-2713
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 21行定义了一个名为*e*的TemperatureSample记录。22到25行将文件中的下几个值加载到该记录的适当字段中。
- en: But! Remember that there are “missing” values in our file. Some days have a
    temperature reading of
  id: totrans-2714
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是！请记住，我们的文件中有“缺失”的值。有些天的温度读数是
- en: '`­99`, so we put in an `if`  statement on line 26 to detect that before we
    put them into our database.'
  id: totrans-2715
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-99`，所以我们在第26行放置了一个`if`语句来检测它，然后将它们放入我们的数据库中。'
- en: 'Then on line 27 there is something new: the Java keyword `continue`. `continue`  is
    only legal inside the body of a loop. And it means “skip the rest of the lines
    of code in the body of the loop and just go back up to the top for the next iteration.”'
  id: totrans-2716
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后在第27行有一些新东西：Java关键字`continue`。`continue`只能在循环体内合法。它的意思是“跳过循环体中剩余的代码行，然后返回顶部进行下一次迭代。”
- en: This effectively throws away the current (invalid) record because it skips lines
    28 and 29, which store the current record in the next available slot in the array
    and then increment the index.
  id: totrans-2717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这实际上丢弃了当前（无效）记录，因为它跳过了第28和29行，这两行将当前记录存储在数组中的下一个可用槽位中，然后增加索引。
- en: 'Some people don’t like to use `continue`  and would write it like this:'
  id: totrans-2718
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有些人不喜欢使用`continue`，他们会这样写：
- en: '[PRE662]'
  id: totrans-2719
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE662]'
- en: And that’s perfectly fine, too. Only put this entry into the array when the
    temperature is not `­99`. I prefer using `continue`  because the code feels cleaner
    to me but reasonable people disagree. Do whichever makes the most sense to you.
  id: totrans-2720
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也完全没问题。只有当温度不是`-99`时，才将此条目放入数组中。我更喜欢使用`continue`，因为这样的代码对我来说更清晰，但是理智的人可能会有不同意见。选择对你来说最有意义的方式。
- en: Once the loop is done on line 31 we make sure to close the file and then store
    the final index into numRecords so we can use it instead of `tempDB.length`  for
    any loops. After all, we made the array bigger than we needed and the last 3283
    slots (in this example) are empty. Not only is looping only up to numRecords slightly
    more efficient, we can avoid examining any invalid records that way.
  id: totrans-2721
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦在第31行完成循环，我们确保关闭文件，然后将最终索引存储到numRecords中，以便我们可以在任何循环中使用它，而不是`tempDB.length`。毕竟，我们使数组比我们需要的大，最后的3283个槽（在这个例子中）是空的。仅循环到numRecords会更有效一些，我们可以通过这种方式避免检查任何无效的记录。
- en: On line 34 we display the number of records on the screen, which can help you
    to see if anything went wrong while reading.
  id: totrans-2722
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第34行，我们在屏幕上显示记录的数量，这可以帮助您查看是否在读取时出现了任何问题。
- en: Lines 36 through 45 loop through all our records. Any record with a month field
    of `11`  (November) gets added to a running total, and we also count the total
    number of matching records while we are at it.
  id: totrans-2723
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第36至45行循环遍历所有我们的记录。任何月份字段为`11`（11月）的记录都会被添加到一个运行总数中，我们也在此过程中计算匹配记录的总数。
- en: Then when that loop is over, we can get the average daily temperature of all
    November days in the database by dividing the sum by the count.
  id: totrans-2724
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，当循环结束时，我们可以通过将总和除以计数来获得数据库中所有11月份每日温度的平均值。
- en: 'Now, my first version of this program had an overall average temperature of
    `59.662962962963`. Not only does this look bad but it’s not correct: all the input
    temperatures were only accurate to a tenth of a degree. So displaying a result
    with a dozen significant figures looks more accurate than it really is.'
  id: totrans-2725
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我的程序的第一个版本的整体平均温度是`59.662962962963`。这不仅看起来不好，而且不正确：所有输入温度只精确到十分之一度。因此，显示具有十几个有效数字的结果看起来比实际更准确。
- en: 'So on lines 52 through 55 you will find a tiny little function to round to
    one decimal place. Java doesn’t have a built­in function for this as far as I
    know, but it does have a built­in function to round to the nearest whole number:
    `Math.round()`. So I multiply the number by ten, round it and then divide by ten
    again. Maybe there’s a better way to do that but I like it.'
  id: totrans-2726
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在第52至55行，您将找到一个小小的函数，用于将数字四舍五入到小数点后一位。据我所知，Java没有内置的此功能，但它确实有一个内置的将数字四舍五入到最接近的整数的函数：`Math.round()`。所以我将数字乘以十，四舍五入，然后再除以十。也许有更好的方法，但我喜欢这样做。
- en: Line 48 passes the average temperature as the argument to my function and then
    takes the rounded return value and stores that as the new value of *avg*.
  id: totrans-2727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第48行将平均温度作为参数传递给我的函数，然后取舍返回值并将其存储为*avg*的新值。
- en: Study Drills
  id: totrans-2728
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习训练
- en: Visit the University of Dayton’s temperature archive and download a file with
    temperature data for a city near you! Make your code read data from that file
    instead.
  id: totrans-2729
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问戴顿大学的温度档案，并下载一个附近城市的温度数据文件！让你的代码从该文件中读取数据。
- en: Change the code to find out other things, like the highest temperature in February
    or whatever suits your fancy.
  id: totrans-2730
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码以查找其他内容，比如二月份的最高温度或其他你感兴趣的内容。
- en: 'Try printing an entire TemperatureSample record on the screen. Something like
    this:'
  id: totrans-2731
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在屏幕上打印整个TemperatureSample记录。类似于这样：
- en: '[PRE663]'
  id: totrans-2732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: Notice that isn’t printing an integer like ts.year or a double like `ts.temperature`;
    it is attempting to display a whole record on the screen. Compile and run the
    file. What gets displayed on the screen?
  id: totrans-2733
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它不会打印像ts.year这样的整数或像`ts.temperature`这样的双精度；它试图在屏幕上显示整个记录。编译并运行文件。屏幕上显示了什么？
- en: Try changing the index to pull different values out of the array and see how
    it changes what gets printed.
  id: totrans-2734
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改索引以从数组中提取不同的值，并查看它如何改变打印出来的内容。
- en: 'Exercise 57: A Deck of Playing Cards'
  id: totrans-2735
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习57：一副扑克牌
- en: Before this book ends I need to show you how to use an array of records to simulate
    a deck of playing cards.
  id: totrans-2736
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书结束之前，我需要向你展示如何使用记录数组来模拟一副扑克牌。
- en: 1 class Card 2 {
  id: totrans-2737
  prefs: []
  type: TYPE_NORMAL
  zh: 1 类卡片2 {
- en: int value;
  id: totrans-2738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: int value;
- en: String suit;
  id: totrans-2739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: String suit;
- en: String name;
  id: totrans-2740
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: String name;
- en: '6'
  id: totrans-2741
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: 7 public String toString() 8 {
  id: totrans-2742
  prefs: []
  type: TYPE_NORMAL
  zh: 7 public String toString() 8 {
- en: 9 return name + " of " + suit; 10 }
  id: totrans-2743
  prefs: []
  type: TYPE_NORMAL
  zh: 9 返回名称+ "of"+ suit; 10 }
- en: 11 }
  id: totrans-2744
  prefs: []
  type: TYPE_NORMAL
  zh: 11 }
- en: '12'
  id: totrans-2745
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: 13 public class PickACard 14 {
  id: totrans-2746
  prefs: []
  type: TYPE_NORMAL
  zh: 13 public class PickACard 14 {
- en: 15 public static void main( String[] args ) 16 {
  id: totrans-2747
  prefs: []
  type: TYPE_NORMAL
  zh: 15 public static void main（String[] args）16 {
- en: Card[] deck = buildDeck();
  id: totrans-2748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Card[] deck = buildDeck();
- en: // displayDeck(deck); 19
  id: totrans-2749
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: // displayDeck(deck); 19
- en: int chosen = (int)(Math.random()*deck.length);
  id: totrans-2750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: int chosen =（int）（Math.random（）* deck.length）;
- en: Card picked = deck[chosen]; 22
  id: totrans-2751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Card picked = deck[chosen]; 22
- en: System.out.println("You picked a " + picked + " out of the deck.");
  id: totrans-2752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println("你从牌组中挑选了" + picked + "。");
- en: System.out.println("In Blackjack your card is worth " + picked.value + "
  id: totrans-2753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: System.out.println("在二十一点中，你的牌值为" + picked.value + "
- en: points.");
  id: totrans-2754
  prefs: []
  type: TYPE_NORMAL
  zh: 点。");
- en: '25'
  id: totrans-2755
  prefs: []
  type: TYPE_NORMAL
  zh: '25'
- en: '}'
  id: totrans-2756
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '26'
  id: totrans-2757
  prefs: []
  type: TYPE_NORMAL
  zh: '26'
- en: '27'
  id: totrans-2758
  prefs: []
  type: TYPE_NORMAL
  zh: '27'
- en: public static Card[] buildDeck()
  id: totrans-2759
  prefs: []
  type: TYPE_NORMAL
  zh: public static Card[] buildDeck（）
- en: '28'
  id: totrans-2760
  prefs: []
  type: TYPE_NORMAL
  zh: '28'
- en: '{'
  id: totrans-2761
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '29'
  id: totrans-2762
  prefs: []
  type: TYPE_NORMAL
  zh: '29'
- en: String[] suits = { "clubs", "diamonds", "hearts", "spades" };
  id: totrans-2763
  prefs: []
  type: TYPE_NORMAL
  zh: String[] suits = { "clubs", "diamonds", "hearts", "spades" };
- en: '30'
  id: totrans-2764
  prefs: []
  type: TYPE_NORMAL
  zh: '30'
- en: String[] names = { "ZERO", "ONE", "two", "three", "four", "five", "six",
  id: totrans-2765
  prefs: []
  type: TYPE_NORMAL
  zh: String[] names = { "ZERO", "ONE", "two", "three", "four", "five", "six",
- en: '31'
  id: totrans-2766
  prefs: []
  type: TYPE_NORMAL
  zh: '31'
- en: '"seven", "eight", "nine", "ten", "Jack", "Queen", "King", "Ace" };'
  id: totrans-2767
  prefs: []
  type: TYPE_NORMAL
  zh: '"seven", "eight", "nine", "ten", "Jack", "Queen", "King", "Ace" };'
- en: '32'
  id: totrans-2768
  prefs: []
  type: TYPE_NORMAL
  zh: '32'
- en: '33'
  id: totrans-2769
  prefs: []
  type: TYPE_NORMAL
  zh: '33'
- en: int i = 0;
  id: totrans-2770
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 0;
- en: '34'
  id: totrans-2771
  prefs: []
  type: TYPE_NORMAL
  zh: '34'
- en: Card[] deck = new Card[52];
  id: totrans-2772
  prefs: []
  type: TYPE_NORMAL
  zh: Card[] deck = new Card[52];
- en: '35'
  id: totrans-2773
  prefs: []
  type: TYPE_NORMAL
  zh: '35'
- en: '36'
  id: totrans-2774
  prefs: []
  type: TYPE_NORMAL
  zh: '36'
- en: 'for ( String s: suits )'
  id: totrans-2775
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（String s：suits）
- en: '37'
  id: totrans-2776
  prefs: []
  type: TYPE_NORMAL
  zh: '37'
- en: '{'
  id: totrans-2777
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '38'
  id: totrans-2778
  prefs: []
  type: TYPE_NORMAL
  zh: '38'
- en: for ( int v = 2; v <= 14 ; v++ )
  id: totrans-2779
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（int v = 2; v <= 14; v ++）
- en: '39'
  id: totrans-2780
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: '{'
  id: totrans-2781
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '40'
  id: totrans-2782
  prefs: []
  type: TYPE_NORMAL
  zh: '40'
- en: Card c = new Card();
  id: totrans-2783
  prefs: []
  type: TYPE_NORMAL
  zh: Card c = new Card();
- en: '41'
  id: totrans-2784
  prefs: []
  type: TYPE_NORMAL
  zh: '41'
- en: c.suit = s;
  id: totrans-2785
  prefs: []
  type: TYPE_NORMAL
  zh: c.suit = s;
- en: '42'
  id: totrans-2786
  prefs: []
  type: TYPE_NORMAL
  zh: '42'
- en: c.name = names[v];
  id: totrans-2787
  prefs: []
  type: TYPE_NORMAL
  zh: c.name = names[v];
- en: '43'
  id: totrans-2788
  prefs: []
  type: TYPE_NORMAL
  zh: '43'
- en: if ( v == 14 )
  id: totrans-2789
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（v == 14）
- en: '44'
  id: totrans-2790
  prefs: []
  type: TYPE_NORMAL
  zh: '44'
- en: c.value = 11;
  id: totrans-2791
  prefs: []
  type: TYPE_NORMAL
  zh: c.value = 11;
- en: '45'
  id: totrans-2792
  prefs: []
  type: TYPE_NORMAL
  zh: '45'
- en: else if ( v > 10 )
  id: totrans-2793
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果（v > 10）
- en: '46'
  id: totrans-2794
  prefs: []
  type: TYPE_NORMAL
  zh: '46'
- en: c.value = 10;
  id: totrans-2795
  prefs: []
  type: TYPE_NORMAL
  zh: c.value = 10;
- en: '47'
  id: totrans-2796
  prefs: []
  type: TYPE_NORMAL
  zh: '47'
- en: else
  id: totrans-2797
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '48'
  id: totrans-2798
  prefs: []
  type: TYPE_NORMAL
  zh: '48'
- en: c.value = v;
  id: totrans-2799
  prefs: []
  type: TYPE_NORMAL
  zh: c.value = v;
- en: '49'
  id: totrans-2800
  prefs: []
  type: TYPE_NORMAL
  zh: '49'
- en: '50'
  id: totrans-2801
  prefs: []
  type: TYPE_NORMAL
  zh: '50'
- en: deck[i] = c;
  id: totrans-2802
  prefs: []
  type: TYPE_NORMAL
  zh: deck[i] = c;
- en: '51'
  id: totrans-2803
  prefs: []
  type: TYPE_NORMAL
  zh: '51'
- en: i++;
  id: totrans-2804
  prefs: []
  type: TYPE_NORMAL
  zh: i++;
- en: '52'
  id: totrans-2805
  prefs: []
  type: TYPE_NORMAL
  zh: '52'
- en: '}'
  id: totrans-2806
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '53'
  id: totrans-2807
  prefs: []
  type: TYPE_NORMAL
  zh: '53'
- en: '}'
  id: totrans-2808
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '54'
  id: totrans-2809
  prefs: []
  type: TYPE_NORMAL
  zh: '54'
- en: return deck;
  id: totrans-2810
  prefs: []
  type: TYPE_NORMAL
  zh: 返回牌组;
- en: '55'
  id: totrans-2811
  prefs: []
  type: TYPE_NORMAL
  zh: '55'
- en: '}'
  id: totrans-2812
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '56'
  id: totrans-2813
  prefs: []
  type: TYPE_NORMAL
  zh: '56'
- en: '57'
  id: totrans-2814
  prefs: []
  type: TYPE_NORMAL
  zh: '57'
- en: public static void displayDeck( Card[] deck )
  id: totrans-2815
  prefs: []
  type: TYPE_NORMAL
  zh: public static void displayDeck（Card[] deck）
- en: '58'
  id: totrans-2816
  prefs: []
  type: TYPE_NORMAL
  zh: '58'
- en: '{'
  id: totrans-2817
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '59'
  id: totrans-2818
  prefs: []
  type: TYPE_NORMAL
  zh: '59'
- en: 'for ( Card c : deck )'
  id: totrans-2819
  prefs: []
  type: TYPE_NORMAL
  zh: 对于（Card c：deck）
- en: '60'
  id: totrans-2820
  prefs: []
  type: TYPE_NORMAL
  zh: '60'
- en: System.out.println(c.value + "\t" + c);
  id: totrans-2821
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(c.value + "\t" + c);
- en: '61'
  id: totrans-2822
  prefs: []
  type: TYPE_NORMAL
  zh: '61'
- en: '}'
  id: totrans-2823
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '62'
  id: totrans-2824
  prefs: []
  type: TYPE_NORMAL
  zh: '62'
- en: '}'
  id: totrans-2825
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: What You Should See
  id: totrans-2826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你应该看到的
- en: '[PRE664]'
  id: totrans-2827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: Of course, even though this is almost the final exercise, I can’t resist sneaking
    in some more new things in. You want to learn something new, don’t you?
  id: totrans-2828
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使这几乎是最后一个练习，我也忍不住加入了一些新东西。你想学点新东西，不是吗？
- en: First of all, I snuck a function into the record. (Actually, because this function
    is inside a class it isn’t a function but a “method”.)
  id: totrans-2829
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我在记录中偷偷加了一个函数。（实际上，因为这个函数在一个类中，它不是一个函数，而是一个“方法”。）
- en: This method is named toString. It has no parameters and returns a `String`.
    In the body of this method we create a String by concatenating the name field,
    the suit field, and the word `" of "`. The method doesn’t need any parameters
    because it has access to the fields of the record. (In fact, that is what makes
    it a “method” and not a “function”.)
  id: totrans-2830
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法被命名为toString。它没有参数，并返回一个`String`。在这个方法的主体中，我们通过连接名称字段、花色字段和单词“of”来创建一个字符串。这个方法不需要任何参数，因为它可以访问记录的字段。（事实上，这就是它成为“方法”而不是“函数”的原因。）
- en: 'Otherwise, the `Card`  record is hopefully what you would expect: it has fields
    for the value of the card (2­11), the suit name and the name of the card itself.'
  id: totrans-2831
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，`Card`记录应该是你期望的：它有卡的值（2-11）、花色名称和卡本身的名称的字段。
- en: On lines 17 though 24 you can see the `main()`, which is really short. Line
    17 declares an array of cards and initializes it using the return value of the
    `buildDeck()`  function.
  id: totrans-2832
  prefs: []
  type: TYPE_NORMAL
  zh: 在第17到24行，你可以看到`main()`，它真的很短。第17行声明了一个卡片数组，并使用`buildDeck()`函数的返回值进行初始化。
- en: Line 18 is commented out, but when I was writing this program originally I used
    the `displayDeck()`
  id: totrans-2833
  prefs: []
  type: TYPE_NORMAL
  zh: 第18行被注释掉了，但当我最初编写这个程序时，我使用了`displayDeck()`
- en: function to make sure that `buildDeck()`  was working correctly.
  id: totrans-2834
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`buildDeck()`函数是否正常工作。
- en: Line 20 chooses a random number between `0`  and `deck.length ­ 1`. You might
    notice that this is exactly the range of legal indexes into the array, and that
    is not a coincidence.
  id: totrans-2835
  prefs: []
  type: TYPE_NORMAL
  zh: 第20行选择了一个介于`0`和`deck.length - 1`之间的随机数。你可能会注意到这恰好是数组中合法索引的范围，这不是巧合。
- en: In fact, you could also say that line 20 chooses a random index into the array
    or that line 20 chooses a slot of the array randomly.
  id: totrans-2836
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你也可以说第20行选择了数组中的一个随机索引，或者第20行随机选择了数组的一个槽位。
- en: Then on line 21 we declare a new Card variable called *picked* and give it a
    value from the randomly­chosen slot of the array.
  id: totrans-2837
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第21行，我们声明了一个新的Card变量*picked*，并给它一个从数组中随机选择的值。
- en: Line 23 looks pretty boring but there is actually magic happening. What type
    of variable is *picked*? It is a Card. Normally when you try to print an entire
    record on the screen like this, Java doesn’t know which fields you want printed
    or in what order so it just prints garbage on the screen. (You saw that in the
    Study Drill for the previous exercise, right?)
  id: totrans-2838
  prefs: []
  type: TYPE_NORMAL
  zh: 第23行看起来相当无聊，但实际上发生了魔法。*picked*是什么类型的变量？它是一张卡。通常当你尝试像这样在屏幕上打印整个记录时，Java不知道你想要打印哪些字段或以什么顺序打印，所以它只是在屏幕上打印垃圾。（你在上一个练习的学习中看到了吧？）
- en: But if you provide a method called `toString()`  inside your record, which returns
    a `String`  and has no parameters, then in a situation like this Java will call
    that method behind the scenes. It will take the return value and print that out
    instead of garbage.
  id: totrans-2839
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在记录中提供了一个名为`toString()`的方法，它返回一个`String`并且没有参数，那么在这种情况下，Java将在幕后调用该方法。它将获取返回值并打印出来，而不是垃圾。
- en: So line 23 will print on the screen the result of running the picked card’s
    `toString()`  method. By contrast, line 24 really is boring. It prints out the
    value field of the chosen card.
  id: totrans-2840
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第23行将在屏幕上打印出运行所选卡的`toString()`方法的结果。相比之下，第24行确实很无聊。它打印出所选卡的值字段。
- en: Before we get to `buildDeck()`, which is the most complex part of this exercise,
    let us skip down to the `displayDeck()`  function. `displayDeck()`  expects you
    to pass in an array of `Card`s as an argument.
  id: totrans-2841
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始`buildDeck()`，这是这个练习中最复杂的部分之前，让我们跳到`displayDeck()`函数。`displayDeck()`期望你传入一个`Card`数组作为参数。
- en: 'Then on line 59 we see something we haven’t seen for a few exercises: a foreach
    loop. This says “for each Card c in the deck…” And since there is only one line
    of code in the body of this `for`  loop, I omitted the curly braces.'
  id: totrans-2842
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第59行，我们看到了一些我们在前几个练习中没有见过的东西：一个foreach循环。这表示“对于牌组中的每张卡……”由于这个`for`循环的主体中只有一行代码，我省略了花括号。
- en: Line 60 displays the value of the current card, a tab, and then the result of
    calling the `toString()`
  id: totrans-2843
  prefs: []
  type: TYPE_NORMAL
  zh: 第60行显示了当前卡片的值，一个制表符，然后调用`toString()`的结果。
- en: method on behalf of Card *c*.
  id: totrans-2844
  prefs: []
  type: TYPE_NORMAL
  zh: 代表Card *c*的方法。
- en: 'Okay, let us tackle this `buildDeck()`  function. `buildDeck()`  doesn’t need
    any parameters because it just creates the deck out of nothing. It does return
    a value, though: an array of Cards.'
  id: totrans-2845
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们来解决这个`buildDeck()`函数。`buildDeck()`不需要任何参数，因为它只是从无中创建牌组。不过它确实返回一个值：一组卡片。
- en: On lines 29 through 31 we create two arrays of Strings. The first one (on line
    29) contains the names of the suits. The second one contains the names of the
    cards.
  id: totrans-2846
  prefs: []
  type: TYPE_NORMAL
  zh: 在第29到31行，我们创建了两个字符串数组。第一个（第29行）包含了花色的名称。第二个包含了卡片的名称。
- en: You may notice that I have a card called `"ZERO"`  and another called `"ONE"`.
    Why? This is so I can this array as a “lookup table”. I am going to write my loop
    so that my card values go from `2`  through `14`  and I want the word `"two"`  to
    have index `2`  in this array. So I needed to put some Strings into slots `0`  and
    `1`  to take up space.
  id: totrans-2847
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到我有一张叫做“ZERO”的卡片，另一张叫做“ONE”的卡片。为什么？这是为了我可以把这个数组当作“查找表”来使用。我将写我的循环，使得我的卡片值从`2`到`14`，我希望单词“two”在这个数组中的索引是`2`。所以我需要把一些字符串放到槽位`0`和`1`中来占用空间。
- en: 'Originally I had just put in two empty Strings like so:'
  id: totrans-2848
  prefs: []
  type: TYPE_NORMAL
  zh: 最初我只是放了两个空字符串，如下所示：
- en: '[PRE665]'
  id: totrans-2849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: …but then I was worried that if I had a bug in my code it would be hard to tell
    if nothing was being printed or if it was the value of `names[0]`  (or `names[1]`).
    So I put words in for those two indexes but made them all­caps so it would catch
    my attention if they got printed out.
  id: totrans-2850
  prefs: []
  type: TYPE_NORMAL
  zh: '...但后来我担心如果我的代码有bug，那么很难判断是没有打印任何内容还是`names[0]`（或`names[1]`）的值。因此，我为这两个索引放入了单词，但将它们全部大写，这样如果它们被打印出来，我就会注意到。'
- en: On line 33 we create i, which will keep track of which index needs to have a
    Card put into it next. And line 34 defines our array of 52 cards (indexed `0`
    through ``51`).
  id: totrans-2851
  prefs: []
  type: TYPE_NORMAL
  zh: 在第33行，我们创建了i，它将跟踪下一个需要放入卡片的索引。第34行定义了我们的52张卡片的数组（从0到51索引）。
- en: Line 36 is another foreach loop. The variable s is going to be set equal to
    `"clubs"`, then
  id: totrans-2852
  prefs: []
  type: TYPE_NORMAL
  zh: 第36行是另一个foreach循环。变量s将被设置为“clubs”，然后
- en: '`"diamonds"`, then `"hearts"`  and then finally `"spades"`.'
  id: totrans-2853
  prefs: []
  type: TYPE_NORMAL
  zh: “方块”，然后“红心”，最后“黑桃”。
- en: Line 38 is another `for`  loop but this one is nested. Remember that means that
    this loop is going to make
  id: totrans-2854
  prefs: []
  type: TYPE_NORMAL
  zh: 第38行是另一个`for`循环，但这个循环是嵌套的。记住这意味着这个循环将进行
- en: v go from `2`  through `14`  before the outer loop ever changes s from `"clubs"`.
  id: totrans-2855
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部循环改变s的值之前，v会从2到14变化。
- en: Line 40 defines a Card named c. On line 41 we set the suit field of this card
    to whatever value is currently in s (`"clubs"`, at first).
  id: totrans-2856
  prefs: []
  type: TYPE_NORMAL
  zh: 第40行定义了一个名为c的Card。在第41行，我们将这张卡的花色字段设置为当前s中的任何值（一开始是“clubs”）。
- en: Depending on which time through the loop this is, v will be some value between
    `2`  and `14`, so on line 42 we use v as an index into the names array. That is,
    when v is `5`  we go into the sixth(!) slot of the array, where we will find the
    String `"five"`. We put a copy of this value into the name field of the current
    card.
  id: totrans-2857
  prefs: []
  type: TYPE_NORMAL
  zh: 根据循环的次数，v将是2到14之间的某个值，所以在第42行，我们使用v作为names数组的索引。也就是说，当v是5时，我们进入数组的第六个位置，那里会找到字符串“five”。我们将这个值的副本放入当前卡片的名称字段。
- en: Lines 43 through 48 store an integer from `2`  to `11`  into the value field
    of the current card. We needed v to go from 2­14 for our lookup table, but now
    that that is already done, we need to make sure that no card gets a value of 12­14.
  id: totrans-2858
  prefs: []
  type: TYPE_NORMAL
  zh: 第43到48行将一个从2到11的整数存储到当前卡片的值字段中。我们需要v从2到14进行查找表，但现在已经完成了，我们需要确保没有卡片的值为12到14。
- en: Card number `14`  is the ace, so we use `11`  for the card value. Then card
    numbers `11`, `12`  and `13`  are the face cards, so they all have `10`  for their
    card values. And any other card value is fine as­is.
  id: totrans-2859
  prefs: []
  type: TYPE_NORMAL
  zh: 第14张卡是A，所以我们使用11作为卡的值。然后第11、12和13张卡是花牌，所以它们的卡值都是10。其他卡的值都可以不变。
- en: Finally we store this card into the next available slot of the *deck* (indexed
    with *i*) and make *i* bigger by 1.
  id: totrans-2860
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将这张卡存储到*deck*的下一个可用槽中（用*i*索引），并使*i*增加1。
- en: When the nested loops finished we have successfully created all 52 cards in
    a standard deck and given them card values that match how they are used in Blackjack.
    Uncomment the call to `displayDeck()`  on line 18 if you want to be sure.
  id: totrans-2861
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌套循环结束时，我们已经成功创建了标准牌组中的所有52张卡，并为它们赋予了与二十一点中使用方式相匹配的卡值。如果您想要确保，可以取消注释第18行上的`displayDeck()`调用。
- en: The last thing that `buildDeck()`  needs to do is `return`  the now­full array
    of Cards so it can be stored into the deck variable on line 17 of `main()`.
  id: totrans-2862
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildDeck()`的最后一步是`return`现在已经填满的Cards数组，这样它就可以存储到`main()`第17行的deck变量中。'
- en: Study Drills
  id: totrans-2863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习练习
- en: Add a function called `shuffleDeck()`. It should take in an array of cards as
    a parameter and return an array of cards. One way to shuffle is to choose two
    random numbers from 0­51 and “swap” the cards in those slots. Then put that code
    in a loop that repeats 1000 times or so. This is a bit tricky to get right.
  id: totrans-2864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`shuffleDeck()`的函数。它应该以一组卡片的数组作为参数，并返回一组卡片。一种洗牌的方法是从0到51选择两个随机数，并“交换”这些槽中的卡片。然后将该代码放入一个重复大约1000次的循环中。这有点难以做到正确。
- en: 'Exercise 58: Final Project ­ Text Adventure Game'
  id: totrans-2865
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习58：最终项目-文本冒险游戏
- en: If you have done all the exercises up to this point, then you should be ready
    for this final project. It is longer than any other exercise that you have done,
    but it isn’t much more difficult than the last few.
  id: totrans-2866
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了到目前为止的所有练习，那么您应该准备好进行这个最终项目了。它比您之前做过的任何练习都要长，但比最近几个练习并不难。
- en: Your final exercise is a text­based adventure game *engine*. By *engine* I mean
    that the code doesn’t know anything about the adventure itself; the game is determined
    100% by what is in the file. Change the file and you change the game play.
  id: totrans-2867
  prefs: []
  type: TYPE_NORMAL
  zh: 您的最终练习是基于文本的冒险游戏*引擎*。通过*引擎*，我的意思是代码对冒险本身一无所知；游戏的进行完全取决于文件中的内容。更改文件就会改变游戏的进行。
- en: So start by downloading a copy of the game data file and saving it into the
    same folder as you are going to put your code.
  id: totrans-2868
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先要下载游戏数据文件的副本，并将其保存到与您要放置代码的相同文件夹中。
- en: '[http://learnjavathehardway.org/txt/text­adventure­rooms.txt](http://learnjavathehardway.org/txt/text-adventure-rooms.txt)'
  id: totrans-2869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://learnjavathehardway.org/txt/text­adventure­rooms.txt](http://learnjavathehardway.org/txt/text-adventure-rooms.txt)'
- en: '[PRE666]'
  id: totrans-2870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: Then, better get started typing. This is a long one, but I think it will be
    worth it.
  id: totrans-2871
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最好开始打字。这是一个很长的练习，但我认为它会很值得。
- en: '[PRE667]'
  id: totrans-2872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-2873
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-2874
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-2875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-2876
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-2877
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-2878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-2879
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-2880
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-2881
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-2882
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-2883
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-2884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-2885
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-2886
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-2887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: '[PRE683]'
  id: totrans-2888
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-2889
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-2890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-2891
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-2892
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-2893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-2894
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-2895
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-2896
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-2897
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-2898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-2899
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-2900
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-2901
  prefs:
  - PREF_OL
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-2902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: '[PRE698]'
  id: totrans-2903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-2904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: What You Should See
  id: totrans-2905
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您应该看到的内容
- en: '[PRE700]'
  id: totrans-2906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-2907
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-2908
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-2909
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-2910
  prefs:
  - PREF_UL
  type: TYPE_PRE
  zh: '[PRE704]'
- en: Before I start talking about the code, let me take a moment to talk about the
    adventure game “file format”.
  id: totrans-2911
  prefs: []
  type: TYPE_NORMAL
  zh: 在我开始讨论代码之前，让我花点时间谈谈冒险游戏的“文件格式”。
- en: The game consists of several “rooms”. Each room has a room number and a room
    name; these are only used for the game engine and are never shown to the player.
  id: totrans-2912
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏由几个“房间”组成。每个房间都有一个房间号和一个房间名称；这些只用于游戏引擎，玩家看不到。
- en: Each room also has a description and one or more “exits”, which is a path to
    another room.
  id: totrans-2913
  prefs: []
  type: TYPE_NORMAL
  zh: 每个房间还有一个描述和一个或多个“出口”，这是通往另一个房间的路径。
- en: 'The adventure game file starts with a number: the total number of locations
    (rooms) in the game. After that are records for each room. Here’s an example:'
  id: totrans-2914
  prefs: []
  type: TYPE_NORMAL
  zh: 冒险游戏文件以一个数字开头：游戏中的位置（房间）的总数。之后是每个房间的记录。这是一个例子：
- en: '[PRE705]'
  id: totrans-2915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: The first line of this record is the room number, so this is room number 1\.
    The second line of the record is the room name, which we only use for debugging.
  id: totrans-2916
  prefs: []
  type: TYPE_NORMAL
  zh: 这个记录的第一行是房间号，所以这是房间号1。记录的第二行是房间名称，我们只用于调试。
- en: Starting with the third line of the record is the description of the room, which
    continues until there is a line with nothing but `%%`  on it. Blank lines are
    allowed in the description.
  id: totrans-2917
  prefs: []
  type: TYPE_NORMAL
  zh: 从记录的第三行开始是房间的描述，一直到有一行只有`%%`的行为止。描述中允许有空行。
- en: After the first double­percent there is a list of exits. Each line has the name
    of the exit (what the player will type to take that route) followed by a colon,
    followed by the room number where that exit leads.
  id: totrans-2918
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个双百分号之后是一个出口列表。每一行都有出口的名称（玩家输入的内容）后跟一个冒号，再跟着出口通往的房间号。
- en: 'For example, in this room if the player types `"fridge"`  then the game engine
    will move them from this room (room #1) into room #3\. And if they type `"go back"`  then
    they will “travel” to room #0 instead. You may notice that in order to make it
    easier for the player to decide what to type I have duplicate exits in the list.
    Either the word `"fridge"`  or `"refrigerator"`  will take them to room #3.'
  id: totrans-2919
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个房间，如果玩家输入`"fridge"`，游戏引擎将把他们从这个房间（房间＃1）移动到房间＃3。如果他们输入`"go back"`，他们将“旅行”到房间＃0。您可能会注意到，为了让玩家更容易决定输入什么，我在列表中有重复的出口。无论是`"fridge"`还是`"refrigerator"`都会把他们带到房间＃3。
- en: The list of exits ends with another line containing only `%%`. And that’s the
    end of the record.
  id: totrans-2920
  prefs: []
  type: TYPE_NORMAL
  zh: 出口列表以另一行只包含`%%`的行结束。这就是记录的结尾。
- en: Okay, now let’s turn to the code. Lines 3 through 11 declare the record for
    one room. You can see we have fields for everything in the adventure game file.
    The only thing you might not have guessed is that the array of exit Strings (exits)
    and the array of destination room numbers (destinations) have an arbitrary capacity
    of `10`  and then there’s a numExits field to keep track of how many exits there
    actually are in this room. Feel free to make this capacity larger if you think
    you’ll need more than 10 exits in a room.
  id: totrans-2921
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们转向代码。第3到11行声明了一个房间的记录。您可以看到我们为冒险游戏文件中的每个字段都有字段。您可能没有猜到的唯一一件事是，出口字符串数组（出口）和目的地房间号数组（目的地）的任意容量为`10`，然后有一个numExits字段来跟踪这个房间实际上有多少出口。如果您认为一个房间需要超过10个出口，请随时将此容量增加。
- en: Moving into `main()`, line 20 declares the array of rooms and initializes it
    from the
  id: totrans-2922
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`main()`，第20行声明了房间数组并从中初始化。
- en: '`loadRoomsFromFile()`  function that I will explain later.'
  id: totrans-2923
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadRoomsFromFile()`函数，稍后我会解释。'
- en: Line 22 has a commented­out call to a `showAllRooms()`  function that I use
    for debugging.
  id: totrans-2924
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行有一个注释掉的`showAllRooms()`函数调用，我用于调试。
- en: On line 25 you will see the definition of our currentRoom variable, which holds
    the room number of the room the player is inside. They start in room `0`, which
    is the first room in the file. And on line 26 is the declaration of the `String`  ans,
    which will hold whatever the player types.
  id: totrans-2925
  prefs: []
  type: TYPE_NORMAL
  zh: 在第25行，您将看到我们当前房间变量的定义，它保存了玩家所在房间的房间号。他们从房间`0`开始，这是文件中的第一个房间。在第26行是`String` ans的声明，它将保存玩家输入的内容。
- en: 'Line 27 is the beginning of the main game loop. It repeats as long as the currentRoom
    variable is `0`  or more. So we will use this to stop the game: when the player
    dies (or wins) we will set currentRoom equal to `­1`.'
  id: totrans-2926
  prefs: []
  type: TYPE_NORMAL
  zh: 第27行是主游戏循环的开始。只要currentRoom变量为`0`或更多，它就会重复。因此，我们将使用它来停止游戏：当玩家死亡（或获胜）时，我们将currentRoom设置为`-1`。
- en: The array rooms contains a list of all the locations in the game. The number
    of the room containing the player is stored in the variable currentRoom. So `rooms[currentRoom]`  is
    the entire record for the… um, current room. In line 29 we store a copy of this
    room into the `Room`  variable cur. (I only do this because I’m lazy and want
    to type things like `cur.description`  instead of `rooms[currentRoom].description`.)
  id: totrans-2927
  prefs: []
  type: TYPE_NORMAL
  zh: 数组rooms包含游戏中所有位置的列表。包含玩家的房间号的房间的变量currentRoom存储在变量中。因此，`rooms[currentRoom]`是整个房间的记录...嗯，当前房间。在第29行，我们将这个房间的副本存储到`Room`变量cur中。（我这样做只是因为我懒，想要输入像`cur.description`而不是`rooms[currentRoom].description`这样的东西。）
- en: Speaking of which, line 30 prints out the description of the current room, which
    is stored in the
  id: totrans-2928
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，第30行打印出当前房间的描述，它存储在
- en: description field.
  id: totrans-2929
  prefs: []
  type: TYPE_NORMAL
  zh: 描述字段。
- en: On lines 31 and 32 we print out a little prompt and let the player enter in
    a String for where they want to go.
  id: totrans-2930
  prefs: []
  type: TYPE_NORMAL
  zh: 在第31和32行，我们打印出一个小提示，并让玩家输入他们想去的地方的字符串。
- en: Lines 36 through 44 search through this room’s array of exits looking to see
    if any of them match what the player typed. Remember that the exits array has
    a capacity of `10`, but there are probably not that many exits actually present
    in this room. So in the `for`  loop we count up to the value of the numExits field
    instead of `10`.
  id: totrans-2931
  prefs: []
  type: TYPE_NORMAL
  zh: 第36到44行搜索这个房间的出口数组，看看它们是否与玩家输入的内容匹配。请记住，出口数组的容量为`10`，但实际上这个房间可能并没有那么多出口。因此，在`for`循环中，我们计数到numExits字段的值，而不是`10`。
- en: If we find an exit that matches the player’s command, we set our flag to `true`  (so
    we know if we should complain if they end up typing something that’s not in our
    list). Then since the words in the exits array line up with the room numbers in
    the destinations array, we pull the room number out of the corresponding slot
    of the destinations array and make that our new room number. This way, when the
    main game loop repeats again, we will have automatically traveled to the new room.
  id: totrans-2932
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找到与玩家命令匹配的出口，我们将标志设置为`true`（这样我们就知道如果他们最终输入了我们列表中没有的内容，我们应该抱怨）。然后，由于出口数组中的单词与目的地数组中的房间号相对应，我们从目的地数组的相应槽中取出房间号，并将其作为我们的新房间号。这样，当主游戏循环再次重复时，我们将自动前往新的房间。
- en: On line 45 we check our flag. If it’s still `false`, it means the human typed
    something we never found in the list of exits. We can politely complain. Because
    currentRoom hasn’t changed, looping around again in the main game loop will just
    print out the description again for the room they were already in.
  id: totrans-2933
  prefs: []
  type: TYPE_NORMAL
  zh: 在第45行，我们检查我们的标志。如果它仍然是`false`，这意味着用户输入了我们在出口列表中从未找到的东西。我们可以礼貌地抱怨。因为当前房间没有改变，所以在主游戏循环中再次循环将只是再次打印出他们已经在的房间的描述。
- en: And that’s the end of the main game loop and the end of `main()`. All that’s
    left is to actually fill up the array of rooms from the adventure game file.
  id: totrans-2934
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是主游戏循环的结束，也是`main()`的结束。剩下的就是从冒险游戏文件中实际填充房间数组。
- en: Line 51 is the beginning of the `loadRoomsFromFile()`  function, which takes
    the filename to open as a parameter and returns an array of `Room`s.
  id: totrans-2935
  prefs: []
  type: TYPE_NORMAL
  zh: 第51行是`loadRoomsFromFile()`函数的开始，它以要打开的文件名作为参数，并返回一个`Room`数组。
- en: (I decided that I didn’t want to have `throws Exception`  anywhere in this file,
    so there’s a try­catch block here. It opens the file.
  id: totrans-2936
  prefs: []
  type: TYPE_NORMAL
  zh: （我决定在这个文件中不想有`throws Exception`，所以这里有一个try-catch块。它打开文件。
- en: If we make it down to line 64 it means the file was opened successfully. We
    read in the first line of the file to tell us how many rooms there are. Then line
    65 defines an array of Room records with the appropriate capacity.
  id: totrans-2937
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们成功到达第64行，这意味着文件已成功打开。我们读取文件的第一行，告诉我们有多少个房间。然后第65行定义了一个具有适当容量的Room记录数组。
- en: 'On line 68 I made a variable called roomNum, which has a dual purpose. First
    of all: it is the index for the next available slot in the room array. But secondly,
    it is used to double­check that the room number (from the file) and the slot number
    of the room are the same. If not, there’s probably some sort­of error in the game’s
    data file. If we detect such an error (on line 72), we complain and end the program.
    (`System.exit()`  ends the program, even from inside a function call.)'
  id: totrans-2938
  prefs: []
  type: TYPE_NORMAL
  zh: 在第68行，我创建了一个名为roomNum的变量，它有双重作用。首先：它是房间数组中下一个可用槽的索引。但其次，它用于双重检查文件中的房间号和房间的槽号是否相同。如果不是，游戏数据文件中可能存在某种错误。如果我们在这里检测到这样的错误（在第72行），我们会抱怨并结束程序。（`System.exit()`结束程序，即使是在函数调用内部。）
- en: 'Line 69 is the beginning of the “read all rooms” loop. It keeps going as long
    as there is stuff in the file we haven’t seen yet. There’s a potential error here:
    if the number of rooms at the top of your data file is a lie, then this loop could
    go too far in the array and blow up. (For example, if the first line of the file
    says you only have 7 rooms but then you have 8 room records then this loop will
    repeat too many times.)'
  id: totrans-2939
  prefs: []
  type: TYPE_NORMAL
  zh: 第69行是“读取所有房间”的循环的开始。只要文件中还有未见过的内容，它就会继续进行。这里存在潜在的错误：如果数据文件顶部的房间数量是错误的，那么这个循环可能会在数组中走得太远并导致错误。（例如，如果文件的第一行说你只有7个房间，但实际上有8个房间记录，那么这个循环将重复太多次。）
- en: On line 71 we get read a single room record using the `getRoom()`  function
    I’ll explain later.
  id: totrans-2940
  prefs: []
  type: TYPE_NORMAL
  zh: 在第71行，我们使用`getRoom()`函数读取单个房间记录，我稍后会解释。
- en: Lines 72 through 76 are the room number sanity check I already mentioned, and
    then line 77 just stores this new room into the next available slot in the rooms
    array. And line 78 increments the room index.
  id: totrans-2941
  prefs: []
  type: TYPE_NORMAL
  zh: 第72到76行是我已经提到的房间号健全性检查，然后第77行只是将这个新房间存储到房间数组的下一个可用槽中。第78行增加了房间索引。
- en: After that loop is over, all the rooms have been read in from the file and stored
    each into their own slot of the array. So on line 82 we can return the array of
    rooms back up to line 20 of `main()`.
  id: totrans-2942
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，所有房间都已从文件中读取并存储在数组的各自位置。因此，在第82行，我们可以将房间数组返回到`main()`的第20行。
- en: Lines 85 through 94 are the `showAllRooms()`  function that I use for debugging.
    It just displays all the rooms in the array on the screen, and for each room it
    also shows all the exits and where they lead.
  id: totrans-2943
  prefs: []
  type: TYPE_NORMAL
  zh: 第85到94行是我用于调试的`showAllRooms()`函数。它只是在屏幕上显示数组中的所有房间，并且对于每个房间，它还显示所有的出口以及它们的目的地。
- en: Our final function is `getRoom()`, which expects a Scanner object to be passed
    in as a parameter and which returns a single Room object.
  id: totrans-2944
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个函数是`getRoom()`，它期望传入一个Scanner对象作为参数，并返回一个单独的Room对象。
- en: On lines 99 and 100 there is a simple sanity check in case there is a malformatted
    data file. If the next
  id: totrans-2945
  prefs: []
  type: TYPE_NORMAL
  zh: 在第99和100行，如果数据文件格式不正确，会进行简单的健全性检查。如果下一个
- en: thing in the file is not an integer, then just return `null`  (the value of
    an uninitialized object). Putting a `return`  up here will return from the function
    right away without bothering to run any of the remaining code.
  id: totrans-2946
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中的东西不是整数，那么只需返回`null`（未初始化对象的值）。在这里放置一个`return`将立即从函数中返回，而不必运行剩下的代码。
- en: On line 102 the empty room object is defined. Line 103 creates a String called
    *line*, which I use for a couple of different things.
  id: totrans-2947
  prefs: []
  type: TYPE_NORMAL
  zh: 在第102行定义了空房间对象。第103行创建了一个名为*line*的字符串，我用它来做一些不同的事情。
- en: Line 106 reads in the room number from the file. The room number is the first
    part of the room record. The rest of this function is going to use only the Scanner
    object’s `nextLine()`  method, and a `nextLine()`  after a `nextInt()`  usually
    doesn’t work because it reads only the end of the line after the integer that
    was just read.
  id: totrans-2948
  prefs: []
  type: TYPE_NORMAL
  zh: 第106行从文件中读取房间号。房间号是房间记录的第一部分。这个函数的其余部分将只使用Scanner对象的`nextLine()`方法，而在`nextInt()`之后的`nextLine()`通常不起作用，因为它只读取刚刚读取的整数后面的行尾。
- en: So line 107 calls the `nextLine()`  method but doesn’t bother to store its return
    value anywhere because it doesn’t read anything worth saving.
  id: totrans-2949
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第107行调用`nextLine()`方法，但不必在任何地方存储它的返回值，因为它不会读取任何值值得保存。
- en: Line 109 reads in the room name from the file. We only use this for debugging.
  id: totrans-2950
  prefs: []
  type: TYPE_NORMAL
  zh: 第109行从文件中读取房间名称。我们只在调试时使用这个。
- en: On line 112 we start by setting this room’s description field to an empty String.
    This is so we can add on to it without getting an error. (Just like we would set
    a “total” variable to `0`  before adding to it in a loop.)
  id: totrans-2951
  prefs: []
  type: TYPE_NORMAL
  zh: 在第112行，我们首先将这个房间的描述字段设置为空字符串。这样我们就可以在不出错的情况下添加内容。（就像我们在循环中将“总数”变量设置为`0`一样，然后再进行累加。）
- en: Okay. So I like writing infinite loops. Sue me. Line 113 is the beginning of
    an infinite loop. This is because we don’t know how many lines are going to be
    in the room’s description; it just goes however long until we see a line consisting
    of nothing but `%%`. There are other ways to do this, but I like the “write an
    infinite loop and then break out of it when you see what you’re looking for” approach.
    Like I’ve said before, reasonable people disagree.
  id: totrans-2952
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。我喜欢写无限循环。告我吧。第113行是一个无限循环的开始。这是因为我们不知道房间描述中会有多少行；它会一直持续，直到我们看到一行什么都没有的“%%”。还有其他方法可以做到这一点，但我喜欢“写一个无限循环，然后在找到你要找的东西时跳出它”的方法。就像我以前说过的，理智的人意见不一。
- en: Once we’re inside the “infinite” loop, we read a line of description into the
    line variable. Then, on line 116 we check to see if what we just read was `%%`.
    If so, we don’t want to add it to the description so we `break`  out of the loop.
    `break`  is sort­of like the opposite of `continue`; `continue`  skips back up
    to the condition of a loop and `break`  just skips to the end and stops looping.
  id: totrans-2953
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入“无限”循环，我们就会将描述的一行读入line变量中。然后，在第116行，我们检查刚刚读取的内容是否为“%%”。如果是的话，我们就不想将其添加到描述中，所以我们跳出循环。break有点像continue的相反；continue跳回到循环的条件，而break直接跳到末尾并停止循环。
- en: If we’re still around to see line 118, it means that we read in a line of description
    and it wasn’t `%%`. So we use `+=`  to add that line (and a `\n`) to the end of
    whatever was already in the description field. And the loop repeats. (No matter
    what.)
  id: totrans-2954
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仍然在第118行附近，这意味着我们读入了一行描述，而且它不是“%%”。所以我们使用+=将该行（和一个\n）添加到描述字段的末尾。然后循环重复。（无论如何。）
- en: Eventually we hopefully hit a `%%`  and the loop stops looping.
  id: totrans-2955
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望碰到“%%”，循环就会停止。
- en: Line 122 defines *i*, which I use for the index of which slot in the *exits*
    and *destinations* arrays we’re going to put something in next. And then starting
    on line 123 there’s another infinite loop. I use a very similar approach to read
    in all the exits.
  id: totrans-2956
  prefs: []
  type: TYPE_NORMAL
  zh: 第122行定义了i，我用它来表示exits和destinations数组中我们要放入下一个值的槽的索引。然后从第123行开始又是一个无限循环。我使用了一个非常类似的方法来读取所有的出口。
- en: Line 125 reads in the whole line, which means that line contains something like
    `"refrigerator:3"`. (If it’s not something like that but is actually `%%`, lines
    126 and 127 stop looping.)
  id: totrans-2957
  prefs: []
  type: TYPE_NORMAL
  zh: 第125行读取整行，这意味着该行包含类似于“'refrigerator:3'”的内容。（如果不是这样，而实际上是“%%”，则第126行和第127行停止循环。）
- en: So now we need to split this line into two parts. Fortunately for us, the `String`  class
    has a built­in method called `split()`.
  id: totrans-2958
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在我们需要将这行分成两部分。幸运的是，String类有一个名为split()的内置方法。
- en: '`line.split(":")`  searches through the String line and breaks it up every
    time it sees a `:`  (colon). And then it returns an array of Strings. For example,
    if line contained `thisXisXaXtest`  then `line.split("X")`  would return an array
    containing `{"this", "is", "a", "test" }`. In our case there’s only one colon
    in line, so it returns something like `{"refrigerator", "3" }`.'
  id: totrans-2959
  prefs: []
  type: TYPE_NORMAL
  zh: line.split(":")在字符串line中搜索并在每次看到“:”（冒号）时将其分割开。然后它返回一个字符串数组。例如，如果line包含thisXisXaXtest，那么line.split("X")将返回一个包含{"this"，"is"，"a"，"test"}的数组。在我们的情况下，line中只有一个冒号，所以它返回类似于{"refrigerator"，"3"}的内容。
- en: So, after line 128 `parts[0]`  contains the exit word (like “refrigerator”)
    and `parts[1]`  contains a String for the destination room number (like `"3"`).
    This doesn’t quite work for us, because we need the room number to be an integer,
    not a String.
  id: totrans-2960
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第128行之后，parts[0]包含出口词（如“refrigerator”），parts[1]包含目的地房间号的字符串（如“3”）。这对我们来说不太适用，因为我们需要房间号是整数，而不是字符串。
- en: 'Fortunately for us (again), Java’s standard library comes to the rescue. There
    is a built­in function to convert a String to an integer: `Integer.parseInt()`.
    We use this on line 130.'
  id: totrans-2961
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说（再次），Java的标准库来拯救我们。有一个内置函数可以将字符串转换为整数：Integer.parseInt()。我们在第130行使用了这个函数。
- en: Recall that i is the index of the slot in the exits array where we need to store
    the next value. So line 129 stores `parts[0]`  (the name of the exit) into the
    appropriate slot of the exits array. And line 130 converts `parts[1]`  (the room
    number to move to) from a String to an `int`  and stores that in the same slot
    of the destinations array. Then line 131 increments the exit index for the next
    go­around.
  id: totrans-2962
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，i是我们需要存储下一个值的出口数组中的槽的索引。因此，第129行将parts[0]（出口的名称）存储到出口数组的适当槽中。第130行将parts[1]（要移动到的房间号）从字符串转换为int，并将其存储在目的地数组的相同槽中。然后第131行增加下一轮的出口索引。
- en: Eventually we will hit a `%%`  and this loop, too, will stop looping. There
    is a potential bug here, however. The exits array only has ten slots. If the data
    file has a room with more than ten exits, this loop will just keep on going past
    the end of the array and blow up the program. So don’t do that.
  id: totrans-2963
  prefs: []
  type: TYPE_NORMAL
  zh: 最终我们会碰到“%%”，这个循环也会停止循环。然而，这里存在一个潜在的错误。出口数组只有十个槽。如果数据文件中有一个房间有超过十个出口，这个循环将继续超出数组的末端，并导致程序崩溃。所以不要这样做。
- en: After the loop ends, then our index *i* will contain the true number of rooms
    that we read in. So we store that into the *numExits* field of the current room
    on line 133.
  id: totrans-2964
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，我们的索引i将包含我们读入的房间的真实数量。所以我们将其存储到第133行当前房间的numExits字段中。
- en: And that should be it. All the fields in the room have been given values, and
    we `return`  this `Room`
  id: totrans-2965
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是这样了。房间中的所有字段都已经被赋值，我们返回这个Room。
- en: object to line 71 of the `loadRoomsFromFile()`  function.
  id: totrans-2966
  prefs: []
  type: TYPE_NORMAL
  zh: 对象到`loadRoomsFromFile()`函数的第71行。
- en: Study Drills
  id: totrans-2967
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习演练
- en: Write your own text adventure. If you think it turns out pretty good, email
    it to me!
  id: totrans-2968
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写你自己的文字冒险。如果你觉得它变得相当不错，就把它发给我！
- en: Add a save­game feature, so that the player can type something to stop the game,
    and the game will store their current room number to a text file and then load
    it back up when the game begins again.
  id: totrans-2969
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个保存游戏的功能，这样玩家可以输入一些内容来停止游戏，游戏将把他们当前的房间号存储到一个文本文件中，然后在游戏重新开始时加载它。
